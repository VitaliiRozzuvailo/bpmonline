// Autogenerated Code for schema BaseWorkplaceLoader (Start)
define('BaseWorkplaceLoaderResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("BaseWorkplaceLoader", ["BaseWorkplaceLoaderResources", 'sandbox'],
	function(resources, sandbox) {

		function load(args) {
			resetMenuByWorkplaceId(args);
			sandbox.publish('PostSectionMenuConfig', {modules: args.modules}, ['SectionMenuModuleId']);
		}

		function init() {
			var args = sandbox.publish('GetWorkplaceInfo');
			load(args);
		}

		function resetMenuByWorkplaceId(workplace) {
			var structure = Terrasoft.configuration.ModuleStructure;
			if (structure) {
				Terrasoft.each(structure, function(item) {
					if (hasModule(workplace.modules, item)) {
						item.hide = "false";
						setModulePosition(workplace.modules, item);
					} else {
						item.hide = "true";
					}
				}, this);
			}
		}

		function setModulePosition(workplaceModules, sectionItem) {
			if (workplaceModules && sectionItem) {
				Terrasoft.each(workplaceModules, function(item) {
					if (item.sectionName === sectionItem.sectionSchema ||
						item.sectionName === sectionItem.sectionModule) {
						sectionItem.position = item.position;
					}
				}, this);
			}
		}

		function hasModule(workplaceModules, sectionItem) {
			var has = false;
			if (workplaceModules && sectionItem) {
				Terrasoft.each(workplaceModules, function(item) {
					if (item.sectionName === sectionItem.sectionSchema ||
						item.sectionName === sectionItem.sectionModule) {
						has = true;
					}
				}, this);
			}
			return has;
		}

		return {
			init: init,
			load: load
		};
	});

				// Autogenerated Code for schema BaseWorkplaceLoader (End)
// Autogenerated Code for schema HotkeyItemsModule (Start)
define('HotkeyItemsModuleResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("HotkeyItemsModule", ["ext-base", "terrasoft", "sandbox"], function(Ext, Terrasoft, sandbox) {
		var hotkeyCollection = new Terrasoft.Collection();

		function init() {
			sandbox.publish("GetEventsConfig", {
				keydown: onKeydownHandler
			}, ["ViewModel_HotkeyItemsModule"]);
		}

		function onKeydownHandler(e) {
			var firedHotkeys = hotkeyCollection.filter(function(hotkey) {
				return (hotkey.keyCode === e.keyCode &&
					((hotkey.ctrl === e.ctrlKey) || (hotkey.ctrl === undefined)) &&
					((hotkey.shift === e.shiftKey) || (hotkey.shift === undefined)) &&
					((hotkey.alt === e.altKey) || (hotkey.alt === undefined)));
			});
			firedHotkeys.each(function(hotkey) {
				if (Ext.isFunction(hotkey.handler)) {
					hotkey.handler.call(hotkey.scope || hotkey, e);
				}
			});
		}

		return {
			init: init
		};
	}
);

				// Autogenerated Code for schema HotkeyItemsModule (End)
// Autogenerated Code for schema HotkeysModule (Start)
define('HotkeysModuleResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("HotkeysModule", ["ext-base", "sandbox"], function(Ext, sandbox) {
		return {
			init: function() {
				sandbox.loadModule("HotkeyItemsModule");
				sandbox.subscribe("GetEventsConfig", function(eventsHandlerConfig) {
					var body = Ext.getBody();
					for (var eventName in eventsHandlerConfig) {
						if (eventsHandlerConfig.hasOwnProperty(eventName)) {
							body.on(eventName, eventsHandlerConfig[eventName]);
						}
					}
				}, ["ViewModel_HotkeyItemsModule"]);
			}
		};
	}
);

				// Autogenerated Code for schema HotkeysModule (End)
// Autogenerated Code for schema IntroPage (Start)
define('IntroPageResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("IntroPage", ["performancecountermanager", "BaseSchemaModuleV2"],
	function(performanceManager) {
		/**
		 * @class Terrasoft.configuration.IntroPage
		 * Класс модуля главной страницы.
		 */
		Ext.define("Terrasoft.configuration.IntroPage", {
			alternateClassName: "Terrasoft.IntroPage",
			extend: "Terrasoft.BaseSchemaModule",

			/**
			 * Подписывается на сообщения для инициации параметров шапки приложения.
			 * @overridden
			 */
			init: function() {
				performanceManager.start(this.sandbox.id + "_Init");
				var headerConfig = {
					isMainMenu: true,
					isCaptionVisible: false,
					isContextHelpVisible: true
				};
				this.sandbox.publish("InitDataViews", headerConfig);
				this.sandbox.subscribe("NeedHeaderCaption", function() {
					this.sandbox.publish("InitDataViews", headerConfig);
				}, this);
				this.callParent(arguments);
				performanceManager.stop(this.sandbox.id + "_Init");
			},

			render: function(renderTo) {
				performanceManager.start(this.sandbox.id + "_Render");
				this.callParent(arguments);
				this.sandbox.publish("InitContextHelp", "0");
				performanceManager.stop(this.sandbox.id + "_Render");
			}
		});
		return Terrasoft.IntroPage;
	});


				// Autogenerated Code for schema IntroPage (End)
// Autogenerated Code for schema IntroPageUtilities (Start)
define('IntroPageUtilitiesResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("IntroPageUtilities", ["terrasoft"], function(Terrasoft) {
	Ext.define("Terrasoft.configuration.IntroPageUtilities", {
		extend: "Terrasoft.BaseObject",
		alternateClassName: "Terrasoft.IntroPageUtilities",

		singleton: true,

		/**
		 * Возвращает имя главной страницы по умолчанию.
		 * @param {Guid} defaultIntroPageId Значение Id для главной страницы по умолчанию.
		 * @param {Function} callback callback-функция.
		 * @param {Object} scope Контекст для выполнения.
		 */
		getDefaultIntroPageName: function(defaultIntroPageId, callback, scope) {
			var esq = Ext.create("Terrasoft.EntitySchemaQuery", {
				rootSchemaName: "ApplicationMainMenu",
				serverESQCacheParameters: {
					cacheLevel: Terrasoft.ESQServerCacheLevels.SESSION,
					cacheGroup: "ApplicationMainMenu",
					cacheItemName: defaultIntroPageId
				}
			});
			esq.addColumn("[SysSchema:UId:IntroPageUId].Name", "Name");
			esq.getEntity(defaultIntroPageId, function(result) {
				var entity = result.entity;
				if (result.success && entity) {
					var defaultIntroPageName = entity.get("Name");
					callback.call(scope, defaultIntroPageName);
				}
			}, this);
		}
	});
	return Terrasoft.IntroPageUtilities;
});


				// Autogenerated Code for schema IntroPageUtilities (End)
// Autogenerated Code for schema SimpleIntro (Start)
define('SimpleIntroResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={
	BasisCaption: 'Базис',
	AnalyticsCaption: 'Аналитика',
	DashboardsSectionCaption: 'Итоги',
	ContactSectionCaption: 'Контакты',
	FeedSectionCaption: 'Лента',
	AccountSectionCaption: 'Контрагенты',
	ActivitySectionCaption: 'Активности',
	KnowlegebaseSectionCaption: 'База знаний',
	SettingsCaption: 'Настройка',
	SectionDesignerCaption: 'Дизайнер системы',
	ProfileCaption: 'Профиль'
};
var localizableImages={
	'BasisIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'SimpleIntro', resourceItemName: 'BasisIcon' }},
	'AnalyticsIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'SimpleIntro', resourceItemName: 'AnalyticsIcon' }},
	'SettingsIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'SimpleIntro', resourceItemName: 'SettingsIcon' }}
};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define('SimpleIntroStructure', ['SimpleIntroResources'], function(resources) {return {schemaUId:'bb057159-e980-45c5-9e98-e93dc287e20a',schemaCaption: 'Схема главного меню для базового продукта', parentSchemaName: 'BaseIntroPageSchema', schemaName:'SimpleIntro',parentSchemaUId:'965b3e29-c42b-456f-90e0-8733809d280d',extendParent:false,type:Terrasoft.SchemaType.MODULE_VIEW_MODEL_SCHEMA,entitySchema:'',name:'',extend:'Terrasoft.model.BaseViewModel',schema:{leftPanel:[],rightPanel:[],actions:[],analytics:[]},methods:{},controlsConfig:{},customBindings:{},bindings:{},schemaDifferences:function(){

}};});
define("SimpleIntro", ["SimpleIntroResources", "ConfigurationConstants"], function(resources, ConfigurationConstants) {
		return {
			attributes: {
				"SystemDesignerVisible": {
					dataValueType: Terrasoft.DataValueType.BOOLEAN,
					type: Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
					value: true
				}
			},
			methods: {
				init: function() {
					this.callParent(arguments);
					this.isSystemDesignerVisible();
				},

				/**
				 * Устанавливает видимость для пункта "Дизайнер системы".
				 */
				isSystemDesignerVisible: function() {
					Terrasoft.SysSettings.querySysSettings(["BuildType"], function(sysSettings) {
						var buildType = sysSettings.BuildType;
						if (buildType && (buildType.value === ConfigurationConstants.BuildType.Public)) {
							this.set("SystemDesignerVisible", false);
						} else {
							this.set("SystemDesignerVisible", true);
						}
					}, this);
				}
			},
			diff: [
				{
					"operation": "merge",
					"name": "MainContainer",
					"values": {
						"markerValue": "main-menu"
					}
				},
				{
					"operation": "insert",
					"name": "BasicTile",
					"propertyName": "items",
					"parentName": "LeftContainer",
					"values": {
						"itemType": Terrasoft.ViewItemType.CONTAINER,
						"generator": "MainMenuTileGenerator.generateMainMenuTile",
						"caption": {"bindTo": "Resources.Strings.BasisCaption"},
						"cls": "basis",
						"icon": resources.localizableImages.BasisIcon,
						"items": []
					}
				},
				{
					"operation": "insert",
					"propertyName": "items",
					"parentName": "BasicTile",
					"name": "ESNFeedSectionV2",
					"values": {
						"itemType": Terrasoft.ViewItemType.LINK,
						"caption": {"bindTo": "Resources.Strings.FeedSectionCaption"},
						"tag": "SectionModuleV2/ESNFeedSectionV2/",
						"click": {"bindTo": "onNavigateTo"}
					}
				},
				{
					"operation": "insert",
					"propertyName": "items",
					"parentName": "BasicTile",
					"name": "AccountSectionV2",
					"values": {
						"itemType": Terrasoft.ViewItemType.LINK,
						"caption": {"bindTo": "Resources.Strings.AccountSectionCaption"},
						"tag": "SectionModuleV2/AccountSectionV2/",
						"click": {"bindTo": "onNavigateTo"}
					}
				},
				{
					"operation": "insert",
					"propertyName": "items",
					"parentName": "BasicTile",
					"name": "ContactSectionV2",
					"values": {
						"itemType": Terrasoft.ViewItemType.LINK,
						"caption": {"bindTo": "Resources.Strings.ContactSectionCaption"},
						"tag": "SectionModuleV2/ContactSectionV2/",
						"click": {"bindTo": "onNavigateTo"}
					}
				},
				{
					"operation": "insert",
					"propertyName": "items",
					"parentName": "BasicTile",
					"name": "ActivitySectionV2",
					"values": {
						"itemType": Terrasoft.ViewItemType.LINK,
						"caption": {"bindTo": "Resources.Strings.ActivitySectionCaption"},
						"tag": "SectionModuleV2/ActivitySectionV2/",
						"click": {"bindTo": "onNavigateTo"}
					}
				},
				{
					"operation": "insert",
					"propertyName": "items",
					"parentName": "BasicTile",
					"name": "KnowledgeBaseSectionV2",
					"values": {
						"itemType": Terrasoft.ViewItemType.LINK,
						"caption": {"bindTo": "Resources.Strings.KnowlegebaseSectionCaption"},
						"tag": "SectionModuleV2/KnowledgeBaseSectionV2/",
						"click": {"bindTo": "onNavigateTo"}
					}
				},
				{
					"operation": "insert",
					"name": "AnalyticsTile",
					"propertyName": "items",
					"parentName": "LeftContainer",
					"values": {
						"itemType": Terrasoft.ViewItemType.CONTAINER,
						"generator": "MainMenuTileGenerator.generateMainMenuTile",
						"caption": {"bindTo": "Resources.Strings.AnalyticsCaption"},
						"cls": "analytics",
						"icon": resources.localizableImages.AnalyticsIcon,
						"items": []
					}
				},
				{
					"operation": "insert",
					"propertyName": "items",
					"parentName": "AnalyticsTile",
					"name": "DashboardsModule",
					"values": {
						"itemType": Terrasoft.ViewItemType.LINK,
						"caption": {"bindTo": "Resources.Strings.DashboardsSectionCaption"},
						"tag": "DashboardsModule/",
						"click": {"bindTo": "onNavigateTo"}
					}
				},
				{
					"operation": "insert",
					"name": "SettingsTile",
					"propertyName": "items",
					"parentName": "LeftContainer",
					"values": {
						"itemType": Terrasoft.ViewItemType.CONTAINER,
						"generator": "MainMenuTileGenerator.generateMainMenuTile",
						"caption": {"bindTo": "Resources.Strings.SettingsCaption"},
						"cls": "settings",
						"icon": resources.localizableImages.SettingsIcon,
						"items": []
					}
				},
				{
					"operation": "insert",
					"propertyName": "items",
					"parentName": "SettingsTile",
					"name": "SystemDesigner",
					"values": {
						"itemType": Terrasoft.ViewItemType.LINK,
						"caption": {"bindTo": "Resources.Strings.SectionDesignerCaption"},
						"tag": "IntroPage/SystemDesigner",
						"click": {"bindTo": "onNavigateTo"},
						"visible": {"bindTo": "SystemDesignerVisible"}
					}
				},
				{
					"operation": "insert",
					"propertyName": "items",
					"parentName": "SettingsTile",
					"name": "ProfileModule",
					"values": {
						"itemType": Terrasoft.ViewItemType.LINK,
						"caption": {"bindTo": "Resources.Strings.ProfileCaption"},
						"tag": "ProfileModule",
						"click": {"bindTo": "onNavigateTo"}
					}
				}
			]
		};
	});


				// Autogenerated Code for schema SimpleIntro (End)
// Autogenerated Code for schema DashboardEnums (Start)
define('DashboardEnumsResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={
	StyleGreen: 'Зеленый',
	StyleMustard: 'Горчичный',
	StyleOrange: 'Оранжевый',
	StyleCoral: 'Коралловый',
	StyleViolet: 'Фиолетовый',
	StyleNavy: 'Синий',
	StyleBlue: 'Голубой',
	StyleDarkTurquoise: 'Темно-бирюзовый',
	StyleTurquoise: 'Бирюзовый'
};
var localizableImages={
	'ImageGreen': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'DashboardEnums', resourceItemName: 'ImageGreen' }},
	'ImageMustard': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'DashboardEnums', resourceItemName: 'ImageMustard' }},
	'ImageOrange': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'DashboardEnums', resourceItemName: 'ImageOrange' }},
	'ImageCoral': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'DashboardEnums', resourceItemName: 'ImageCoral' }},
	'ImageViolet': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'DashboardEnums', resourceItemName: 'ImageViolet' }},
	'ImageNavy': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'DashboardEnums', resourceItemName: 'ImageNavy' }},
	'ImageBlue': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'DashboardEnums', resourceItemName: 'ImageBlue' }},
	'ImageTurquoise': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'DashboardEnums', resourceItemName: 'ImageTurquoise' }},
	'ImageDarkTurquoise': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'DashboardEnums', resourceItemName: 'ImageDarkTurquoise' }}
};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("DashboardEnums", ["DashboardEnumsResources"], function(resources) {

	Ext.ns("Terrasoft.DashboardEnums");

	Terrasoft.DashboardEnums.WidgetType = {
		"Chart": {
			"view": {
				"moduleName": "ChartModule",
				"configurationMessage": "GetChartConfig"
			},
			"design": {
				"moduleName": "ConfigurationModuleV2",
				"configurationMessage": "GetModuleConfig",
				"resultMessage": "PostModuleConfig",
				"stateConfig": {
					"stateObj": {
						"designerSchemaName": "ChartDesigner"
					}
				}
			}
		},
		"Indicator": {
			"view": {
				"moduleName": "IndicatorModule",
				"configurationMessage": "GetIndicatorConfig"
			},
			"design": {
				"moduleName": "ConfigurationModuleV2",
				"configurationMessage": "GetModuleConfig",
				"resultMessage": "PostModuleConfig",
				"stateConfig": {
					"stateObj": {
						"designerSchemaName": "IndicatorDesigner"
					}
				}
			}
		},
		"Gauge": {
			"view": {
				"moduleName": "GaugeModule",
				"configurationMessage": "GetGaugeConfig"
			},
			"design": {
				"moduleName": "ConfigurationModuleV2",
				"configurationMessage": "GetModuleConfig",
				"resultMessage": "PostModuleConfig",
				"stateConfig": {
					"stateObj": {
						"designerSchemaName": "GaugeDesigner"
					}
				}
			}
		},
		"DashboardGrid": {
			"view": {
				"moduleName": "DashboardGridModule",
				"configurationMessage": "GetDashboardGridConfig"
			},
			"design": {
				"moduleName": "ConfigurationModuleV2",
				"configurationMessage": "GetModuleConfig",
				"resultMessage": "PostModuleConfig",
				"stateConfig": {
					"stateObj": {
						"designerSchemaName": "DashboardGridDesigner"
					}
				}
			}
		},
		"Module": {
			"view": {},
			"design": {
				"moduleName": "ConfigurationModuleV2",
				"configurationMessage": "GetModuleConfig",
				"resultMessage": "PostModuleConfig",
				"stateConfig": {
					"stateObj": {
						"designerSchemaName": "ModuleConfigEdit"
					}
				}
			}
		},
		"WebPage": {
			"view": {
				"moduleName": "WebPageModule",
				"configurationMessage": "GetWebPageConfig"
			},
			"design": {
				"moduleName": "ConfigurationModuleV2",
				"configurationMessage": "GetModuleConfig",
				"resultMessage": "PostModuleConfig",
				"stateConfig": {
					"stateObj": {
						"designerSchemaName": "WebPageDesigner"
					}
				}
			}
		}
	};

	/** @enum
	 *  Перечисление режимов представления в модуле графиков */
	Terrasoft.DashboardEnums.ChartDisplayMode = {
		/** Режим графика */
		CHART: 0,
		/** Режим списка */
		GRID: 1
	};

	/** @enum
	 *  Перечисление режимов отображения подписи оси графика
	 **/
	Terrasoft.DashboardEnums.ChartAxisPosition = {
		/** Не отображать */
		NONE: 0,
		/** Слева */
		LEFT: 1,
		/** Справа */
		RIGHT: 2
	};

	/** @enum
	 *  Перечисление типов сортироки графика
	 **/
	Terrasoft.DashboardEnums.ChartOrderBy = {
		/** По полую группировки */
		GROUP_BY_FIELD: "GroupByField",
		/** По результату выборки */
		CHART_ENTITY_COLUMN: "ChartEntityColumn"
	};

	/** @enum
	 *  Перечисление направлений сортироки графика
	 **/
	Terrasoft.DashboardEnums.ChartOrderDirection = {
		/** По возрастанию */
		ASCENDING: "Ascending",
		/** По убыванию */
		DESCENDING: "Descending"
	};

	/** @enum
	 * Набор цветов виджетов.
	 */
	Terrasoft.DashboardEnums.WidgetColorSet = [
	/** 0: Голубой */
		"#64b8df",
	/** 1: Зеленый */
		"#8ecb60",
	/** 2: Горчичный */
		"#e7cc61",
	/** 3: Оранжевый */
		"#eeaf4b",
	/** 4: Коралловый */
		"#ef7e63",
	/** 5: Фиолетовый */
		"#8e8eb7",
	/** 6: Синий */
		"#6483c3",
	/** 7: Бирюзовый */
		"#5bc8c4",
	/** 8: Темно-бирюзовый */
		"#4ca6a3"
	];

	/** @enum
	 * Объект соотношения стилей и цветов серий.
	 */
	Terrasoft.DashboardEnums.StyleColors = {
		/** Зеленый */
		"widget-green": Terrasoft.DashboardEnums.WidgetColorSet[1],
		/** Горчичный */
		"widget-mustard": Terrasoft.DashboardEnums.WidgetColorSet[2],
		/** Оранжевый */
		"widget-orange": Terrasoft.DashboardEnums.WidgetColorSet[3],
		/** Коралловый */
		"widget-coral": Terrasoft.DashboardEnums.WidgetColorSet[4],
		/** Фиолетовый */
		"widget-violet": Terrasoft.DashboardEnums.WidgetColorSet[5],
		/** Синий */
		"widget-navy": Terrasoft.DashboardEnums.WidgetColorSet[6],
		/** Голубой */
		"widget-blue": Terrasoft.DashboardEnums.WidgetColorSet[0],
		/** Бирюзовый */
		"widget-turquoise": Terrasoft.DashboardEnums.WidgetColorSet[7],
		/** Темно-бирюзовый */
		"widget-dark-turquoise": Terrasoft.DashboardEnums.WidgetColorSet[8]
	};

	/** @enum
	 * Перечисления стилей виджетов вместе с их заголовками и изображениями.
	 */
	Terrasoft.DashboardEnums.WidgetColor = {
		/** Зеленый */
		"widget-green": {
			value: "widget-green",
			displayValue: resources.localizableStrings.StyleGreen,
			imageConfig: resources.localizableImages.ImageGreen
		},
		/** Горчичный */
		"widget-mustard": {
			value: "widget-mustard",
			displayValue: resources.localizableStrings.StyleMustard,
			imageConfig: resources.localizableImages.ImageMustard
		},
		/** Оранжевый */
		"widget-orange": {
			value: "widget-orange",
			displayValue: resources.localizableStrings.StyleOrange,
			imageConfig: resources.localizableImages.ImageOrange
		},
		/** Коралловый */
		"widget-coral": {
			value: "widget-coral",
			displayValue: resources.localizableStrings.StyleCoral,
			imageConfig: resources.localizableImages.ImageCoral
		},
		/** Фиолетовый */
		"widget-violet": {
			value: "widget-violet",
			displayValue: resources.localizableStrings.StyleViolet,
			imageConfig: resources.localizableImages.ImageViolet
		},
		/** Синий */
		"widget-navy": {
			value: "widget-navy",
			displayValue: resources.localizableStrings.StyleNavy,
			imageConfig: resources.localizableImages.ImageNavy
		},
		/** Голубой */
		"widget-blue": {
			value: "widget-blue",
			displayValue: resources.localizableStrings.StyleBlue,
			imageConfig: resources.localizableImages.ImageBlue
		},
		/** Темно-бирюзовый */
		"widget-dark-turquoise": {
			value: "widget-dark-turquoise",
			displayValue: resources.localizableStrings.StyleDarkTurquoise,
			imageConfig: resources.localizableImages.ImageDarkTurquoise
		},
		/** Бирюзовый */
		"widget-turquoise": {
			value: "widget-turquoise",
			displayValue: resources.localizableStrings.StyleTurquoise,
			imageConfig: resources.localizableImages.ImageTurquoise
		}
	};
});


				// Autogenerated Code for schema DashboardEnums (End)
// Autogenerated Code for schema BaseIntroPageSchema (Start)
define('BaseIntroPageSchemaResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={
	ButtonCaption: 'Перейти',
	BannerCaption: 'Академия:',
	BannerHint: 'видео, документация, тесты по системе',
	MobileAppCaption: 'Мобильная версия',
	AndroidUrl: 'https://play.google.com/store/apps/details?id=com.bpmonline.mobile70',
	IosUrl: 'https://itunes.apple.com/us/app/bpmonline-mobile-7/id708432450?mt=8',
	LinkedInUrl: 'https://www.linkedin.com/company/166335?trk=tyah&trkInfo=tarId%3A1421760862245%2Ctas%3Aterrasoft%2Cidx%3A2-1-3',
	GoogleUrl: 'https://plus.google.com/u/0/116164135679912261451/posts',
	TwitterUrl: 'https://twitter.com/Terrasoft_CIS',
	FacebookUrl: 'https://www.facebook.com/terrasoftglobal?pnref=lhc',
	YoutubeUrl: 'https://www.youtube.com/user/terrasoftvideo',
	SdkCaption: 'руководство по разработке на платформе bpm\'online',
	CommunityCaption: 'Сообщество',
	CommunityUrl: 'http://www.community.terrasoft.ru/',
	WindowsUrl: 'http://www.windowsphone.com/ru-ru/store/app/bpm-online-mobile-7/759b1001-6e8d-42a4-a668-031ee6a23b81'
};
var localizableImages={
	'TwitterIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'BaseIntroPageSchema', resourceItemName: 'TwitterIcon' }},
	'FacebookIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'BaseIntroPageSchema', resourceItemName: 'FacebookIcon' }},
	'GoogleIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'BaseIntroPageSchema', resourceItemName: 'GoogleIcon' }},
	'YoutubeIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'BaseIntroPageSchema', resourceItemName: 'YoutubeIcon' }},
	'LinkedinIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'BaseIntroPageSchema', resourceItemName: 'LinkedinIcon' }},
	'AcademyBanner': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'BaseIntroPageSchema', resourceItemName: 'AcademyBanner' }},
	'Arrow': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'BaseIntroPageSchema', resourceItemName: 'Arrow' }},
	'playBtn': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'BaseIntroPageSchema', resourceItemName: 'playBtn' }},
	'playBtnActive': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'BaseIntroPageSchema', resourceItemName: 'playBtnActive' }},
	'AndroidIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'BaseIntroPageSchema', resourceItemName: 'AndroidIcon' }},
	'IosIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'BaseIntroPageSchema', resourceItemName: 'IosIcon' }},
	'CommunityIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'BaseIntroPageSchema', resourceItemName: 'CommunityIcon' }},
	'WindowsIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'BaseIntroPageSchema', resourceItemName: 'WindowsIcon' }}
};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define('BaseIntroPageSchemaStructure', ['BaseIntroPageSchemaResources'], function(resources) {return {schemaUId:'965b3e29-c42b-456f-90e0-8733809d280d',schemaCaption: 'Базовая схема главной страницы', parentSchemaName: '', schemaName:'BaseIntroPageSchema',parentSchemaUId:'',extendParent:false,type:Terrasoft.SchemaType.MODULE_VIEW_MODEL_SCHEMA,entitySchema:'',name:'',extend:'Terrasoft.model.BaseViewModel',schema:{leftPanel:[],rightPanel:[],actions:[],analytics:[]},methods:{},controlsConfig:{},customBindings:{},bindings:{},schemaDifferences:function(){

}};});
define("BaseIntroPageSchema", ["BaseIntroPageSchemaResources", "MainMenuTileGenerator"],
	function(resources, MainMenuTileGenerator) {
		return {
			attributes: {
				"LmsUrl": {dataValueType: Terrasoft.DataValueType.TEXT},

				"ProductEdition": {dataValueType: Terrasoft.DataValueType.TEXT},

				"ConfigurationVersion": {dataValueType: Terrasoft.DataValueType.TEXT},

				"AcademyUrl": {dataValueType: Terrasoft.DataValueType.TEXT},

				"VideoUrl": {dataValueType: Terrasoft.DataValueType.TEXT},

				"VideoCaption": {dataValueType: Terrasoft.DataValueType.TEXT},

				"IsAcademyBannerVisible": {
					dataValueType: Terrasoft.DataValueType.BOOLEAN,
					value: true
				},

				"IsMobilePannerVisible": {
					dataValueType: Terrasoft.DataValueType.BOOLEAN,
					value: true
				},

				"IsSdkPanelVisible": {
					dataValueType: Terrasoft.DataValueType.BOOLEAN,
					value: false
				},

				"IsComunityPanelVisible": {
					dataValueType: Terrasoft.DataValueType.BOOLEAN,
					value: true
				},

				"IsSocialAccountsPanelVisible": {
					dataValueType: Terrasoft.DataValueType.BOOLEAN,
					value: true
				}
			},
			messages: {
				/**
				 * @message SelectedSideBarItemChanged
				 * Изменяет выделение текущего раздела в меню раделов левой панели.
				 * @param {String} Структура раздела (Напр. "SectionModuleV2/AccountPageV2/" или "DashboardsModule/").
				*/
				"SelectedSideBarItemChanged": {
					mode: this.Terrasoft.MessageMode.PTP,
					direction: this.Terrasoft.MessageDirectionType.PUBLISH
				}
			},
			methods: {
				onNavigateTo: function(event, tag) {
					this.showBodyMask();
					this.sandbox.publish("SelectedSideBarItemChanged", tag, ["sectionMenuModule"]);
					this.sandbox.publish("PushHistoryState", {
						hash: tag
					});
					return false;
				},

				navigateToAcademy: function() {
					var path = this.get("LmsUrl");
					var parameters = [];
					var productEdition = this.get("ProductEdition");
					if (productEdition) {
						parameters.push("product=" + encodeURIComponent(productEdition));
					}
					var configurationVersion = this.get("ConfigurationVersion");
					if (configurationVersion) {
						parameters.push("ver=" + encodeURIComponent(configurationVersion));
					}
					var academyUrl = this.get("AcademyUrl");
					if (academyUrl) {
						window.open(academyUrl);
					} else {
						window.open(path + "?" + parameters.join("&"));
					}
				},

				CommunityClick: function() {
					var communityLink = this.get("Resources.Strings.CommunityUrl");
					window.open(communityLink);
				},

				SdkClick: function() {
					var path = this.get("LmsUrl");
					var parameters = [];
					parameters.push("product=" + encodeURIComponent("SDK"));
					var configurationVersion = this.get("ConfigurationVersion");
					if (configurationVersion) {
						parameters.push("ver=" + encodeURIComponent(configurationVersion));
					}
					window.open(path + "?" + parameters.join("&"));
				},

				init: function(callback, scope) {
					this.callParent([function() {
						var sysSettingsNameArray = ["UseLMSDocumentation", "LMSUrl", "ProductEdition",
							"ConfigurationVersion"];
						this.Terrasoft.SysSettings.querySysSettings(sysSettingsNameArray, function(values) {
							this.sandbox.publish("SelectedSideBarItemChanged", "", ["sectionMenuModule"]);
							this.set("LmsUrl", values.LMSUrl);
							this.set("ProductEdition", values.ProductEdition);
							this.set("ConfigurationVersion", values.ConfigurationVersion);
							this.set("UseLMSDocumentation", values.UseLMSDocumentation);
							var currentCultureId = this.Terrasoft.Resources.CultureSettings.currentCultureId;
							var russianCultureId = "1a778e3f-0a8e-e111-84a3-00155d054c03";
							if (values.UseLMSDocumentation === false || (currentCultureId !== russianCultureId)) {
								this.set("IsAcademyBannerVisible", false);
							}
						}, this);

						var select = Ext.create("Terrasoft.EntitySchemaQuery", {
							rootSchemaName: "IntroPageLookup",
							serverESQCacheParameters: {
								cacheLevel: Terrasoft.ESQServerCacheLevels.SESSION,
								cacheGroup: "ApplicationMainMenu",
								cacheItemName: scope.schemaName + "Lookup"
							}
						});
						select.addColumn("AcademyUrl");
						select.addColumn("VideoUrl");
						select.addColumn("VideoCaption");
						select.filters.addItem(
							this.Terrasoft.createColumnFilterWithParameter(
								this.Terrasoft.ComparisonType.EQUAL, "CodePage", scope.schemaName));
						select.execute(function(result) {
							this.preparePageLinks(result, callback, scope);
						}, this);
					}, this]);
				},

				onRender: function() {
					var sdkContainer = this.Ext.get("sdk-container-el");
					var communityContainer = this.Ext.get("community-container-el");
					if (!this.Ext.isEmpty(sdkContainer)) {
						sdkContainer.on("click", this.SdkClick, this);
					}
					if (!this.Ext.isEmpty(communityContainer)) {
						communityContainer.on("click", this.CommunityClick, this);
					}
				},

				/**
				 * Получает ссылки из справочника.
				 * @param {Object} response Ответ от сервера.
				 * @param {Object} callback функция обратного вызова.
				 * @param {Object} scope контекст выполнения.
				 */
				preparePageLinks: function(response, callback, scope) {
					var needRender = false;
					if (response.success && response.collection.getCount() > 0) {
						var row = response.collection.getItems()[0];
						this.set("AcademyUrl", row.get("AcademyUrl"));
						this.set("VideoUrl", row.get("VideoUrl"));
						this.set("VideoCaption", row.get("VideoUrl"));
						if (row.get("VideoUrl") && row.get("VideoUrl").length > 0) {
							var videoPanel = MainMenuTileGenerator.generateVideoPanel({
								"playBtnIcon": resources.localizableImages.playBtn,
								"activePlayBtnIcon": resources.localizableImages.playBtnActive,
								"playlist": [{
									"videoUrl": row.get("VideoUrl"),
									"caption":  row.get("VideoCaption")
								}]
							});
							var videoPanelEl = this.Ext.create("Terrasoft.Container", videoPanel);
							needRender = true;
						}
					}
					if (callback) {
						callback.call(scope);
						if (needRender) {
							this.Ext.get("VideoPanel").remove();
							videoPanelEl.render(this.Ext.get("right-container"), 0);
						}
					}
				}
			},
			diff: [
				{
					"operation": "insert",
					"name": "MainContainer",
					"values": {
						"itemType": Terrasoft.ViewItemType.CONTAINER,
						id: "main-container",
						"classes": {
							"wrapClassName": ["main-container", "x-unselectable"]
						},
						"items": []
					}
				},
				{
					"operation": "insert",
					"name": "LeftContainer",
					"propertyName": "items",
					"parentName": "MainContainer",
					"values": {
						"itemType": Terrasoft.ViewItemType.CONTAINER,
						id: "left-container",
						"classes": {
							"wrapClassName": ["left-container", "main-container-panel"]
						},
						"items": []
					}
				},
				{
					"operation": "insert",
					"name": "RightContainer",
					"propertyName": "items",
					"parentName": "MainContainer",
					"values": {
						"itemType": Terrasoft.ViewItemType.CONTAINER,
						"id": "right-container",
						"classes": {
							"wrapClassName": ["right-container", "main-container-panel"]
						},
						"items": []
					}
				},
				{
					"operation": "insert",
					"name": "VideoPanel",
					"propertyName": "items",
					"parentName": "RightContainer",
					"values": {
						"itemType": Terrasoft.ViewItemType.CONTAINER,
						"generator": "MainMenuTileGenerator.generateVideoPanel",
						"playBtnIcon": resources.localizableImages.playBtn,
						"activePlayBtnIcon": resources.localizableImages.playBtnActive,
						"playlist": []
					}
				},
				{
					"operation": "insert",
					"name": "AcademyPanel",
					"propertyName": "items",
					"parentName": "RightContainer",
					"values": {
						"itemType": Terrasoft.ViewItemType.CONTAINER,
						"generator": "MainMenuTileGenerator.generateAcademyBaner",
						"bannerImage": resources.localizableImages.AcademyBanner,
						"bannerCaption": {"bindTo": "Resources.Strings.BannerCaption"},
						"bannerHint": {"bindTo": "Resources.Strings.BannerHint"},
						"visible": {bindTo: "IsAcademyBannerVisible"},
						"navigationConfig": {
							"caption": {"bindTo": "Resources.Strings.ButtonCaption"},
							"click": {"bindTo": "navigateToAcademy"},
							"rightIcon": resources.localizableImages.Arrow
						},
						"items": []
					}
				},
				{
					"operation": "insert",
					"name": "MobileAppLinksPanel",
					"propertyName": "items",
					"parentName": "RightContainer",
					"values": {
						"visible": {"bindTo": "IsMobilePannerVisible"},
						"caption": {"bindTo": "Resources.Strings.MobileAppCaption"},
						"androidUrl": resources.localizableStrings.AndroidUrl,
						"iosUrl": resources.localizableStrings.IosUrl,
						"windowsUrl": resources.localizableStrings.WindowsUrl,
						"androidIcon": resources.localizableImages.AndroidIcon,
						"iosIcon": resources.localizableImages.IosIcon,
						"windowsIcon": resources.localizableImages.WindowsIcon,
						"itemType": Terrasoft.ViewItemType.CONTAINER,
						"generator": "MainMenuTileGenerator.generateMobileAppBaner",
						"items": []
					}
				},
				{
					"operation": "insert",
					"name": "TerrasoftAccountsLinksPanel",
					"propertyName": "items",
					"parentName": "RightContainer",
					"values": {
						"IsComunityPanelVisible": {"bindTo": "IsComunityPanelVisible"},
						"IsSdkPanelVisible": {"bindTo": "IsSdkPanelVisible"},
						"IsSocialAccountsPanelVisible": {"bindTo": "IsSocialAccountsPanelVisible"},
						"sdkCaption": {"bindTo": "Resources.Strings.SdkCaption"},
						"communityCaption": {"bindTo": "Resources.Strings.CommunityCaption"},
						"communityIcon": resources.localizableImages.CommunityIcon,
						"itemType": Terrasoft.ViewItemType.CONTAINER,
						"generator": "MainMenuTileGenerator.generateTerrasoftAccountsLinks",
						"socialAccounts": []
					}
				},
				{
					"operation": "insert",
					"name": "LinkedIn",
					"propertyName": "socialAccounts",
					"parentName": "TerrasoftAccountsLinksPanel",
					"values": {
						"icon": resources.localizableImages.LinkedinIcon,
						"href": resources.localizableStrings.LinkedInUrl,
						"markerValue": "LinkedIn"
					}
				},
				{
					"operation": "insert",
					"name": "Google",
					"propertyName": "socialAccounts",
					"parentName": "TerrasoftAccountsLinksPanel",
					"values": {
						"icon": resources.localizableImages.GoogleIcon,
						"href": resources.localizableStrings.GoogleUrl,
						"markerValue": "Google"
					}
				},
				{
					"operation": "insert",
					"name": "Twitter",
					"propertyName": "socialAccounts",
					"parentName": "TerrasoftAccountsLinksPanel",
					"values": {
						"icon": resources.localizableImages.TwitterIcon,
						"href": resources.localizableStrings.TwitterUrl,
						"markerValue": "Twitter"
					}
				},
				{
					"operation": "insert",
					"name": "Facebook",
					"propertyName": "socialAccounts",
					"parentName": "TerrasoftAccountsLinksPanel",
					"values": {
						"icon": resources.localizableImages.FacebookIcon,
						"href": resources.localizableStrings.FacebookUrl,
						"markerValue": "Facebook"
					}
				},
				{
					"operation": "insert",
					"name": "Youtube",
					"propertyName": "socialAccounts",
					"parentName": "TerrasoftAccountsLinksPanel",
					"values": {
						"icon": resources.localizableImages.YoutubeIcon,
						"href": resources.localizableStrings.YoutubeUrl,
						"markerValue": "Youtube"
					}
				}
			]
		};
	});


				// Autogenerated Code for schema BaseIntroPageSchema (End)
// Autogenerated Code for schema NavigationModule (Start)
define('NavigationModuleResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("NavigationModule", ["ext-base", "terrasoft", "sandbox"],
	function(Ext, Terrasoft, sandbox) {

	var router = Terrasoft.router.Router;

	function init() {
		router.on("stateChanged", onRouterStateChanged, router);
		sandbox.subscribe("PushHistoryState", onPushHistoryState);
		sandbox.subscribe("ReplaceHistoryState", onReplaceHistoryState);
		sandbox.subscribe("GetHistoryState", onGetHistoryState);
		sandbox.subscribe("BackHistoryState", onBackHistoryState);
		sandbox.subscribe("ForwardHistoryState", onForwardHistoryState);
		onRouterStateChanged();
		sandbox.publish("NavigationModuleLoaded");
	}

	function onReplaceHistoryState(historyState) {
		router.replaceState(historyState.stateObj, historyState.pageTitle, historyState.hash, historyState.silent);
	}

	function onRouterStateChanged() {
		var history = onGetHistoryState();
		sandbox.publish("HistoryStateChanged", history);
	}

	/**
	 * Возвращает последнее состояние истории браузера.
	 * Проверка первого символа клиентской части адреса связана с проблемами в ie версии 9
	 * @returns {Object} Последнее состояние истории браузера
	 */
	function onGetHistoryState() {
		var hash = router.getHash();
		if (hash.charAt(0) === "/") {
			hash = hash.slice(1);
		}
		var history = {
			state: router.getState(),
			hash: splitHistoryState(hash)
		};
		return history;
	}

	function splitHistoryState(historyState) {
		var historyStateParts = historyState.split("?");
		var params = historyStateParts[0].split("/");
		var history = {};
		history.historyState = historyState;
		history.moduleName = params[0];
		history.entityName = params[1];
		history.operationType =  params[2];
		var paramExtr = 3;
		if (params.length > 4 && history.operationType !== "add") {
			paramExtr = 4;
			if (params[3]) {
				history.recordId = params[3];
			}
		}
		if (params.length > 4) {
			var valuePairs = (params.length - paramExtr) / 2;
			history.valuePairs = [];
			for (var i = 0; i < valuePairs; i++) {
				var index = paramExtr + i * 2;
				history.valuePairs[i] = {
					name: params[index],
					value: params[index + 1]
				};
			}
		} else {
			if (params[3]) {
				history.recordId = params[3];
			}
		}
		return history;
	}

	function onPushHistoryState(historyState) {
		var result = sandbox.publish("BeforeHistoryChanging", historyState);
		if (Ext.isEmpty(result) || result) {
			router.pushState(historyState.stateObj, historyState.pageTitle, historyState.hash, historyState.silent);
		}
		if (historyState.silent === true) {
			sandbox.publish("RefreshCacheHash");
		}
	}

	function onBackHistoryState() {
		router.back();
	}

	function onForwardHistoryState() {
		router.forward();
	}

	return {
		"init": init
	};
});


				// Autogenerated Code for schema NavigationModule (End)
// Autogenerated Code for schema SyncModule (Start)
define('SyncModuleResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("SyncModule", ["ext-base", "terrasoft"], function(Ext, Terrasoft) {

	/**
	 * Инициализирует модуль.
	 */
	function init() {
		Terrasoft.ServerChannel.on(Terrasoft.EventName.ON_MESSAGE, onChannelMessage, this);
	}

	/**
	 * Обрабатывает сообщение серверного канала сообщений.
	 * @protected
	 * @param {Object} scope Контекст выполнения.
	 * @param {Object} message Объект сообщения.
	 */
	function onChannelMessage(scope, message) {
		if (Ext.isEmpty(message) || Ext.isEmpty(window.console)) {
			return;
		}
		var header = message.Header;
		if (Ext.isEmpty(header) || (header.Sender !== "SyncMsgLogger")) {
			return;
		}
		var body = message.Body;
		switch (header.BodyTypeName) {
			case "Info":
				window.console.log(body);
				break;
			case "Error":
				window.console.error(body);
				break;
			default:
				break;
		}
	}

	return {
		init: init
	};
});

				// Autogenerated Code for schema SyncModule (End)
// Autogenerated Code for schema MainMenuTileGenerator (Start)
define('MainMenuTileGeneratorResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("MainMenuTileGenerator", ["ext-base", "terrasoft", "ViewGeneratorV2"],
	function(Ext, Terrasoft) {
		Ext.define("Terrasoft.configuration.MainMenuTileGenerator", {
			extend: "Terrasoft.ViewGenerator",
			alternateClassName: "Terrasoft.MainMenuTileGenerator",

			/**
			 * Генерирует конфигурацию представления для {Terrasoft.ContainerList}.
			 * @protected
			 * @virtual
			 * @param {Object} config Описание элемента представления.
			 * @return {Object} Возвращает сгенерированное представление ContainerList.
			 */
			generateMainMenuTile: function(config) {
				var clonedConfig = Terrasoft.deepClone(config);
				var result = this.generateTileView(clonedConfig);
				return result;
			},

			generateTileView: function(tile) {
				var tileId = "tile-" + tile.name;
				var tileItemsContainerCfg = {
					className: "Terrasoft.Container",
					classes: {
						wrapClassName: ["items-container"]
					},
					items: []
				};
				var iconContainer = {
					className: "Terrasoft.Container",
					classes: {
						wrapClassName: ["image-panel"]
					}
				};
				if (tile.icon) {
					var iconUrl = Terrasoft.ImageUrlBuilder.getUrl(tile.icon);
					iconContainer.styles = {
						"wrapStyles": {"background-image": "url(" + iconUrl + ")"}
					};
				}
				var items = this.generateTileItems(tile.items);
				tileItemsContainerCfg.items = items;
				var wrapClasses = ["tile"];
				if (!Ext.isEmpty(tile.cls)) {
					var customClasses = Ext.isArray(tile.cls) ? tile.cls : [tile.cls];
					wrapClasses = wrapClasses.concat(customClasses);
				}
				var tileContainer = {
					className: "Terrasoft.Container",
					id: tileId,
					classes: {
						wrapClassName: wrapClasses
					},
					markerValue: tile.markerValue || tile.caption,
					items: [
						{
							className: "Terrasoft.Container",
							id: tileId + "-color-panel",
							classes: {
								wrapClassName: ["color-panel"]
							}
						},
						{
							className: "Terrasoft.Container",
							classes: {
								wrapClassName: ["view-panel"]
							},
							items: [
								{
									className: "Terrasoft.Label",
									id: tileId + "-caption",
									caption: tile.caption,
									classes: {
										labelClass: ["tile-caption"]
									}
								},
								{
									className: "Terrasoft.Container",
									classes: {
										wrapClassName: ["content-panel"]
									},
									items: [
										iconContainer,
										tileItemsContainerCfg
									]
								}
							]
						}
					]
				};
				return tileContainer;
			},

			generateTileItems: function(itemsCfg) {
				var result = [];
				Terrasoft.each(itemsCfg, function(item) {
					var tileItemContainer = {
						className: "Terrasoft.Container",
						classes: {
							wrapClassName: ["tile-item"]
						},
						visible: (item.visible === undefined) ? true : item.visible,
						items: []
					};
					var tileItemView =
					{
						className: "Terrasoft.Hyperlink",
						caption: item.caption,
						markerValue: item.markerValue || item.caption,
						tag: item.tag
					};
					if (item.click) {
						tileItemView.click = item.click;
					}
					tileItemContainer.items.push(tileItemView);
					result.push(tileItemContainer);
				}, this);
				return result;
			},

			generateVideoPanel: function(config) {
				var playBtnIcon = Terrasoft.ImageUrlBuilder.getUrl(config.playBtnIcon);
				var activePlayBtnIcon = Terrasoft.ImageUrlBuilder.getUrl(config.activePlayBtnIcon);
				var playlist = this.generatePlayList(config.playlist, playBtnIcon, activePlayBtnIcon);
				var defaultVideoUrl = playlist.length > 0 ? playlist[0].href : "";
				var result = {
					className: "Terrasoft.Container",
					classes: {
						wrapClassName: ["video-container", "right-item"]
					},
					"id": "VideoPanel",
					"selectors": {"wrapEl": "#VideoPanel"},
					markerValue: config.markerValue || "video-container",
					items: [
						{
							className: "Terrasoft.Container",
							html: '<iframe name="bpmonline-video" id="bpmonline-video" width="560" height="315" src="'+encodeURI(defaultVideoUrl)+'" frameborder="0" allowfullscreen></iframe>',
							selectors: {
								wrapEl: "#bpmonline-video"
							}
						}
					]
				};
				result.items = result.items.concat(playlist);
				result.visible = (playlist.length > 0);
				return result;
			},

			generatePlayList: function(itemsCfg, playBtnIcon, activePlayBtnIcon) {
				var playlist = [];
				//"active-video-link"
				Terrasoft.each(itemsCfg, function(item) {
					if (!Ext.isEmpty(item.videoUrl)) {
						var playlistItem = {
							className: "Terrasoft.Hyperlink",
							tpl: [
								'<a id="{id}" name="{name}" href="{href}" target="{target}" class="{hyperlinkClass}" style="{hyperlinkStyle}" title="{hint}" type="{type}">',
								'<div class="{videoLinkImageClass}" style="{playBtnStyle}"></div>{caption}',
								'</a>'
							],
							target: "bpmonline-video",
							href: item.videoUrl,
							caption: item.caption,
							classes: {
								hyperlinkClass: ["ts-box-sizing", "video-link"],
								videoLinkImageClass: ["play-video-image"]
							},
							tplData: {
								playBtnStyle: {
									"background-image": "url(" + playBtnIcon + ")"
								}
							}
						};
						playlist.push(playlistItem);
					}
				}, this);
				return playlist;
			},

			generateAcademyBaner: function(config) {
				var bannerUrl = Terrasoft.ImageUrlBuilder.getUrl(config.bannerImage);
				var navigationConfig = config.navigationConfig;
				var navigateBtnRightUrl = Terrasoft.ImageUrlBuilder.getUrl(navigationConfig.rightIcon);
				var wrapClassName = ["academy-container", "right-item"];
				if (!Ext.isEmpty(config.wrapClassName)) {
					var customClasses = Ext.isArray(config.wrapClassName)
						? config.wrapClassName
						: [config.wrapClassName];
					wrapClassName = wrapClassName.concat(customClasses);
				}
				var result = {
					className: "Terrasoft.Container",
					classes: {
						wrapClassName: wrapClassName
					},
					markerValue: config.markerValue || "academy-container",
					visible: config.visible,
					items: [
						{
							className: "Terrasoft.Component",
							tpl: '<img id="academy-img" class="academy-image" src="'+bannerUrl+'"/>',
							selectors: {
								wrapEl: "#academy-img"
							}
						},
						{
							className: "Terrasoft.Container",
							classes: {
								wrapClassName: ["academy-caption-container"]
							},
							items: [
								{
									className: "Terrasoft.Label",
									caption: config.bannerCaption,
									classes: {
										labelClass: ["academy-caption"]
									}
								},
								{
									className: "Terrasoft.Label",
									caption: config.bannerHint,
									classes: {
										labelClass: ["academy-hint"]
									}
								}
							]
						},
						{
							className: "Terrasoft.Button",
							caption: navigationConfig.caption,
							classes: {
								wrapperClass: ["goto-academy-button"]
							},
							click: navigationConfig.click,
							iconAlign: Terrasoft.controls.ButtonEnums.iconAlign.RIGHT,
							imageConfig: {
								source: Terrasoft.ImageSources.URL,
								url: navigateBtnRightUrl
							},
							markerValue: "GoToAcademyButton"
						}
					]
				};
				return result;
			},

			generateMobileAppBaner: function(config) {
				var androidIcon =  Terrasoft.ImageUrlBuilder.getUrl(config.androidIcon);
				var iosIcon =  Terrasoft.ImageUrlBuilder.getUrl(config.iosIcon);
				var windowsIcon =  Terrasoft.ImageUrlBuilder.getUrl(config.windowsIcon);
				var result = {
					className: "Terrasoft.Container",
					classes: {
						wrapClassName: ["mobile-apps-container", "right-item"]
					},
					visible: config.visible,
					markerValue: config.markerValue || "mobile-apps-container",
					items: [
						{
							className: "Terrasoft.Label",
							caption: config.caption
						},
						{
							className: "Terrasoft.Container",
							classes: {
								wrapClassName: ["mobile-apps-links-container"]
							},
							items: [
								{
									className: "Terrasoft.Component",
									tpl: [
										'<a id="windows-store" class="{linkClass}" href="{storeLink}" target="_blank" rel="nofollow">',
										'<img src="{imageUrl}" class="{imageClass}" alt="Download on the App Store">',
										'</a>'
									],
									tplData: {
										storeLink: config.windowsUrl,
										imageUrl: windowsIcon
									},
									classes: {
										linkClass: ["mobile-app-link"],
										imageClass: ["mobile-app-image"]
									},
									selectors: {
										wrapEl: "#windows-store"
									},
									markerValue: "windows-store"
								},
								{
									className: "Terrasoft.Component",
									tpl: [
										'<a id="app-store" class="{linkClass}" href="{storeLink}" target="_blank" rel="nofollow">',
										'<img src="{imageUrl}" class="{imageClass}" alt="Download on the App Store">',
										'</a>'
									],
									tplData: {
										storeLink: config.iosUrl,
										imageUrl: iosIcon
									},
									classes: {
										linkClass: ["mobile-app-link"],
										imageClass: ["mobile-app-image"]
									},
									selectors: {
										wrapEl: "#app-store"
									},
									markerValue: "app-store"
								},
								{
									className: "Terrasoft.Component",
									tpl: [
										'<a id="play-market" class="{linkClass}" href="{storeLink}" target="_blank" rel="nofollow">',
										'<img src="{imageUrl}" class="{imageClass}" alt="Download on the App Store">',
										'</a>'
									],
									tplData: {
										storeLink: config.androidUrl,
										imageUrl: androidIcon
									},
									classes: {
										linkClass: ["mobile-app-link"],
										imageClass: ["mobile-app-image"]
									},
									selectors: {
										wrapEl: "#play-market"
									},
									markerValue: "play-market"
								}
							]
						}
					]
				};
				return result;
			},

			generateTerrasoftAccountsLinks: function(config) {
				var socialAccountItems = this.generateSocialAccountButtons(config.socialAccounts);
				var communityIcon =  Terrasoft.ImageUrlBuilder.getUrl(config.communityIcon);
				var wrapClassName = ["references-container", "right-item"];
				if (!Ext.isEmpty(config.wrapClassName)) {
					var customClasses = Ext.isArray(config.wrapClassName)
						? config.wrapClassName
						: [config.wrapClassName];
					wrapClassName = wrapClassName.concat(customClasses);
				}
				var result = {
					className: "Terrasoft.Container",
					classes: {
						wrapClassName: wrapClassName
					},
					markerValue: config.markerValue || "references-container",
					items: [
						{
							className: "Terrasoft.Container",
							classes: {
								wrapClassName: ["sdk-container"]
							},
							id: "sdk-container-el",
							visible: config.IsSdkPanelVisible,
							items: [
								{
									className: "Terrasoft.Container",
									classes: {
										wrapClassName: ["sdk-caption-container"]
									},
									items: [
										{
											className: "Terrasoft.Label",
											classes: {
												labelClass: ["sdk-caption"]
											},
											caption: "SDK"
										}
									]
								},
								{
									className: "Terrasoft.Label",
									classes: {
										labelClass: ["sdk-hint"]
									},
									caption: config.sdkCaption
								}
							]
						},
						{
							className: "Terrasoft.Container",
							classes: {
								wrapClassName: ["community-container"]
							},
							visible: config.IsComunityPanelVisible,
							id: "community-container-el",
							items: [
								{
									className: "Terrasoft.Component",
									tpl: '<img id="community-icon" class="community-icon" src="'+communityIcon+'"/>',
									selectors: {
										wrapEl: "#community-icon"
									}
								},
								{
									className: "Terrasoft.Label",
									classes: {
										labelClass: ["community-caption"]
									},
									caption: config.communityCaption
								}
							],
							markerValue: "CommunityContainer"
						},
						{
							className: "Terrasoft.Container",
							classes: {
								wrapClassName: ["social-networks-container"]
							},
							visible: config.IsSocialAccountsPanelVisible,
							items: socialAccountItems
						}
					]
				};
				return result;
			},

			generateSocialAccountButtons: function(itemsCfg) {
				var items = [];
				Terrasoft.each(itemsCfg, function(item) {
					var itemIcon = Terrasoft.ImageUrlBuilder.getUrl(item.icon);
					var itemCfg = {
						className: "Terrasoft.Hyperlink",
						tpl: [
								'<a id="{id}" name="{name}" href="{href}" target="_blank" class="{hyperlinkClass}" style="{hyperlinkStyle}" title="{hint}" type="{type}">',
								'<img src="{imageSrc}">',
								'</a>'
							],
						tplData: {
							imageSrc: itemIcon
						},
						href: item.href,
						classes: {
							hyperlinkClass: ["social-network"]
						},
						markerValue: item.markerValue
					};
					items.push(itemCfg);
				}, this);
				return items;
			}
		});

		return new Terrasoft.configuration.MainMenuTileGenerator();
	});


				// Autogenerated Code for schema MainMenuTileGenerator (End)
// Autogenerated Code for schema AcademyUtilities (Start)
define('AcademyUtilitiesResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("AcademyUtilities", ["terrasoft"], function(Terrasoft) {
	Ext.define("Terrasoft.configuration.AcademyUtilities", {
		extend: "Terrasoft.BaseObject",
		alternateClassName: "Terrasoft.AcademyUtilities",

		singleton: true,

		/**
		 * Асинхронно получает ссылку на документацию.
		 * Если значение contextHelpCode указано, то ссылка формируется на основе значений, извлекаемых из таблицы
		 * контекстной справки и дополненых в случае отсутствия значениями из системных настроек.
		 * Если значение contextHelpCode не указано, то ссылка формируется на основе значений системных настроек.
		 * @param {Object} config Объект конфигурации.
		 * @param {Function} config.callback Функция обратного вызова.
		 * @param {Object} config.scope Контекст для выполнения.
		 * @param {String} config.contextHelpCode (optional) Код контекстной справки.
		 * @param {Number} config.contextHelpId (optional) Идентификатор контекстной справки.
		 */
		getUrl: function(config) {
			if (!config) {
				return;
			}
			var callback = config.callback || Terrasoft.emptyFn;
			var scope = config.scope || this;
			var contextHelpCode = config.contextHelpCode;
			var contextHelpId = config.contextHelpId;
			this.getHelpConfigFromSysSettings(contextHelpId, function(defaultHelpConfig) {
				if (contextHelpCode) {
					this.getHelpConfigFromDb(contextHelpCode, function(helpConfig) {
						if (helpConfig) {
							Terrasoft.each(defaultHelpConfig, function(propertyValue, propertyName) {
								if (Ext.isEmpty(helpConfig[propertyName])) {
									helpConfig[propertyName] = propertyValue;
								}
							});
						} else {
							helpConfig = defaultHelpConfig;
						}
						this.buildUrl(helpConfig, callback, scope);
					}, this);
				} else {
					this.buildUrl(defaultHelpConfig, callback, scope);
				}
			}, this);
		},

		/**
		 * Асинхронно получает конфигурацию из системных настроек для построения ссылки на документацию.
		 * @private
		 * @param {Number} contextHelpId Идентификатор контекстной справки.
		 * @param {Function} callback Функция обратного вызова.
		 * @param {Object} scope Контекст для выполнения.
		 */
		getHelpConfigFromSysSettings: function(contextHelpId, callback, scope) {
			var sysSettingsNameArray = ["UseLMSDocumentation", "LMSUrl", "ProductEdition", "ConfigurationVersion",
				"EnableContextHelp"];
			Terrasoft.SysSettings.querySysSettings(sysSettingsNameArray,
				function(values) {
					var helpConfig = {};
					if (values) {
						helpConfig = {
							useLmsDocumentation: values.UseLMSDocumentation,
							lmsUrl: values.LMSUrl,
							enableContextHelp: values.EnableContextHelp,
							contextHelpId: contextHelpId,
							productEdition: values.ProductEdition,
							configurationVersion: values.ConfigurationVersion
						};
					}
					callback.call(scope, helpConfig);
				}, this);
		},

		/**
		 * Асинхронно получает конфигурацию со справочника для построения ссылки на документацию.
		 * @private
		 * @param {String} contextHelpCode Код контекстной справки.
		 * @param {Function} callback Функция обратного вызова.
		 * @param {Object} scope Контекст для выполнения.
		 */
		getHelpConfigFromDb: function(contextHelpCode, callback, scope) {
			var esq = Ext.create("Terrasoft.EntitySchemaQuery", {
				rootSchemaName: "ContextHelp",
				serverESQCacheParameters: {
					cacheLevel: Terrasoft.ESQServerCacheLevels.WORKSPACE,
					cacheGroup: "AcademyUtilities",
					cacheItemName: contextHelpCode
				}
			});
			esq.addColumn("Code");
			esq.addColumn("ContextHelpId");
			esq.addColumn("LMSUrl");
			esq.addColumn("ProductEdition");
			esq.addColumn("ConfigurationVersion");
			esq.filters.add("ContextHelpCode", esq.createColumnFilterWithParameter(
				Terrasoft.ComparisonType.EQUAL, "Code", contextHelpCode));
			esq.getEntityCollection(function(result) {
				var collection = result.collection;
				var helpConfig = null;
				if (result.success && collection.getCount()) {
					var entity = collection.getByIndex(collection.getCount() - 1);
					var lmsUrl = entity.get("LMSUrl");
					var contextHelpId = entity.get("ContextHelpId");
					helpConfig = {
						lmsUrl: lmsUrl,
						enableContextHelp: !Ext.isEmpty(contextHelpId),
						contextHelpId: contextHelpId,
						productEdition: entity.get("ProductEdition"),
						configurationVersion: entity.get("ConfigurationVersion")
					};
				}
				callback.call(scope, helpConfig);
			}, this);
		},

		/**
		 * Возвращает ссылку на документацию на основе объекта конфигурации.
		 * @private
		 * @param {Object} config Объект конфигурации.
		 * @param {Boolean} config.useLmsDocumentation (optional) Доступность контекстной справки.
		 * @param {Function} callback Функция обратного вызова.
		 * @param {Object} scope Контекст для выполнения.
		 */
		buildUrl: function(config, callback, scope) {
			var url = "#";
			if (config) {
				url = (config.useLmsDocumentation) ? this.getLmsDocumentationUrl(config) :
					this.getLocalDocumentationUrl(config);
			}
			callback.call(scope, url);
		},

		/**
		 * Возвращает ссылку на Академию на основе объекта конфигурации.
		 * @private
		 * @param {Object} config Объект конфигурации.
		 * @param {Number} config.lmsUrl Адрес LMS.
		 * @param {String} config.productEdition (optional) Редакция продукта.
		 * @param {String} config.configurationVersion (optional) Версия конфигурации.
		 * @param {Number} config.enableContextHelp (optional) Доступность контекстной справки.
		 * @param {Number} config.contextHelpId (optional) Идентификатор контекстной справки.
		 * @return {String} Ссылка на Академию.
		 */
		getLmsDocumentationUrl: function(config) {
			var parameters = [];
			var productEdition = config.productEdition;
			if (productEdition) {
				parameters.push("product=" + encodeURIComponent(productEdition));
			}
			var configurationVersion = config.configurationVersion;
			if (configurationVersion) {
				parameters.push("ver=" + encodeURIComponent(configurationVersion));
			}
			var enableContextHelp = config.enableContextHelp;
			var contextHelpId = config.contextHelpId;
			if (enableContextHelp && contextHelpId) {
				parameters.push("id=" + encodeURIComponent(contextHelpId));
			}
			return Ext.String.format("{0}?{1}", config.lmsUrl, parameters.join("&"));
		},

		/**
		 * Возвращает ссылку на локальную справку на основе объекта конфигурации.
		 * @private
		 * @param {Object} config Объект конфигурации.
		 * @param {Number} config.contextHelpId (optional) Идентификатор контекстной справки.
		 * @return {String} Ссылка на локальную справку.
		 */
		getLocalDocumentationUrl: function(config) {
			var url = Terrasoft.workspaceBaseUrl + "/WebHelpNui/";
			url += config.productEdition + "/";
			var userCulture = Terrasoft.SysValue.CURRENT_USER_CULTURE.displayValue;
			var userCultureParts = userCulture.split("-", 1);
			url += userCultureParts[0];
			url += "/BPMonline_Help.htm";
			var contextHelpId = config.contextHelpId;
			if (contextHelpId) {
				url += "#<id=" + contextHelpId;
			}
			return url;
		}
	});
	return Terrasoft.AcademyUtilities;
});


				// Autogenerated Code for schema AcademyUtilities (End)
// Autogenerated Code for schema ESNConstants (Start)
define('ESNConstantsResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("ESNConstants", [], function() {
	/**
	 * @class Terrasoft.configuration.ESNConstants
	 * Класс ESNConstants содержит конфигурационные константы для ESN.
	 */
	Ext.define("Terrasoft.configuration.ESNConstants", {
		extend: "Terrasoft.BaseObject",
		alternateClassName: "Terrasoft.ESNConstants",

		ESN: {
			SocialChannelSchemaUId: "dd74c060-eb4b-4f15-b381-db91ca5ac483",
			SchemasWithPrimaryImageColumnCollection: {
				"dd74c060-eb4b-4f15-b381-db91ca5ac483": "SocialChannel",
				"16be3651-8fe2-4159-8dd0-a803d4683dd3": "Contact"
			}
		},

		LikedUsersModalBoxConfig: {
			minWidth: 10,
			minHeight: 10,
			maxWidth: 40,
			maxHeight: 50
		},

		WebSocketMessageHeader: {
			ESNNotification: "ESNNotification"
		},

		SysSchema: {
			CaseUId: "117d32f9-8275-4534-8411-1c66115ce9cd"
		}
	});
	return Ext.create("Terrasoft.ESNConstants");
});

				// Autogenerated Code for schema ESNConstants (End)
// Autogenerated Code for schema CtiPanelModule (Start)
define('CtiPanelModuleResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("CtiPanelModule", ["BaseSchemaModuleV2"], function() {
	/**
	 * @class Terrasoft.configuration.CtiPanelModule
	 * Класс страницы CTI панели, для работы со звонками.
	 */
	Ext.define("Terrasoft.configuration.CtiPanelModule", {
		alternateClassName: "Terrasoft.CtiPanelModule",
		extend: "Terrasoft.BaseSchemaModule",

		/**
		 * Инициализирует название схемы.
		 * @protected
		 * @overridden
		 */
		initSchemaName: function() {
			this.schemaName = "CtiPanel";
		},

		/**
		 * Создает модель представления. Расширяет модель {@link Terrasoft.CtiModel} моделью текущего класса.
		 * @protected
		 * @overridden
		 */
		createViewModel: function() {
			var viewModel = this.callParent(arguments);
			var model = Ext.merge(Terrasoft.CtiModel.model, viewModel.model);
			Ext.merge(viewModel, Terrasoft.CtiModel, {
				init: viewModel.init
			});
			viewModel.model = model;
			Terrasoft.CtiModel = Terrasoft.integration.telephony.CtiModel = viewModel;
			return viewModel;
		},

		/**
		 * Заменяет последний элемент в цепочке состояний, если его идентификатор модуля отличается от текущего.
		 * @protected
		 * @overridden
		 */
		initHistoryState: Ext.emptyFn

	});
	return Terrasoft.CtiPanelModule;
});

				// Autogenerated Code for schema CtiPanelModule (End)
// Autogenerated Code for schema SideBarModule (Start)
define('SideBarModuleResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("SideBarModule", ['ext-base', 'terrasoft', 'sandbox', "SideBarModuleResources"],
	function(Ext, Terrasoft, sandbox, resources) {
		var nodes = [];
		var leftPanelHeader;
		var leftPanelContent;

		var render = function(renderTo) {
			renderView(renderTo);
			sandbox.subscribe('SideBarLoadModule', onSideBarLoadModule);
			sandbox.subscribe('SideBarBack', onSideBarBack);
			sandbox.subscribe('GetSideBarCurrentConfig', getSideBarCurrentConfig);
			sandbox.subscribe('PushSideBarModuleDefInfo', function(menuItems) {
				nodes.push(menuItems);
				updateHistoryNodes();
				renderNode(menuItems);
			});

			var historyState = sandbox.publish('GetHistoryState');
			if (historyState && historyState.state) {
				var historyNodes = historyState.state.SideBarNodes;
				if (Ext.isArray(historyNodes) && historyNodes.length > 0) {
					nodes = [].concat(historyNodes);
				}
			}
			if (nodes.length > 0) {
				renderNode(nodes[nodes.length - 1]);
			} else {
				sandbox.publish('SideBarModuleDefInfo');
			}
		};

		function updateHistoryNodes() {
			var historyState = sandbox.publish('GetHistoryState');
			var state = historyState.state || {};
			state.SideBarNodes = nodes;
			if (historyState.hash) {
				sandbox.publish('ReplaceHistoryState', {
					stateObj: state,
					hash: historyState.hash.historyState,
					silent: true
				});
			}
		}

		function getSideBarCurrentConfig() {
			return getCurrentNode();
		}

		function onSideBarBack() {
			if (nodes.length > 1) {
				clearRenderedItems();
				nodes.pop();
				renderNode(getCurrentNode());
			}
		}

		function onSideBarLoadModule(args) {
			var newNode = args.items;
	   		if (newNode) {
				clearRenderedItems();
			   	/*if (args.keepAlive === false) {
					nodes.pop();
				}*/
				nodes.pop();
				nodes.push(newNode);
				renderNode(newNode);
			} else {
				var currentNode = getCurrentNode();
				if (!Ext.isEmpty(args.position)) {
					currentNode.splice(args.position, 0, args);
					renderItem(args, args.position);
				} else {
					renderItem(args);
				}
			}
			updateHistoryNodes();
		}

		function getCurrentNode() {
			return nodes[nodes.length - 1];
		}

		function clearRenderedItems() {
			var currentNode = getCurrentNode();
			Terrasoft.each(currentNode, function(item) {
				sandbox.unloadModule(item.id);
				var renderToContainer = Ext.get(item.id);
				renderToContainer.destroy();
			}, this);
			leftPanelHeader.reRender();
			leftPanelContent.reRender();
		}

		function renderNode(node) {
			Terrasoft.each(node, function(item) {
				renderItem(item);
			}, this);
		}

		function renderView(renderTo) {
			leftPanelHeader = Ext.create("Terrasoft.Container", {
				renderTo: renderTo,
				id: 'leftPanelHeader',
				classes: {
					wrapClassName: ['header']
				},
				selectors: {
					wrapEl: '#leftPanelHeader'
				}
			});
			leftPanelContent = Ext.create("Terrasoft.Container", {
				renderTo: renderTo,
				id: 'leftPanelContent',
				classes: {
					wrapClassName: ['scroll', 'content']
				},
				selectors: {
					el: '#leftPanelContent',
					wrapEl: '#leftPanelContent'
				}
			});
		}

		function renderItem(item, position) {
			var id = item.id = item.id || 'item' + Terrasoft.generateGUID();
			var renderTo = (item.showInHeader) ? leftPanelHeader.getWrapEl() : leftPanelContent.getWrapEl();
			var itemContainer = Ext.create("Terrasoft.Container", {
				renderTo: renderTo,
				id: id,
				selectors: {
					el: '#' + id,
					wrapEl: '#' + id
				}
			});
			if (!Ext.isEmpty(position)) {
				itemContainer.reRender(position);
			}
			sandbox.loadModule(item.name, {
				renderTo: id,
				id: id
			});
		}

		function init() {
			sandbox.subscribe('GetSectionMenuInfo', function(menuId) {
				Terrasoft.each(getCurrentNode(), function(item) {
					if (item.id === menuId) {
						sandbox.publish('PostSectionMenuConfig', Terrasoft.deepClone(item.config || {}), [menuId]);
					}
				}, this);
			});
		}

		return {
			init: init,
			render: render
		};
	});

				// Autogenerated Code for schema SideBarModule (End)
// Autogenerated Code for schema WelcomeScreen (Start)
define('WelcomeScreenResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={
	AcademyButtonCaption: 'Перейти в Академию',
	WelcomeTextStartLabel: 'Добро пожаловать в ',
	AcademyHintLabel: 'Узнайте больше о возможностях системы в Terrasoft Academy'
};
var localizableImages={
	'CloseButtonImage': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'WelcomeScreen', resourceItemName: 'CloseButtonImage' }},
	'PlayButtonImage': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'WelcomeScreen', resourceItemName: 'PlayButtonImage' }}
};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define('WelcomeScreenStructure', ['WelcomeScreenResources'], function(resources) {return {schemaUId:'fd1aa610-e338-461e-b0d0-41a66bb2fb4e',schemaCaption: 'WelcomeScreen', parentSchemaName: '', schemaName:'WelcomeScreen',parentSchemaUId:'',extendParent:false,type:Terrasoft.SchemaType.EDIT_VIEW_MODEL_SCHEMA,entitySchema:'',name:'',extend:'Terrasoft.model.BaseViewModel',schema:{leftPanel:[],rightPanel:[],actions:[],analytics:[]},methods:{},controlsConfig:{},customBindings:{},bindings:{},schemaDifferences:function(){

}};});
define("WelcomeScreen", ["ModalBox", "AcademyUtilities"], function(ModalBox) {
	return {
		attributes: {
			"WelcomeScreenVisible": {
				dataValueType: Terrasoft.DataValueType.BOOLEAN,
				type: Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
				value: true
			},
			"VideoScreenVisible": {
				dataValueType: Terrasoft.DataValueType.BOOLEAN,
				type: Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
				value: true
			},
			"UseLMSDocumentation": {
				dataValueType: Terrasoft.DataValueType.BOOLEAN,
				type: Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
				value: false
			},
			"ProductNameEdition": {
				dataValueType: Terrasoft.DataValueType.TEXT,
				type: Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
				value: false
			},
			"WelcomeScreenVideoUrl": {
				dataValueType: Terrasoft.DataValueType.TEXT,
				type: Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
				value: ""
			}
		},

		methods: {
			init: function(callback, scope) {
				this.callParent([function() {
					var sysSettingsNameArray = ["UseLMSDocumentation", "ProductName", "ProductEdition",
						"WelcomeScreenVideoUrl"];
					this.Terrasoft.SysSettings.querySysSettings(sysSettingsNameArray,
						function(values) {
							if (values) {
								this.set("UseLMSDocumentation", values.UseLMSDocumentation);
								this.set("WelcomeScreenVideoUrl", values.WelcomeScreenVideoUrl);
								var productName = values.ProductName;
								var productEdition = values.ProductEdition;
								var params = [];
								if (productName) {
									params.push(productName.replace(/&#39;/g, "'"));
								}
								if (productEdition) {
									params.push(productEdition);
								}
								var product = params.join(" ");
								this.set("Product", product);
							}
							callback.call(scope);
						}, this);
				}, this]);

			},

			/**
			 * Выполняет действия необходимые после отображения модуля.
			 */
			onRender: function() {
				this.set("WelcomeScreenVisible", true);
				this.set("VideoScreenVisible", false);
			},

			/**
			 * Открывает видео.
			 * @private
			 */
			onPlayButtonClick: function() {
				this.set("WelcomeScreenVisible", false);
				this.set("VideoScreenVisible", true);
				var html = this.getVideo();
				var videoContainer = this.Ext.get("VideoContainer");
				this.Ext.create("Terrasoft.HtmlControl", {
					id: "videoControl",
					renderTo: videoContainer,
					html: html,
					selectors: {
						wrapEl: ".video-wrapper"
					}
				});
			},

			/**
			 * Открывает Академию.
			 * @private
			 */
			onAcademyButtonClick: function() {
				var config = {
					callback: function(url) {
						window.open(url, "_blank");
					},
					contextHelpCode: "WelcomeScreen",
					scope: this
				};
				Terrasoft.AcademyUtilities.getUrl(config);
			},

			/**
			 * Закрывает приветственное окно.
			 * @private
			 */
			onCloseButtonClick: function() {
				ModalBox.close();
			},

			/**
			 * Возвращает значение параметра, использовать справку, или нет.
			 * @return {boolean}
			 */
			useLMSDocumentation: function() {
				return this.get("UseLMSDocumentation");
			},

			/**
			 * Возвращает строку с названием продукта.
			 * @return {String}
			 */
			getProduct: function() {
				return this.get("Product");
			},

			/**
			 * Возвращает строку с html для встраивания видео.
			 * @return {String}
			 */
			getVideo: function() {
				var html = "<iframe width=\"996\" height=\"698\" src=\"{0}\" frameborder=\"0\" allowfullscreen></iframe>";
				var welcomeScreenVideoUrl = this.get("WelcomeScreenVideoUrl");
				return this.Ext.String.format(html, welcomeScreenVideoUrl);
			},

			/**
			 * Возвращает видимость кнопки проигрывания видео.
			 * @return {boolean}
			 */
			getPlayButtonVisible: function() {
				var welcomeScreenVideoUrl = this.get("WelcomeScreenVideoUrl");
				return !this.Ext.isEmpty(welcomeScreenVideoUrl);
			}
		},

		diff: [
			//ScreenContainer
			{
				"operation": "insert",
				"name": "ScreenContainer",
				"propertyName": "items",
				"values": {
					"generateId": false,
					"itemType": Terrasoft.ViewItemType.CONTAINER,
					"classes": {
						wrapClassName: ["screen"]
					},
					"items": []
				}
			},
			//WelcomeScreen
			{
				"operation": "insert",
				"parentName": "ScreenContainer",
				"name": "WelcomeScreen",
				"propertyName": "items",
				"values": {
					"generateId": false,
					"itemType": Terrasoft.ViewItemType.CONTAINER,
					"classes": {
						wrapClassName: ["welcome-screen"]
					},
					"visible": {bindTo: "WelcomeScreenVisible"},
					"items": []
				}
			},
			//CloseButton
			{
				"operation": "insert",
				"parentName": "ScreenContainer",
				"name": "CloseButton",
				"propertyName": "items",
				"values": {
					"generateId": false,
					"itemType": Terrasoft.ViewItemType.BUTTON,
					"style": Terrasoft.controls.ButtonEnums.style.TRANSPARENT,
					"click": {bindTo: "onCloseButtonClick"},
					"markerValue": "CloseButton",
					"imageConfig": {"bindTo": "getCloseButtonImageConfig"},
					"classes": {
						wrapperClass: ["close-button-wrapper"]
					}
				}
			},
			//WelcomeText
			{
				"operation": "insert",
				"name": "WelcomeText",
				"parentName": "WelcomeScreen",
				"propertyName": "items",
				"values": {
					"generateId": false,
					"itemType": Terrasoft.ViewItemType.CONTAINER,
					"classes": {
						wrapClassName: ["welcome-text-wrapper"]
					},
					"items": []
				}
			},
			//WelcomeTextStart
			{
				"operation": "insert",
				"name": "WelcomeTextStartLabel",
				"parentName": "WelcomeText",
				"propertyName": "items",
				"values": {
					"generateId": false,
					"itemType": Terrasoft.ViewItemType.LABEL,
					"caption": {"bindTo": "Resources.Strings.WelcomeTextStartLabel"}
				}
			},
			//WelcomeTextProductVersion
			{
				"operation": "insert",
				"name": "WelcomeTextProduct",
				"parentName": "WelcomeText",
				"propertyName": "items",
				"values": {
					"generateId": false,
					"itemType": Terrasoft.ViewItemType.LABEL,
					"caption": {"bindTo": "getProduct"}
				}
			},
			//PlayButtonContainer
			{
				"operation": "insert",
				"parentName": "WelcomeScreen",
				"name": "PlayButtonContainer",
				"propertyName": "items",
				"values": {
					"generateId": false,
					"itemType": Terrasoft.ViewItemType.CONTAINER,
					"items": []
				}
			},
			//PlayButton
			{
				"operation": "insert",
				"parentName": "PlayButtonContainer",
				"name": "PlayButton",
				"propertyName": "items",
				"values": {
					"generateId": false,
					"itemType": Terrasoft.ViewItemType.BUTTON,
					"style": Terrasoft.controls.ButtonEnums.style.TRANSPARENT,
					"imageConfig": {"bindTo": "Resources.Images.PlayButtonImage"},
					"click": {bindTo: "onPlayButtonClick"},
					"markerValue": "PlayButton",
					"classes": {
						wrapperClass: ["play-button-wrapper"]
					},
					"visible": {bindTo: "getPlayButtonVisible"}
				}
			},
			//Academy
			{
				"operation": "insert",
				"name": "Academy",
				"parentName": "WelcomeScreen",
				"propertyName": "items",
				"values": {
					"generateId": false,
					"itemType": Terrasoft.ViewItemType.CONTAINER,
					"classes": {
						wrapClassName: ["academy-wrapper"]
					},
					"visible": {bindTo: "UseLMSDocumentation"},
					"items": []
				}
			},
			//AcademyHint
			{
				"operation": "insert",
				"name": "AcademyHint",
				"parentName": "Academy",
				"propertyName": "items",
				"values": {
					"itemType": Terrasoft.ViewItemType.LABEL,
					"caption": {"bindTo": "Resources.Strings.AcademyHintLabel"}
				}
			},
			//AcademyButtonContainer
			{
				"operation": "insert",
				"parentName": "Academy",
				"name": "AcademyButtonContainer",
				"propertyName": "items",
				"values": {
					"generateId": false,
					"itemType": Terrasoft.ViewItemType.CONTAINER,
					"classes": {
						wrapClassName: ["academy-button-wrapper"]
					},
					"items": []
				}
			},
			//AcademyButton
			{
				"operation": "insert",
				"parentName": "AcademyButtonContainer",
				"name": "AcademyButton",
				"propertyName": "items",
				"values": {
					"generateId": false,
					"itemType": Terrasoft.ViewItemType.BUTTON,
					"style": Terrasoft.controls.ButtonEnums.style.GREEN,
					"caption": {bindTo: "Resources.Strings.AcademyButtonCaption"},
					"click": {bindTo: "onAcademyButtonClick"},
					"markerValue": "AcademyButton",
					"classes": {
						wrapperClass: ["academy-button-wrapper"]
					}
				}
			},
			//VideoScreen
			{
				"operation": "insert",
				"parentName": "ScreenContainer",
				"name": "VideoScreen",
				"propertyName": "items",
				"values": {
					"generateId": false,
					"itemType": Terrasoft.ViewItemType.CONTAINER,
					"classes": {
						wrapClassName: ["video-screen"]
					},
					"visible": {bindTo: "VideoScreenVisible"},
					"items": []
				}
			},
			//VideoContainer
			{
				"operation": "insert",
				"name": "VideoContainer",
				"parentName": "VideoScreen",
				"propertyName": "items",
				"values": {
					"id": "VideoContainer",
					"itemType": Terrasoft.ViewItemType.CONTAINER,
					"classes": {
						wrapClassName: ["video-wrapper"]
					},
					items: []
				}
			}
		]
	};
});


				// Autogenerated Code for schema WelcomeScreen (End)
// Autogenerated Code for schema WelcomeScreenModule (Start)
define('WelcomeScreenModuleResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("WelcomeScreenModule", ["BaseSchemaModuleV2"/*"css!WelcomeScreenModule"*/],
		function() {
	Ext.define("Terrasoft.configuration.WelcomeScreenModule", {

		extend: "Terrasoft.BaseSchemaModule",
		alternateClassName: "Terrasoft.WelcomeScreenModule",

		/**
		 * @inheritDoc Terrasoft.BaseSchemaModule#generateViewContainerId
		 * @overridden
		 */
		generateViewContainerId: false,

		/**
		 * @inheritDoc Terrasoft.BaseSchemaModule#initSchemaName
		 * @overridden
		 */
		initSchemaName: function() {
			this.schemaName = "WelcomeScreen";
		},

		/**
		 * @inheritDoc Terrasoft.BaseSchemaModule#initHistoryState
		 * @overridden
		 */
		initHistoryState: Terrasoft.emptyFn

	});
	return Terrasoft.WelcomeScreenModule;
});

				// Autogenerated Code for schema WelcomeScreenModule (End)
// Autogenerated Code for schema LeftPanelClientWorkplaceMenu (Start)
define('LeftPanelClientWorkplaceMenuResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("LeftPanelClientWorkplaceMenu", ["LeftPanelClientWorkplaceMenuResources", "MaskHelper", "ServiceHelper",
	"RightUtilities", "profile!clientWorkplaceMenuProfile", "css!LeftPanelTopMenuModule"],
	function(resources, MaskHelper, ServiceHelper, RightUtilities, clientWorkplaceMenuProfile) {
		function createConstructor(context) {
			var container;
			var viewModel;
			var Ext = context.Ext;
			var sandbox = context.sandbox;
			var Terrasoft = context.Terrasoft;
			var profile = clientWorkplaceMenuProfile;

			var getViewConfig = function() {
				var topMenuContainer = {
					className: "Terrasoft.Container",
					id: "top-menu-workplace-button-container",
					selectors: {
						wrapEl: "#" + "top-menu-workplace-button-container"
					},
					classes: {
						wrapClassName: ["top-menu-workplace-button-container-wrapEl"]
					},
					items: getTopMenuConfig("Default")
				};
				return topMenuContainer;
			};

			function getTopMenuConfig(caption) {
				var menuConfig = {
						id: "menu-workplace-button",
						selectors: {
							wrapEl: "#menu-workplace-button"
						},
						tag: "TopWorkplaceMenu",
						markerValue: "TopWorkplaceMenu",
						className: "Terrasoft.Button",
						style: {
							bindTo: "TopWorkplaceMenuButtonStyle"
						},
						caption: {
							bindTo: "TopWorkplaceMenuCaption"
						},
						menu: {
							items: {
								bindTo: "WorkplaceCollection"
							}
						},
						prepareMenu: {bindTo: "addHighlight"},
						hideMenu: {bindTo: "removeHighlight"}
					};
				return [menuConfig];
			}

			var getViewModel = function() {
				return Ext.create("Terrasoft.BaseViewModel", {
					values: {
						selectedWorkplaceId: null,
						TopWorkplaceMenuCaption: "",
						WorkplaceCollection: Ext.create("Terrasoft.BaseViewModelCollection"),
						TopWorkplaceMenuButtonStyle: Terrasoft.controls.ButtonEnums.style.TRANSPARENT
					},
					methods: {
						reloadMenu: function(workplaces, workplaceId) {
							var control = Ext.getCmp("menu-workplace-button");
							if (!control) {
								return;
							}
							var menuItems = [];
							Terrasoft.each(workplaces, function(item) {
								if (item.hide) {
									return;
								}
								var menuItemConfig = {
									caption: item.name,
									tag: item.workplaceId,
									markerValue: item.name,
									click: {
										bindTo: "menuItemClick"
									}
								};
								menuItems.push(menuItemConfig);
								if (workplaceId === item.workplaceId) {
									control.caption = item.name;
								}
							}, this);
							if (workplaceId === undefined) {
								control.caption = workplaces[0].name;
							}
							var menu = Ext.create("Terrasoft.Menu", {
								items: menuItems,
								markerValue: "TopWorkplaceMenu"
							});
							menu.bind(this);
							control.menu = menu;
							control.reRender();
						},
						loadMenu: function(workplaces, workplaceId) {
							var collection = this.get("WorkplaceCollection");
							if (!collection.isEmpty()) {
								collection.clear();
							}
							Terrasoft.each(workplaces, function(item) {
								if (item.hide) {
									return;
								}
								collection.addItem(Ext.create("Terrasoft.BaseViewModel", {
									values: {
										Id: Terrasoft.generateGUID(),
										Caption: item.name,
										MarkerValue: item.name,
										Tag: item.workplaceId,
										Click: {bindTo: "menuItemClick"}
									}
								}));
								if (workplaceId === item.workplaceId) {
									this.set("TopWorkplaceMenuCaption", item.name);
								}
							}, this);
						},
						loadMenuItems: function(workplaceId) {
							var workplaces =
								Terrasoft.deepClone(Terrasoft.configuration.WorkplacesStructure.Workplaces);
							if (workplaces.length > 0) {
								workplaces.sort(function(a, b) {
									if (a.name < b.name) {
										return -1;
									}
									if (a.name > b.name) {
										return 1;
									}
									return 0;
								});
								this.loadMenu(workplaces, workplaceId);
							}
						},
						menuItemClick: function(tag) {
							if (this.get("selectedWorkplaceId") === tag) {
								return;
							}
							this.loadMenuItems(tag);
							var dataSend = {
								workplaceId: tag
							};
							Terrasoft.utils.saveUserProfile("clientWorkplaceMenuProfile", dataSend);
							ServiceHelper.callService("WorkplaceService", "SetWorkplaceCache", Terrasoft.emptyFn, dataSend, this);
							this.load(tag);
							this.set("selectedWorkplaceId", tag);
						},
						load: function(tag) {
							var workplaceItem = this.getWorkplaceData(tag);
							if (workplaceItem) {
								sandbox.subscribe("GetWorkplaceInfo", function(args) {
									return workplaceItem;
								});
								sandbox.loadModule(workplaceItem.loaderName);
							}
						},
						getWorkplaceData: function(workplaceId) {
							var workplaces = Terrasoft.configuration.WorkplacesStructure.Workplaces;
							var workplaceItem = null;
							if (workplaces.length > 0) {
								Terrasoft.each(workplaces, function(item) {
									if (item.workplaceId === workplaceId) {
										workplaceItem = item;
									}
								}, this);
							}
							return workplaceItem;
						},
						addHighlight: function() {
							this.set("TopWorkplaceMenuButtonStyle", "highlighted");
						},
						removeHighlight: function() {
							this.set("TopWorkplaceMenuButtonStyle", Terrasoft.controls.ButtonEnums.style.TRANSPARENT);
						}
					}
				});
			};
			var loadMenu = function() {
				var workplaceId;
				var workplaces = Terrasoft.configuration.WorkplacesStructure.Workplaces;
				if (profile && profile.workplaceId) {
					var isInWorkplace = workplaces.some(function(item) {
						return item.workplaceId === profile.workplaceId;
					});
					if (isInWorkplace) {
						workplaceId = profile.workplaceId;
					} else if (workplaces.length) {
						profile.workplaceId = workplaces[0].workplaceId;
						workplaceId = profile.workplaceId;
					}
				} else {
					if (workplaces.length) {
						workplaceId = profile.workplaceId = workplaces[0].workplaceId;
					}
				}
				if (workplaceId != null) {
					viewModel.loadMenuItems(workplaceId);
					viewModel.load(workplaceId);
				}
			};
			var generate = function() {
				var view = Ext.create("Terrasoft.Container", getViewConfig());
				viewModel = getViewModel();
				view.bind(viewModel);
				view.render(container);
				sandbox.subscribe("RefreshWorkplace", function(args) {
					ServiceHelper.callService("WorkplaceService", "RefreshWorkplace", function(responce) {
						Terrasoft.configuration.WorkplacesStructure = JSON.parse(responce.RefreshWorkplaceResult);
						loadMenu();
					}, null, this);
				});
				loadMenu();
				sandbox.subscribe("ChangeCurrentWorkplace", function(args) {
					viewModel.menuItemClick(args);
				});
			};

			function render(renderTo) {
				container = renderTo;
				generate();
			}

			return Ext.define("LeftPanelClientWorkplaceMenu", {
				render: render
			});
		}

		return createConstructor;
	});

				// Autogenerated Code for schema LeftPanelClientWorkplaceMenu (End)
// Autogenerated Code for schema CommunicationPanel (Start)
define('CommunicationPanel613fd913-be03-46ce-909b-f44e4225469eResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={
	ESNFeedMenuHint: 'Лента',
	NotificationsMenuHint: 'Уведомления',
	VisaMenuHint: 'Визы',
	MenuItemIconNameTemplate: '{0}Menu{1}{2}Icon',
	CloseRightSidePanel: 'Свернуть панель',
	EmailMenuHint: 'Email'
};
var localizableImages={
	'ESNFeedMenuIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanel', resourceItemName: 'ESNFeedMenuIcon' }},
	'ESNFeedMenuPressedIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanel', resourceItemName: 'ESNFeedMenuPressedIcon' }},
	'ESNFeedMenuCounterIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanel', resourceItemName: 'ESNFeedMenuCounterIcon' }},
	'ESNFeedMenuPressedCounterIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanel', resourceItemName: 'ESNFeedMenuPressedCounterIcon' }},
	'NotificationsMenuIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanel', resourceItemName: 'NotificationsMenuIcon' }},
	'NotificationsMenuPressedIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanel', resourceItemName: 'NotificationsMenuPressedIcon' }},
	'NotificationsMenuCounterIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanel', resourceItemName: 'NotificationsMenuCounterIcon' }},
	'NotificationsMenuPressedCounterIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanel', resourceItemName: 'NotificationsMenuPressedCounterIcon' }},
	'VisaMenuIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanel', resourceItemName: 'VisaMenuIcon' }},
	'VisaMenuPressedIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanel', resourceItemName: 'VisaMenuPressedIcon' }},
	'VisaMenuCounterIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanel', resourceItemName: 'VisaMenuCounterIcon' }},
	'VisaMenuPressedCounterIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanel', resourceItemName: 'VisaMenuPressedCounterIcon' }},
	'ImageCloseRightSidePanelButton': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanel', resourceItemName: 'ImageCloseRightSidePanelButton' }},
	'EmailMenuIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanel', resourceItemName: 'EmailMenuIcon' }},
	'EmailMenuPressedIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanel', resourceItemName: 'EmailMenuPressedIcon' }},
	'EmailMenuCounterIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanel', resourceItemName: 'EmailMenuCounterIcon' }},
	'EmailMenuPressedCounterIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanel', resourceItemName: 'EmailMenuPressedCounterIcon' }}
};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define('CommunicationPanel90ef497e-6e18-440d-b80e-d28f2f133509Resources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={
	ESNNotificationMenuHint: 'Уведомления ленты'
};
var localizableImages={
	'ESNNotificationMenuIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanel', resourceItemName: 'ESNNotificationMenuIcon' }},
	'ESNNotificationMenuPressedIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanel', resourceItemName: 'ESNNotificationMenuPressedIcon' }},
	'ESNNotificationMenuCounterIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanel', resourceItemName: 'ESNNotificationMenuCounterIcon' }},
	'ESNNotificationMenuPressedCounterIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanel', resourceItemName: 'ESNNotificationMenuPressedCounterIcon' }}
};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define('CommunicationPanelResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={
	CtiPanelMenuHint: 'CTI панель'
};
var localizableImages={
	'CtiPanelMenuIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanel', resourceItemName: 'CtiPanelMenuIcon' }},
	'CtiPanelMenuPressedIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanel', resourceItemName: 'CtiPanelMenuPressedIcon' }},
	'CtiPanelMenuCounterIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanel', resourceItemName: 'CtiPanelMenuCounterIcon' }},
	'CtiPanelMenuPressedCounterIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanel', resourceItemName: 'CtiPanelMenuPressedCounterIcon' }},
	'CtiPanelMenuCallDurationIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanel', resourceItemName: 'CtiPanelMenuCallDurationIcon' }},
	'CtiPanelMenuCallDurationPressedIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanel', resourceItemName: 'CtiPanelMenuCallDurationPressedIcon' }}
};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define('CommunicationPanel613fd913-be03-46ce-909b-f44e4225469eStructure', ['CommunicationPanel613fd913-be03-46ce-909b-f44e4225469eResources'], function(resources) {return {schemaUId:'3431e29c-09d8-4c7c-a1d5-4f76de040039',schemaCaption: 'Схема коммуникационной панели', parentSchemaName: '', schemaName:'CommunicationPanel613fd913-be03-46ce-909b-f44e4225469e',parentSchemaUId:'',extendParent:false,type:Terrasoft.SchemaType.EDIT_VIEW_MODEL_SCHEMA,entitySchema:'',name:'',extend:'Terrasoft.model.BaseViewModel',schema:{leftPanel:[],rightPanel:[],actions:[],analytics:[]},methods:{},controlsConfig:{},customBindings:{},bindings:{},schemaDifferences:function(){

}};});
define('CommunicationPanel90ef497e-6e18-440d-b80e-d28f2f133509Structure', ['CommunicationPanel90ef497e-6e18-440d-b80e-d28f2f133509Resources'], function(resources) {return {schemaUId:'4e9b84e4-c21d-4531-bef3-8c936a11763c',schemaCaption: 'Схема коммуникационной панели', parentSchemaName: 'CommunicationPanel613fd913-be03-46ce-909b-f44e4225469e', schemaName:'CommunicationPanel90ef497e-6e18-440d-b80e-d28f2f133509',parentSchemaUId:'3431e29c-09d8-4c7c-a1d5-4f76de040039',extendParent:true,type:Terrasoft.SchemaType.EDIT_VIEW_MODEL_SCHEMA,entitySchema:'',name:'',extend:'CommunicationPanel613fd913-be03-46ce-909b-f44e4225469e',schema:{leftPanel:[],rightPanel:[],actions:[],analytics:[]},methods:{},controlsConfig:{},customBindings:{},bindings:{},schemaDifferences:function(){

}};});
define('CommunicationPanelStructure', ['CommunicationPanelResources'], function(resources) {return {schemaUId:'73d02d4f-825c-44a9-9265-ceb23711e411',schemaCaption: 'Схема коммуникационной панели', parentSchemaName: 'CommunicationPanel90ef497e-6e18-440d-b80e-d28f2f133509', schemaName:'CommunicationPanel',parentSchemaUId:'4e9b84e4-c21d-4531-bef3-8c936a11763c',extendParent:true,type:Terrasoft.SchemaType.EDIT_VIEW_MODEL_SCHEMA,entitySchema:'',name:'',extend:'CommunicationPanel90ef497e-6e18-440d-b80e-d28f2f133509',schema:{leftPanel:[],rightPanel:[],actions:[],analytics:[]},methods:{},controlsConfig:{},customBindings:{},bindings:{},schemaDifferences:function(){

}};});
define("CommunicationPanel613fd913-be03-46ce-909b-f44e4225469e", ["terrasoft", "RemindingsUtilities", "GoogleTagManagerUtilities",
		"CommunicationPanelHelper"],
	function(Terrasoft, RemindingsUtilities, GoogleTagManagerUtilities) {
		return {
			messages: {
				"ShowHideRightSidePanel": {
					"mode": Terrasoft.MessageMode.PTP,
					"direction": Terrasoft.MessageDirectionType.PUBLISH
				},
				"CommunicationPanelItemSelected": {
					"mode": Terrasoft.MessageMode.PTP,
					"direction": Terrasoft.MessageDirectionType.PUBLISH
				}
			},
			mixins: {},
			attributes: {

				/**
				 * Текущий выбранный элемент меню.
				 * @type {String}
				 */
				"SelectedMenuItem": {
					"dataValueType": Terrasoft.DataValueType.TEXT,
					"type": Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
					"value": ""
				},

				/**
				 * Конфигурация педыдущего выбранного элемента меню панели.
				 * @type {String}
				 */
				"PreviousItemConfig": {
					"dataValueType": Terrasoft.DataValueType.CUSTOM_OBJECT,
					"type": Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
					"value": null
				},

				/**
				 * Признак, определяющий активен ли пункт меню «Лента ESN».
				 * @type {Boolean}
				 */
				"ESNFeedActive": {
					"dataValueType": Terrasoft.DataValueType.BOOLEAN,
					"type": Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
					"value": false
				},

				/**
				 * Счетчик непрочитанных уведомлений пункта меню «Лента ESN».
				 * @type {String}
				 */
				"ESNFeedCounter": {
					"dataValueType": Terrasoft.DataValueType.TEXT,
					"type": Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
					"value": ""
				},

				/**
				 * Признак, определяющий активен ли пункт меню «Уведомления».
				 * @type {Boolean}
				 */
				"NotificationsActive": {
					"dataValueType": Terrasoft.DataValueType.BOOLEAN,
					"type": Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
					"value": false
				},

				/**
				 * Счетчик непрочитанных уведомлений пункта меню «Уведомления».
				 * @type {String}
				 */
				"NotificationsCounter": {
					"dataValueType": Terrasoft.DataValueType.TEXT,
					"type": Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
					"value": ""
				},

				/**
				 * Признак, определяющий активен ли пункт меню «Визы».
				 * @type {Boolean}
				 */
				"VisaActive": {
					"dataValueType": Terrasoft.DataValueType.BOOLEAN,
					"type": Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
					"value": false
				},

				/**
				 * Счетчик виз.
				 * @type {String}
				 */
				"VisaCounter": {
					"dataValueType": Terrasoft.DataValueType.TEXT,
					"type": Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
					"value": ""
				},

				/**
				 * Количество необработанных почтовых сообщений.
				 * @type {String}
				 */
				"EmailCounter": {
					"dataValueType": Terrasoft.DataValueType.TEXT,
					"type": Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
					"value": ""
				},

				/**
				 * Максимальная длина текста счетчика уведомлений.
				 * @type {Number}
				 */
				"MaxCounterLength": {
					"dataValueType": Terrasoft.DataValueType.INTEGER,
					"type": Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
					"value": 2
				},

				/**
				 * Признак отображать ли пункт меню «Визы».
				 * @type {Boolean}
				 */
				"VisaVisible": {
					"dataValueType": Terrasoft.DataValueType.BOOLEAN,
					"type": Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
					"value": false
				}
			},
			methods: {

				/**
				 * Инициализирует начальные значения модели.
				 * @protected
				 * @overridden
				 */
				init: function(callback, scope) {
					this.callParent([function() {
						Terrasoft.ServerChannel.on(Terrasoft.EventName.ON_MESSAGE, this.onUserCountersChanged, this);
						this.initUserCounters(true);
						this.initVisaVisible();
						this.on("change:SelectedMenuItem", this.onSelectedMenuItemChanged, this);
						this.initSelectedMenuItem(function(selectedMenuItemTag) {
							this.set("SelectedMenuItem", selectedMenuItemTag);
							if (callback) {
								callback.call(scope || this);
							}
						}.bind(this));
					}, this]);
				},

				/**
				 * Инициализация атрибута доступности пункта меню «Визы».
				 * @protected
				 * @virtual
				 */
				initVisaVisible: function() {
					var select = Ext.create("Terrasoft.EntitySchemaQuery", {
						rootSchemaName: "NotificationProvider"
					});
					var visaType = "0";
					select.addAggregationSchemaColumn("Id", Terrasoft.AggregationType.COUNT, "VisaProviderCount");
					select.filters.addItem(select.createColumnFilterWithParameter(Terrasoft.ComparisonType.EQUAL,
						"Type", visaType));
					select.getEntityCollection(function(response) {
						if (response.success) {
							var result = response.collection.getByIndex(0);
							var visaProviderCount = result.get("VisaProviderCount");
							var visaVisible = visaProviderCount > 0;
							this.set("VisaVisible", visaVisible);
						}
					}, this);
				},

				/**
				 * Инициализирует начальный выделенный пункт меню.
				 * @protected
				 * @virtual
				 * @param {function} callback Функция обратного вызова. Параметром в функцию передается тэг выбранного
				 * пункта меню.
				 */
				initSelectedMenuItem: function(callback) {
					var profile = this.get("Profile");
					var selectedMenuItemTag = !Ext.isEmpty((profile || {}).selectedItemTag)
						? profile.selectedItemTag
						: "";
					callback(selectedMenuItemTag);
				},

				/**
				 * Возвращает ключ профиля.
				 * @protected
				 * @overridden
				 * @returns {string} Ключ профиля для коммуникационной панели.
				 */
				getProfileKey: function() {
					return "CommunicationPanelProfileData";
				},

				/**
				 * Выполняет первоначальный подсчет количества уведомлений/виз.
				 * Выполняет вызов сервиса, который в свою очередь ставит задачу,
				 * которая периодически выполняет подсчет количества уведомлений и возврат их на клиент.
				 * @private
				 * @param {Boolean} callService Указывает нужно ли вызывать метод сервиса.
				 */
				initUserCounters: function(callService) {
					RemindingsUtilities.getRemindingsCounters(this, this.updateUserCounters);
					if (callService) {
						var config = {
							serviceName: "RemindingService",
							methodName: "UpdateRemindingsCountersStart"
						};
						this.callService(config, Terrasoft.emptyFn, this);
					}
				},

				/**
				 * Выполняет обновление количества уведомлений/виз.
				 * @private
				 * @param {Number} countersData.notificationsCount Количество уведомлений.
				 * @param {Number} countersData.visaCount Количество виз.
				 */
				updateUserCounters: function(countersData) {
					var notificationsCounterValue =
						countersData.remindingsCount > 0 ? String(countersData.remindingsCount) : "";
					var visasCounterValue = countersData.visaCount > 0 ? String(countersData.visaCount) : "";
					this.set("NotificationsCounter", notificationsCounterValue);
					this.set("VisaCounter", visasCounterValue);
				},

				/**
				 * Возвращает конфигурацию выбранного элемента меню панели.
				 * @virtual
				 * @param {String} moduleName Название модуля.
				 * @returns {Object} Конфигурация выбранного элемента меню панели.
				 */
				getPanelItemConfig: function(moduleName) {
					return {
						moduleName: moduleName,
						keepAlive: false
					};
				},

				/**
				 * Загружает модуль выбранного элемента меню панели.
				 * @private
				 * @param {String} itemTag Название модуля.
				 */
				loadModule: function(itemTag) {
					var moduleName = itemTag + "Module";
					var itemConfig = this.getPanelItemConfig(moduleName);
					if (Ext.isEmpty(itemConfig)) {
						return;
					}
					var previousItemConfig = this.get("PreviousItemConfig");
					this.set("PreviousItemConfig", itemConfig);
					itemConfig.previousItemConfig = previousItemConfig;
					this.sandbox.publish("CommunicationPanelItemSelected", itemConfig);
				},

				/**
				 * Срабатывает при клике на кнопку меню панели. 4-ым параметром передается название (tag) кнопки.
				 * @private
				 */
				onMenuItemClick: function() {
					var selectedItemTag = arguments[3];
					var oldItemTag = this.get("SelectedMenuItem");
					if (selectedItemTag === oldItemTag) {
						selectedItemTag = "";
					}
					this.set("SelectedMenuItem", selectedItemTag);

					GoogleTagManagerUtilities.actionModule({
						virtualUrl: this.Terrasoft.workspaceBaseUrl + "/" + this.sandbox.id,
						moduleName: selectedItemTag,
						typeModule: selectedItemTag
					});
				},

				/**
				 * Скрывает правую боковую панель.
				 * @private
				 */
				closeRightPanel: function() {
					this.set("SelectedMenuItem", "");
				},

				/**
				 * Устанавливает видимость кнопки "Cвернуть панель".
				 * @private
				 */
				isRightPanelCloseButtonVisible: function() {
					return !Ext.isEmpty(this.get("SelectedMenuItem"));
				},

				/**
				 * Срабатывает при изменении активного элемента меню панели.
				 * @private
				 * @param {Backbone.Model} model Модель.
				 * @param {String} newItemTag Идентификатор выбранного элемента меню.
				 */
				onSelectedMenuItemChanged: function(model, newItemTag) {
					var oldItemTag = model.previous("SelectedMenuItem");
					var isOldItemNotEmpty = !Ext.isEmpty(oldItemTag);
					var isNewItemNotEmpty = !Ext.isEmpty(newItemTag);
					this.saveProfileData(function() {
						this.sandbox.publish("ShowHideRightSidePanel", {
							forceShow: isNewItemNotEmpty
						});
						if (isNewItemNotEmpty) {
							this.loadModule(newItemTag);
						}
					}.bind(this));
					if (isOldItemNotEmpty) {
						this.set(oldItemTag + "Active", false);
					}
					if (isNewItemNotEmpty) {
						this.set(newItemTag + "Active", true);
					}
				},

				/**
				 * Сохраняет настройки коммуникационной панели в профиль.
				 * @private
				 * @param callback (optional) Функция обратного вызова.
				 */
				saveProfileData: function(callback) {
					var selectedMenuItemTag = this.get("SelectedMenuItem");
					var profileData = Ext.Object.merge(this.ProfileData || {},
						{selectedItemTag: selectedMenuItemTag});
					Terrasoft.utils.saveUserProfile(this.getProfileKey(), profileData, false, function() {
						this.set("Profile", profileData);
						if (callback) {
							callback();
						}
					}.bind(this));
				},

				/**
				 * Запускает процедуру обновления уведомлений на основании значений счетчиков,
				 * которые получены в результате выполнения задачи на сервере.
				 * @private
				 * @param {Object} scope Контекст.
				 * @param {Object} userCounters Объект, который в себе содержит значения счетчиков
				 * количества уведомлений.
				 */
				onUserCountersChanged: function(scope, userCounters) {
					if (!userCounters) {
						return;
					}
					switch (userCounters.Header.Sender) {
						case "GetRemindingCounters":
							var counters = Ext.decode(userCounters.Body);
							var countersConfig = this.getCountersConfig(counters);
							this.updateUserCounters(countersConfig);
							break;
						case "UpdateReminding":
							this.initUserCounters(false);
							break;
						default:
							break;
					}
				},

				/**
				 * Формирует конфигурационнй объект для обновления значений счетчиков.
				 * @param {Object} counters Объект, который в себе содержит значения счетчиков
				 * количества уведомлений.
				 * @return {Object} Конфигурационнй объект для обновления значений счетчиков.
				 */
				getCountersConfig: function(counters) {
					return {
						remindingsCount: counters.RemindingsCount,
						visaCount: counters.VisaCount
					};
				},

				/**
				 * Возвращает конфигурацию изображения элемента меню по его состоянию.
				 * @private
				 * @param {String} itemTag Идентификатор элемента меню.
				 * @returns {Object} Конфигурация изображения.
				 */
				getItemImageConfig: function(itemTag) {
					var isItemPressed = (this.get("SelectedMenuItem") === itemTag);
					var isItemCounter = this.get(itemTag + "Counter");
					var pressedSuffix = isItemPressed ? "Pressed" : Ext.emptyString;
					var counterSuffix = isItemCounter ? "Counter" : Ext.emptyString;
					var resourceName = this.Ext.String.format(this.get("Resources.Strings.MenuItemIconNameTemplate"),
						itemTag, pressedSuffix, counterSuffix);
					return this.get("Resources.Images." + resourceName);
				},

				/**
				 * Возвращает всплывающую подсказку для пунктов меню.
				 * @private
				 * @param {String} tag Параметр идентификации пункта меню.
				 * @returns {String} Текст всплывающей подсказки.
				 */
				getHint: function(tag) {
					return this.get("Resources.Strings." + tag + "MenuHint");
				},

				/**
				 * Возвращает конфигурацию изображения для кнопки "Свернуть панель".
				 * @private
				 * @returns {Object} Конфигурация изображения.
				 */
				getCloseRightSidePanelButtonImageConfig: function() {
					return this.get("Resources.Images.ImageCloseRightSidePanelButton");
				},

				/**
				 * Возвращает текст всплывающей подсказки для кнопки "Свернуть панель".
				 * @private
				 * @returns {String} Текст всплывающей подсказки.
				 */
				getCloseRightSidePanelButtonHint: function() {
					return this.get("Resources.Strings.CloseRightSidePanel");
				}
			},
			diff: [
				{
					"operation": "insert",
					"name": "communicationPanelAll",
					"propertyName": "items",
					"values": {
						"id": "communicationPanelAll",
						"selectors": {"wrapEl": "#communicationPanelAll"},
						"itemType": Terrasoft.ViewItemType.CONTAINER,
						"wrapClass": ["all"],
						"items": []
					}
				},
				{
					"operation": "insert",
					"name": "rightPanelCloseButton",
					"parentName": "communicationPanelAll",
					"propertyName": "items",
					"values": {
						"id": "rightPanelCloseButton",
						"itemType": Terrasoft.ViewItemType.BUTTON,
						"click": {"bindTo": "closeRightPanel"},
						"visible": {"bindTo": "isRightPanelCloseButtonVisible"},
						"imageConfig": {"bindTo": "getCloseRightSidePanelButtonImageConfig"},
						"hint": {"bindTo": "getCloseRightSidePanelButtonHint"},
						"markerValue": "rightPanelCloseButton",
						"selectors": {"wrapEl": "#rightPanelCloseButton"},
						"style": Terrasoft.controls.ButtonEnums.style.TRANSPARENT,
						"tag": "rightPanelCloseButton"
					}
				},
				{
					"operation": "insert",
					"name": "communicationPanelContent",
					"parentName": "communicationPanelAll",
					"propertyName": "items",
					"values": {
						"id": "communicationPanelContent",
						"selectors": {"wrapEl": "#communicationPanelContent"},
						"itemType": Terrasoft.ViewItemType.CONTAINER,
						"wrapClass": ["content"],
						"items": []
					}
				},
				{
					"operation": "insert",
					"parentName": "communicationPanelContent",
					"propertyName": "items",
					"name": "email",
					"values": {
						"tag": "Email",
						"generator": "CommunicationPanelHelper.generateMenuItem",
						"markerValue": "email"
					}
				},
				{
					"operation": "insert",
					"parentName": "communicationPanelContent",
					"propertyName": "items",
					"name": "esnFeed",
					"values": {
						"tag": "ESNFeed",
						"generator": "CommunicationPanelHelper.generateMenuItem"
					}
				},
				{
					"operation": "insert",
					"parentName": "communicationPanelContent",
					"propertyName": "items",
					"name": "remindings",
					"values": {
						"tag": "Notifications",
						"generator": "CommunicationPanelHelper.generateMenuItem"
					}
				},
				{
					"operation": "insert",
					"parentName": "communicationPanelContent",
					"propertyName": "items",
					"name": "visas",
					"values": {
						"tag": "Visa",
						"generator": "CommunicationPanelHelper.generateMenuItem",
						"visible": {"bindTo": "VisaVisible"}
					}
				}
			]
		};
	});

define("CommunicationPanel90ef497e-6e18-440d-b80e-d28f2f133509", ["terrasoft", "RemindingsUtilities", "ESNConstants", "CommunicationPanelHelper"],
	function(Terrasoft, RemindingsUtilities, ESNConstants) {
		return {
			messages: {
				"UpdateCounters": {
					"mode": Terrasoft.MessageMode.BROADCAST,
					"direction": Terrasoft.MessageDirectionType.SUBSCRIBE
				}
			},
			attributes: {
				/**
				 * Признак, определяющий активен ли пункт меню «уведомления esn».
				 * @type {Boolean}
				 */
				"ESNNotificationActive": {
					"dataValueType": Terrasoft.DataValueType.BOOLEAN,
					"type": Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
					"value": false
				},

				/**
				 * Конфигурация отображения пункта меню «Уведомления ESN».
				 * @type {Object}
				 */
				"ESNNotificationImageConfig": {
					"dataValueType": Terrasoft.DataValueType.CUSTOM_OBJECT,
					"type": Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
					"value": null
				},

				/**
				 * Счетчик новых уведомлений.
				 * @type {String}
				 */
				"ESNNotificationCounter": {
					"dataValueType": Terrasoft.DataValueType.TEXT,
					"type": Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
					"value": ""
				}
			},
			methods: {

				/**
				 * Выполняет обновление количества уведомлений ESN.
				 * @overridden
				 * @param {Number} countersData.notificationsCount Количество уведомлений.
				 * @param {Number} countersData.visaCount Количество виз.
				 * @param {Number} countersData.esnNotificationsCount Количество уведомлений ESN.
				 */
				updateUserCounters: function(countersData) {
					this.callParent(arguments);
					var esnNotificationsCounterValue = "";
					if (countersData.hasOwnProperty("esnNotificationsCount") &&
							(countersData.esnNotificationsCount > 0)) {
						esnNotificationsCounterValue = countersData.esnNotificationsCount;
					}
					this.set("ESNNotificationCounter", esnNotificationsCounterValue);
				},

				/**
				 * Формирует конфигурационнй объект для обновления значений счетчиков.
				 * @overridden
				 * @param {Object} counters Объект, который в себе содержит значения счетчиков
				 * количества уведомлений.
				 * @return {Object} Конфигурационнй объект для обновления значений счетчиков.
				 */
				getCountersConfig: function(counters) {
					var result = this.callParent(arguments);
					result.esnNotificationsCount = counters.ESNNotificationsCount;
					return result;
				},

				/**
				 * Обработчик сообщения обновления счечиков.
				 * @private
				 */
				onUpdateCounters: function() {
					RemindingsUtilities.getRemindingsCounters(this, this.updateUserCounters);
				},

				/**
				 * Обработчик сообщения изменения счечиков.
				 * @private
				 * @param {Object} scope Контекст выполнения callback-функции.
				 * @param {Function} response Ответ от сервера.
				 */
				onSocialMessageReceived: function(scope, response) {
					if (!response) {
						return;
					}
					if (response.Header.Sender === ESNConstants.WebSocketMessageHeader.ESNNotification) {
						this.onUpdateCounters();
					}
				},

				/**
				 * Инициализирует начальные значения модели.
				 * @protected
				 * @overridden
				 */
				init: function(callback, scope) {
					this.callParent([function() {
						this.sandbox.subscribe("UpdateCounters", this.onUpdateCounters, this);
						this.Terrasoft.ServerChannel.on(this.Terrasoft.EventName.ON_MESSAGE,
							this.onSocialMessageReceived, this);
						if (callback) {
							callback.call(scope || this);
						}
					}, this]);
				},

				/**
				 * Очищает все подписки на события.
				 * @virtual
				 */
				destroy: function() {
					this.Terrasoft.ServerChannel.un(this.Terrasoft.EventName.ON_MESSAGE, this.onSocialMessageReceived,
						this);
					this.callParent(arguments);
				},

				/**
				 * @inheritdoc Terrasoft.CommunicationPanel#getPanelItemConfig
				 * @overridden
				 */
				getPanelItemConfig: function(moduleName) {
					var config = this.callParent(arguments);
					if (moduleName !== "ESNFeedModule") {
						return config;
					}
					return this.Ext.apply(config, {
						keepAlive: true
					});
				}

			},
			diff: [
				{
					"operation": "insert",
					"index": 2,
					"parentName": "communicationPanelContent",
					"propertyName": "items",
					"name": "esnNotification",
					"values": {
						"tag": "ESNNotification",
						"generator": "CommunicationPanelHelper.generateMenuItem"
					}
				}
			]
		};
	});
define("CommunicationPanel", ["terrasoft", "CommunicationPanelHelper", "CtiBaseHelper"],
	function(Terrasoft, CommunicationPanelHelper, CtiBaseHelper) {
		return {
			messages: {

				/**
				 * @message SelectCommunicationPanelItem
				 * Выбирает пункт в коммуникационной панели.
				 * @param {Object} Информация о выбранном пункте коммуникационной панели.
				 */
				"SelectCommunicationPanelItem": {
					"mode": Terrasoft.MessageMode.PTP,
					"direction": Terrasoft.MessageDirectionType.SUBSCRIBE
				},

				/**
				 * @message CallDurationChanged
				 * Изменяет строку с длительностью соответствующего звонка.
				 * @param {String} Длительность звонка.
				 */
				"CallDurationChanged": {
					"mode": Terrasoft.MessageMode.PTP,
					"direction": Terrasoft.MessageDirectionType.SUBSCRIBE
				}
			},
			attributes: {
				/**
				 * Признак, определяющий активен ли пункт меню «CTI панель».
				 * @type {Boolean}
				 */
				"CtiPanelActive": {
					"dataValueType": Terrasoft.DataValueType.BOOLEAN,
					"type": Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
					"value": false
				},

				/**
				 * Счетчик пропущенных звонков.
				 * @type {String}
				 */
				"CtiPanelCounter": {
					"dataValueType": Terrasoft.DataValueType.TEXT,
					"type": Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
					"value": ""
				},

				/**
				 * Время разговора в формате mm:ss.
				 * @type {String}
				 */
				"CallDuration": {
					"dataValueType": Terrasoft.DataValueType.TEXT,
					"type": Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
					"value": null
				},

				/**
				 * Признак, определяющий видим ли пункт меню «CTI панель».
				 * @type {Boolean}
				 */
				"CtiPanelVisible": {
					"dataValueType": Terrasoft.DataValueType.BOOLEAN,
					"type": Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
					"value": false
				},

				/**
				 * Признак, определяющий необходимость загрузки cti-модуля без последующей выгрузки.
				 * @type {Boolean}
				 */
				"CtiPanelModuleKeepAlive": {
					"dataValueType": Terrasoft.DataValueType.BOOLEAN,
					"type": Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
					"value": true
				}
			},
			methods: {

				/**
				 * Инициализирует начальный выделенный пункт меню.
				 * @protected
				 * @overridden
				 * @param {function} callback Функция обратного вызова. Параметром в функцию передается тэг выбранного
				 * пункта меню.
				 */
				initSelectedMenuItem: function(callback) {
					this.sandbox.subscribe("SelectCommunicationPanelItem", this.selectItem.bind(this));
					this.sandbox.subscribe("CallDurationChanged", this.onCallDurationChanged.bind(this));
					this.callParent([function(selectedMenuItemTag) {
						CtiBaseHelper.GetIsTelephonyEnabled(function(isEnabled) {
							this.set("CtiPanelVisible", isEnabled);
							if (!isEnabled && (selectedMenuItemTag === "CtiPanel")) {
								selectedMenuItemTag = "";
							}
							if (isEnabled && (selectedMenuItemTag !== "CtiPanel")) {
								var itemConfig = this.getPanelItemConfig("CtiPanelModule");
								itemConfig.loadHidden = true;
								this.sandbox.publish("CommunicationPanelItemSelected", itemConfig);
							}
							callback(selectedMenuItemTag);
						}.bind(this));
					}.bind(this)]);
				},

				/**
				 * Обрабатывает сообщении о том, что длительность текущего звонка изменилась.
				 * @param callDuration {String} Длительность звонка в формате mm:ss.
				 */
				onCallDurationChanged: function(callDuration) {
					this.set("CallDuration", callDuration);
				},

				/**
				 * @inheritDoc Terrasoft.CommunicationPanel#getPanelItemConfig
				 * @overridden
				 */
				getPanelItemConfig: function(moduleName) {
					var config = this.callParent(arguments);
					if (moduleName !== "CtiPanelModule") {
						return config;
					}
					return Ext.apply(config, {
						keepAlive: true
					});
				},

				/**
				 * Устанавливает выбранный пункт меню.
				 * @private
				 * @param {Object} config Конфигурационный объект выбранного пункта меню.
				 */
				selectItem: function(config) {
					this.set("SelectedMenuItem", config.selectedItem);
				},

				/**
				 * Возвращает конфигурацию изображения элемента меню CtiPanel по его состоянию.
				 * @private
				 * @param {String} itemTag Идентификатор элемента меню.
				 * @returns {Object} Конфигурация изображения.
				 */
				getCtiPanelImageConfig: function(itemTag) {
					var isItemPressed = this.get("SelectedMenuItem") === itemTag;
					var ctiPanelCounter = this.get(itemTag + "Counter");
					var pressedSuffix = isItemPressed ? "Pressed" : Ext.emptyString;
					var counterSuffix = !Ext.isEmpty(ctiPanelCounter) ? "Counter" : Ext.emptyString;
					var callDuration = this.get("CallDuration");
					if (!isItemPressed) {
						counterSuffix = !Ext.isEmpty(callDuration) ? "CallDuration" : counterSuffix;
					}
					var resourceName = Ext.String.format(this.get("Resources.Strings.MenuItemIconNameTemplate"),
						itemTag, pressedSuffix, counterSuffix);
					return this.get("Resources.Images." + resourceName);
				},

				/**
				 * Возвращает стиль элемента меню CtiPanel по его состоянию.
				 * @private
				 * @param {String} itemTag Идентификатор элемента меню.
				 * @returns {String} Стиль изображения.
				 */
				getCtiPanelStyle: function(itemTag) {
					var isItemPressed = this.get("SelectedMenuItem") === itemTag;
					var callDuration = this.get("CallDuration");
					var itemWithCallDuration = (!isItemPressed && !Ext.isEmpty(callDuration));
					return itemWithCallDuration ? "with-call-duration" : "without-call-duration";
				},

				/**
				 * Возвращает подпись пункта меню "Cti панель". Может вернуть либо количество пропущеных звонков,
				 * либо, при наличие звонка и свернутой панели - длительность звонка.
				 * @private
				 * @returns {String} Подпись пункта меню "Cti панель".
				 */
				getCtiPanelCaption: function(itemTag) {
					var isItemPressed = this.get("SelectedMenuItem") === itemTag;
					var ctiPanelCounter = this.get(itemTag + "Counter");
					var callDuration = this.get("CallDuration");
					if (!isItemPressed) {
						return !Ext.isEmpty(callDuration) ? callDuration : ctiPanelCounter;
					}
					return ctiPanelCounter;
				}
			},
			diff: [
				{
					"operation": "insert",
					"index": 0,
					"parentName": "communicationPanelContent",
					"propertyName": "items",
					"name": "ctiPanel",
					"values": {
						"tag": "CtiPanel",
						"visible": {"bindTo": "CtiPanelVisible"},
						"imageConfig": {"bindTo": "getCtiPanelImageConfig"},
						"caption": {"bindTo": "getCtiPanelCaption"},
						"style": {"bindTo": "getCtiPanelStyle"},
						"generator": "CommunicationPanelHelper.generateMenuItem"
					}
				}
			]
		};
	});

				// Autogenerated Code for schema CommunicationPanel (End)
// Autogenerated Code for schema ContextHelpModule (Start)
define('ContextHelpModuleResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={
	HelpButtonHint: 'Справка'
};
var localizableImages={
	'HelpIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'ContextHelpModule', resourceItemName: 'HelpIcon' }}
};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("ContextHelpModule", ["ContextHelpModuleResources", "performancecountermanager", "AcademyUtilities",
		"BaseSchemaModuleV2", "ConfigurationConstants"],
	function(resources, performanceCounterManager, AcademyUtilities) {
		/**
		 * @class Terrasoft.configuration.ContextHelpModule
		 * Класс ContextHelpModule предназначен для создания экземпляра модуля контекстной справки.
		 */
		Ext.define("Terrasoft.configuration.ContextHelpModule", {
			alternateClassName: "Terrasoft.ContextHelpModule",
			extend: "Terrasoft.BaseModule",

			Ext: null,
			sandbox: null,
			Terrasoft: null,

			/**
			 * Внутренняя модель представления модуля контекстной справки.
			 * @type {Object}
			 */
			viewModel: null,

			/**
			 * Получает конфигурацию представления модуля контекстной справки.
			 * @private
			 * @return {Object} Возращает конфигурацию представления
			 */
			getViewConfig: function() {
				var view = {
					className: "Terrasoft.Container",
					id: "context-help-container",
					selectors: {
						el: "#context-help-container",
						wrapEl: "#context-help-container"
					},
					items: [
						{
							className: "Terrasoft.Button",
							style: Terrasoft.controls.ButtonEnums.style.TRANSPARENT,
							classes: {
								wrapperClass: "help-button",
								imageClass: "help-button-image"
							},
							markerValue: "ContextHelpButton",
							hint: resources.localizableStrings.HelpButtonHint,
							imageConfig: resources.localizableImages.HelpIcon,
							click: {bindTo: "linkClick"}
						}
					]
				};
				return view;
			},

			/**
			 * Возращает модель представления модуля контекстной справки.
			 * @private
			 * @return {Object} Модель представления модуля справки.
			 */
			getViewModel: function() {
				var viewModel = this.Ext.create("Terrasoft.BaseViewModel", {
					methods: {
						linkClick: function() {
							var config = {
								callback: function(url) {
									window.open(url, "_blank");
								},
								scope: this,
								contextHelpId: this.get("contextHelpId"),
								contextHelpCode: this.get("contextHelpCode")
							};
							AcademyUtilities.getUrl(config);
						}
					},
					values: {
						/**
						 * Идентификатор раздела справки.
						 * @protected
						 * @type {Number}
						 */
						contextHelpId: 0,

						/**
						 * Флаг, который включает или отключает отображение справки.
						 * @protected
						 * @type {Boolean}
						 */
						enableContextHelp: false
					}
				});
				return viewModel;
			},

			/**
			 * Указатель асинхронности модуля
			 * @type {Boolean} [isAsync=true]
			 */
			isAsync: true,

			/**
			 * Выполняет отрисовку модуля контекстной справки.
			 * @private
			 * @param {Object} renderTo Контейнер в который отрисовывается модуль.
			 */
			render: function(renderTo) {
				var viewConfig = this.getViewConfig();
				var view = this.Ext.create(viewConfig.className || "Terrasoft.Container", viewConfig);
				view.bind(this.viewModel);
				view.render(renderTo);
				performanceCounterManager.setTimeStamp("loadAdditionalModulesComplete");
			},

			/**
			 * Инициализирует настройки контекстной справки.
			 * @private
			 * @param {Object|Number} config Конфигурация справки или её идентификатор.
			 * @param {Number} config.contextHelpId Идентификатор.
			 * @param {String} config.contextHelpCode Код.
			 * @param {String} config.product Редакция продукта.
			 */
			setContextHelp: function(config) {
				var contextHelpId = null;
				var viewModel = this.viewModel;
				if (this.Ext.isNumber(config)) {
					contextHelpId = config;
				} else if (this.Ext.isObject(config)) {
					if (config.contextHelpId) {
						contextHelpId = config.contextHelpId;
					}
					if (config.contextHelpCode) {
						viewModel.set("contextHelpCode", config.contextHelpCode);
					}
					if (config.product) {
						viewModel.set("productEdition", config.product);
					}
				}
				viewModel.set("contextHelpId", contextHelpId);
			},

			/**
			 * Иницализирует начальные значения модуля.
			 * @private
			 * @param {Function} callback Функция обратного вызова.
			 * @param {Object} scope Контекст функции обратного вызова.
			 */
			init: function(callback, scope) {
				var sysSettingsNameArray = ["EnableContextHelp"];
				this.Terrasoft.SysSettings.querySysSettings(sysSettingsNameArray, function(values) {
					this.viewModel = this.getViewModel();
					this.enableContextHelp = values.EnableContextHelp;
					if (this.enableContextHelp) {
						this.sandbox.subscribe("ChangeContextHelpId", function(config) {
							this.setContextHelp(config);
						}, this, [this.sandbox.id]);
						var config = this.sandbox.publish("GetContextHelpId", null, [this.sandbox.id]);
						this.setContextHelp(config);
						if (callback) {
							callback.call(scope);
						}
					}
				}, this);
			}
		});
		return Terrasoft.ContextHelpModule;
	});


				// Autogenerated Code for schema ContextHelpModule (End)
// Autogenerated Code for schema SectionMenuModule (Start)
define('SectionMenuModuleResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={
	'DefaultIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'SectionMenuModule', resourceItemName: 'DefaultIcon' }}
};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("SectionMenuModule", ["SectionMenuModuleResources", "ModuleUtils", "MaskHelper"],
	function(resources, ModuleUtils, MaskHelper) {
		function createConstructor(context) {
			var sideBar;
			var Ext = context.Ext;
			var sandbox = context.sandbox;
			var Terrasoft = context.Terrasoft;
			var info;
			var pages;
			var currentSelection = null;

			var getSideBarItems = function() {
				var config = [];
				var moduleStructure = Terrasoft.configuration.ModuleStructure;
				var modules = info && info.modules ? info.modules : Object.keys(moduleStructure);
				var availableSections = info.AvailableSections;
				var defaultIconUrl = Terrasoft.ImageUrlBuilder.getUrl(resources.localizableImages.DefaultIcon);
				if (modules) {
					modules.forEach(function(module) {
						if (module.moduleId !== Terrasoft.data.constants.GUID_EMPTY) {
							var moduleName = module.moduleName ? module.moduleName : module;
							var moduleConfig = moduleStructure[moduleName];
							var imageId = moduleStructure[moduleName].imageId;
							var imageUrl = imageId ? getImageUrl(imageId) : defaultIconUrl;
							var tag = ModuleUtils.getModuleTag(moduleName);
							if (moduleConfig.hide !== "true") {
								if (!Ext.isArray(availableSections) ||
									(Ext.isArray(availableSections) && availableSections.indexOf(moduleName) >= 0)) {
									config.push({
										caption: moduleStructure[moduleName].moduleCaption,
										tag: tag,
										imageUrl: imageUrl
									});
								}
							}
						}
					});
				}
				return config;
			};

			var getImageUrl = function(imageId) {
				var imageConfig = {
					source: Terrasoft.ImageSources.SYS_IMAGE,
					params: {
						primaryColumnValue: imageId
					}
				};
				var imageUrl = Terrasoft.ImageUrlBuilder.getUrl(imageConfig);
				return imageUrl;
			};

			var render = function(renderTo) {
				MaskHelper.HideBodyMask();
				sandbox.subscribe("PostSectionMenuConfig", function(args) {
					info = args;
					var items = getSideBarItems();
					var index = 0;
					var selectedItemIndex = -1;
					Terrasoft.each(items, function(item) {
						if (item.tag === currentSelection) {
							selectedItemIndex = index;
							return;
						}
						index++;
					});
					if (sideBar) {
						sideBar.destroy();
					}
					sideBar = Ext.create("Terrasoft.SideBar", {
						renderTo: renderTo,
						items: items,
						selectedItemIndex: selectedItemIndex
					});
					sideBar.on("itemSelected", onSidebarItemSelected);
				}, [sandbox.id, "SectionMenuModuleId"]);
				sandbox.publish("GetSectionMenuInfo", sandbox.id);
				var token = sandbox.publish("GetHistoryState");
				if (token) {
					onHistoryStateChanged(token, true);
				}
			};

			function onHistoryStateChanged(token, silent) {
				if (!sideBar) {
					return;
				}
				var currentState = sandbox.publish("GetHistoryState");
				var moduleName = token.hash ? token.hash.moduleName : null;
				var entityName = token.hash ? token.hash.entityName : null;
				var oldOperationType = currentState.hash.operationType;
				if (entityName) {
					entityName = moduleName + "/" + findCurrentSection(entityName, oldOperationType) + "/";
				} else {
					entityName = moduleName + "/";
				}
				onSelectedSideBarItemChanged(entityName, silent);
			}

			function findCurrentSection(entityName, oldOperationType) {
				for (var i = 0; i < pages.length; i += 1) {
					for (var j = 0; j < pages[i].length; j += 1) {
						if (entityName === pages[i][j]) {
							entityName = pages[i][0];
							return entityName;
						}
					}
				}
				if (entityName.search("Page") !== -1) {
					entityName = entityName.replace("Page", "Section");
				} else {
					if (oldOperationType) {
						entityName = oldOperationType + "Section";
					}
				}
				return entityName;
			}

			function findAllSections() {
				var arr = [];
				var isCreated = false;
				var sections = Terrasoft.configuration.ModuleStructure;
				var entityStructure = null;
				for (var i in sections) {
					isCreated = false;
					entityStructure = Terrasoft.configuration.EntityStructure[i] || sections[i].pages;
					var pages = entityStructure ? entityStructure.pages : null;
					if (pages) {
						for (var j = 0; j < pages.length; j += 1) {
							if (pages[j].cardSchema) {
								if (!isCreated) {
									arr[arr.length] = [];
									arr[arr.length - 1][0] = sections[i].sectionSchema;
									isCreated = true;
								}
								arr[arr.length - 1][arr[arr.length - 1].length] = pages[j].cardSchema;
							}
						}
					}
				}
				return arr;
			}

			function onSidebarItemSelected(item, tag) {
				var currentModule = sandbox.publish("GetHistoryState").hash.historyState;
				if (currentModule !== tag) {
					MaskHelper.ShowBodyMask();
					sandbox.publish("PushHistoryState", {hash: tag});
				}
			}

			function init() {
				MaskHelper.ShowBodyMask();
				sandbox.subscribe("FocusCorrectSideBar", function() {
					correctFocusSideBar();
				});
				sandbox.subscribe("SelectedSideBarItemChanged", onSelectedSideBarItemChanged, [sandbox.id]);
				pages = findAllSections();
			}

			function correctFocusSideBar() {
				var currentState = sandbox.publish("GetHistoryState");
				var sectionName = currentState.hash.moduleName + "/" +
					currentState.hash.entityName.replace("Page", "Section") + "/";
				onSelectedSideBarItemChanged(sectionName);
			}

			function onSelectedSideBarItemChanged(item, silent) {
				currentSelection = item;
				if (sideBar) {
					var index = 0;
					sideBar.setSelectedItem();
					Terrasoft.each(sideBar.items, function(sideBarItem) {
						if (compareSideBarItemTag(sideBarItem.tag, item)) {
							sideBar.setSelectedItem(index);
							var config = {
								caption: sideBarItem.caption
							};
							if (silent !== true) {
								sandbox.publish("SectionChanged", config);
							}
							return true;
						}
						index++;
					});
				}
			}

			/**
			 * Сравнивает значения тегов элемента левого меню и тега из хеша.
			 * @param {String} itemTag Тег элетента левого меню.
			 * @param {String} tag Тег из хеша.
			 * @returns {boolean} Совпадение хешей в названии раздела.
			 */
			function compareSideBarItemTag(itemTag, tag) {
				if (itemTag === tag) {
					return true;
				}
				var tagItems = tag.split("/");
				if (tagItems.length > 2 && tagItems[1].indexOf("Section") > 0) {
					var sidebarTagItems = itemTag.split("/");
					if (sidebarTagItems.length > 2 && sidebarTagItems[1] === tagItems[1]) {
						return true;
					}
				}
				return false;
			}

			return Ext.define("SectionMenuModule", {
				init: init,
				render: render
			});
		}
		return createConstructor;
	});

				// Autogenerated Code for schema SectionMenuModule (End)
// Autogenerated Code for schema CommunicationPanelHelper (Start)
define('CommunicationPanelHelperResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={
	EsnFeedMenuHint: 'Лента',
	RemindingsMenuHint: 'Уведомления',
	VisasMenuHint: 'Визы',
	MenuItemIconNameTemplate: '{0}Menu{1}{2}Icon',
	CtiPanelMenuHint: 'CTI панель'
};
var localizableImages={
	'CtiPanelMenuIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanelHelper', resourceItemName: 'CtiPanelMenuIcon' }},
	'CtiPanelMenuPressedIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanelHelper', resourceItemName: 'CtiPanelMenuPressedIcon' }},
	'CtiPanelMenuCounterIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanelHelper', resourceItemName: 'CtiPanelMenuCounterIcon' }},
	'CtiPanelMenuPressedCounterIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanelHelper', resourceItemName: 'CtiPanelMenuPressedCounterIcon' }},
	'EsnFeedMenuIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanelHelper', resourceItemName: 'EsnFeedMenuIcon' }},
	'EsnFeedMenuPressedIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanelHelper', resourceItemName: 'EsnFeedMenuPressedIcon' }},
	'EsnFeedMenuCounterIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanelHelper', resourceItemName: 'EsnFeedMenuCounterIcon' }},
	'EsnFeedMenuPressedCounterIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanelHelper', resourceItemName: 'EsnFeedMenuPressedCounterIcon' }},
	'RemindingsMenuIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanelHelper', resourceItemName: 'RemindingsMenuIcon' }},
	'RemindingsMenuPressedIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanelHelper', resourceItemName: 'RemindingsMenuPressedIcon' }},
	'RemindingsMenuCounterIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanelHelper', resourceItemName: 'RemindingsMenuCounterIcon' }},
	'RemindingsMenuPressedCounterIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanelHelper', resourceItemName: 'RemindingsMenuPressedCounterIcon' }},
	'VisasMenuIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanelHelper', resourceItemName: 'VisasMenuIcon' }},
	'VisasMenuPressedIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanelHelper', resourceItemName: 'VisasMenuPressedIcon' }},
	'VisasMenuCounterIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanelHelper', resourceItemName: 'VisasMenuCounterIcon' }},
	'VisasMenuPressedCounterIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanelHelper', resourceItemName: 'VisasMenuPressedCounterIcon' }},
	'ChatMenuIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanelHelper', resourceItemName: 'ChatMenuIcon' }},
	'ChatMenuPressedIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanelHelper', resourceItemName: 'ChatMenuPressedIcon' }},
	'ChatMenuCounterIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanelHelper', resourceItemName: 'ChatMenuCounterIcon' }},
	'ChatMenuPressedCounterIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanelHelper', resourceItemName: 'ChatMenuPressedCounterIcon' }},
	'EmailsMenuIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanelHelper', resourceItemName: 'EmailsMenuIcon' }},
	'EmailsMenuPressedIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanelHelper', resourceItemName: 'EmailsMenuPressedIcon' }},
	'EmailsMenuCounterIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanelHelper', resourceItemName: 'EmailsMenuCounterIcon' }},
	'EmailsMenuPressedCounterIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanelHelper', resourceItemName: 'EmailsMenuPressedCounterIcon' }},
	'ImageCloseRightSidePanelButton': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanelHelper', resourceItemName: 'ImageCloseRightSidePanelButton' }}
};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("CommunicationPanelHelper", ["BaseModule"], function() {

		/**
		 * @class Terrasoft.configuration.CommunicationPanelHelper
		 * Класс генератора конфигурационных элементов коммуникационной панели.
		 */
		Ext.define("Terrasoft.configuration.CommunicationPanelHelper", {
			alternateClassName: "Terrasoft.CommunicationPanelHelper",
			extend: "Terrasoft.BaseModule",
			Ext: null,
			sandbox: null,
			Terrasoft: null,

			/**
			 * Генерирует пункт меню для коммуникационной панели.
			 * @protected
			 * @param {Object} config Содержит свойства для генерации пунктов меню.
			 * @return {Object} Конфигурация пункта меню.
			 */
			generateMenuItem: function(config) {
				var imageConfig = Ext.isEmpty(config.imageConfig) ? {bindTo: "getItemImageConfig"} : config.imageConfig;
				var itemCaption = Ext.isEmpty(config.caption) ? {bindTo: config.tag + "Counter"} : config.caption;
				var style = Ext.isEmpty(config.style) ? Terrasoft.controls.ButtonEnums.style.TRANSPARENT : config.style;
				return {
					id: "view-button-" + config.name,
					className: "Terrasoft.Button",
					selectors: {wrapEl: "#view-button-" + config.name},
					caption: itemCaption,
					click: {bindTo: "onMenuItemClick"},
					imageConfig: imageConfig,
					hint: {"bindTo": "getHint"},
					pressed: {bindTo: config.tag + "Active"},
					classes: {
						imageClass: ["communication-panel-menu-images-class"],
						pressedClass: ["pressed-button-view"]
					},
					markerValue: config.name,
					style: style,
					tag: config.tag,
					visible: Ext.isEmpty(config.visible) || config.visible,
					width: "100%"
				};
			}
		});

		return Ext.create("Terrasoft.CommunicationPanelHelper");
	});

				// Autogenerated Code for schema CommunicationPanelHelper (End)
// Autogenerated Code for schema CommunicationPanelModule (Start)
define('CommunicationPanelModuleResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={
	CloseRightSidePanel: 'Свернуть панель'
};
var localizableImages={
	'ImageCloseRightSidePanelButton': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CommunicationPanelModule', resourceItemName: 'ImageCloseRightSidePanelButton' }}
};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("CommunicationPanelModule", ["BaseSchemaModuleV2"], function() {
	/**
	 * @class Terrasoft.configuration.CommunicationPanelModule
	 * Класс страницы коммуникационной панели.
	 */
	Ext.define("Terrasoft.configuration.CommunicationPanelModule", {
		alternateClassName: "Terrasoft.CommunicationPanelModule",
		extend: "Terrasoft.BaseSchemaModule",

		/**
		 * Инициализирует название схемы.
		 * @protected
		 * @overridden
		 */
		initSchemaName: function() {
			this.schemaName = "CommunicationPanel";
		},

		/**
		 * Заменяет последний элемент в цепочке состояний, если его идентификатор модуля отличается от текущего.
		 * @protected
		 * @overridden
		 */
		initHistoryState: Ext.emptyFn

	});
	return Terrasoft.CommunicationPanelModule;
});


				// Autogenerated Code for schema CommunicationPanelModule (End)
// Autogenerated Code for schema LeftPanelTopMenuModule (Start)
define('LeftPanelTopMenuModuleResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={
	mainManuMenuItemCaption: 'Главное меню',
	processMenuItemCaption: 'Запустить процесс',
	collapseSideBarMenuItemCaption: 'Свернуть панель разделов',
	expandSideBarMenuItemCaption: 'Развернуть панель разделов',
	showRemindingMenuItemCaption: 'Показать панель уведомлений',
	hideRemindingMenuItemCaption: 'Скрыть панель уведомлений',
	userProfileMenuItemCaption: 'Профиль пользователя',
	processLookupCaption: 'Запуск процесса',
	workPlaceMenuItemCaption: 'РАБОЧЕЕ МЕСТО',
	exitMenuItemCaption: 'Выход',
	AddButtonHint: 'Добавить',
	MenuButtonHint: 'Меню',
	RemindButtonHint: 'Панель уведомлений',
	ESNButtonHint: 'Лента',
	StartProcessButtonHint: 'Запустить процесс',
	AnotherProcessMenuItemCaption: 'Другой процесс',
	RunProcessButtonMenuCaption: 'Запустить процесс',
	systemDesignerMenuItemCaption: 'Дизайнер системы'
};
var localizableImages={
	'homeIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'LeftPanelTopMenuModule', resourceItemName: 'homeIcon' }},
	'menuIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'LeftPanelTopMenuModule', resourceItemName: 'menuIcon' }},
	'RemindingsImage': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'LeftPanelTopMenuModule', resourceItemName: 'RemindingsImage' }},
	'notifyEmptyIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'LeftPanelTopMenuModule', resourceItemName: 'notifyEmptyIcon' }},
	'quickaddIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'LeftPanelTopMenuModule', resourceItemName: 'quickaddIcon' }},
	'collapseIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'LeftPanelTopMenuModule', resourceItemName: 'collapseIcon' }},
	'remindingIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'LeftPanelTopMenuModule', resourceItemName: 'remindingIcon' }},
	'EmptyRemindingsImage': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'LeftPanelTopMenuModule', resourceItemName: 'EmptyRemindingsImage' }},
	'processIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'LeftPanelTopMenuModule', resourceItemName: 'processIcon' }}
};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("LeftPanelTopMenuModule", ["LeftPanelTopMenuModuleResources", "MaskHelper",
	"LookupUtilities", "ConfigurationConstants", "ProcessModuleUtilities", "LeftPanelUtilitiesV2"],
		function(resources, MaskHelper, LookupUtilities, ConfigurationConstants,
				ProcessModuleUtilities, LeftPanelUtilities) {
			function createConstructor(context) {
				var container;
				var Ext = context.Ext;
				var sandbox = context.sandbox;
				var Terrasoft = context.Terrasoft;

				function callServiceMethod(ajaxProvider, requestUrl, callback, dataSend) {
					var provider = ajaxProvider;
					var data = dataSend || {};
					provider.request({
						url: requestUrl,
						headers: {
							"Accept": "application/json",
							"Content-Type": "application/json"
						},
						method: "POST",
						jsonData: data,
						callback: function(request, success, response) {
							var responseObject = {};
							if (success) {
								responseObject = Terrasoft.decode(response.responseText);
							}
							callback.call(this, responseObject);
						},
						scope: this
					});
				}

				var getViewModel = function() {
					var viewModel =  Ext.create("Terrasoft.BaseViewModel", {
						values: {
							collapsed: false,
							quickAddMenu: Ext.create("Terrasoft.BaseViewModelCollection"),
							startProcessMenu: Ext.create("Terrasoft.BaseViewModelCollection"),
							MainMenuItems: Ext.create("Terrasoft.BaseViewModelCollection"),
							IsSystemDesignerVisible: true,
							IsSSP: (Terrasoft.CurrentUser.userType === Terrasoft.UserType.SSP)
						},
						methods: {
							/**
							 * Инициализирует начальные значения модели.
							 * @protected
							 * @overridden
							 */
							init: function(callback, scope) {
								this.loadMenu();
								this.setSystemDesignerVisible();
								LeftPanelUtilities.on("collapsedChanged", this.onSideBarCollapsedChanged, this);
								callback.call(scope);
							},

							/**
							 * Устанавливает, исходя из конфигурации, свойство панели отвечающее за отображение кнопки "Дизайнер системы".
							 * Отвечает за отображение и скрытие кнопки "Дизайнер системы" на панели.
							 * @private
							 * @param {Object} config Конфигурация настроек верхней панели
							 */
							setSystemDesignerVisible: function() {
								var isSystemDesignerVisible = !this.get("IsSSP");
								Terrasoft.SysSettings.querySysSettings(["BuildType"], function(sysSettings) {
									var buildType = sysSettings.BuildType;
									if (buildType && (buildType.value === ConfigurationConstants.BuildType.Public)) {
										isSystemDesignerVisible = false;
									}
									this.set("IsSystemDesignerVisible", isSystemDesignerVisible);
								}, this);
							},

							/**
							 * Возвращает конфигурацию пункта главного меню.
							 * @private
							 * @param {Object} entity Запись из справочника пунктов главного меню.
							 * @return {Object} Конфигурация пункта главного меню.
							 **/
							getConfigMenuItem: function(entity) {
								var uId = entity.get("IntroPageUId");
								var name = entity.get("Name");
								var tag = entity.get("Tag");
								return {
									Id: uId,
									Caption: name,
									Tag: tag,
									Class: "menu-item",
									Click: {bindTo: "goToIntroPageFromMenu"}
								};
							},

							/**
							 * Заполняет коллекцию пунктов главного меню.
							 * @protected
							 */
							loadItemsMainMenu: function() {
								var esq = Ext.create("Terrasoft.EntitySchemaQuery", {
									rootSchemaName: "ApplicationMainMenu",
									isDistinct: true
								});
								esq.addColumn("Id");
								esq.addColumn("IntroPageUId");
								esq.addColumn("Name");
								esq.addColumn("[SysSchema:UId:IntroPageUId].Name", "Tag");
								esq.getEntityCollection(function(result) {
									if (!result.success) {
										return;
									}
									var menuCollection = Ext.create("Terrasoft.BaseViewModelCollection");
									var entities = result.collection;
									var mainMenuConfig = {
										Id: "menu-menu-item",
										Tag: "MainMenu",
										Caption: resources.localizableStrings.mainManuMenuItemCaption,
										Visible: {
											bindTo: "IsSSP",
											bindConfig: {
												converter: function(value) {
													return !value;
												}
											}
										}
									};
									var entitiesCount = entities.getCount();
									if (entitiesCount === 0) {
										mainMenuConfig.Class = "menu-item";
										mainMenuConfig.Click = {bindTo: "goToFromMenu"};
										menuCollection.add(mainMenuConfig.Id, Ext.create("Terrasoft.BaseViewModel", {
											values: mainMenuConfig
										}));
									} else if (entitiesCount === 1) {
										entities.each(function(entity) {
											var menuItem = this.getConfigMenuItem(entity);
											menuItem.Caption = mainMenuConfig.Caption;
											menuCollection.add(menuItem.Id, Ext.create("Terrasoft.BaseViewModel", {
												values: menuItem
											}));
										}, this);
									} else {
										mainMenuConfig.Type = "Terrasoft.MenuSeparator";
										menuCollection.add(mainMenuConfig.Id, Ext.create("Terrasoft.BaseViewModel", {
											values: mainMenuConfig
										}));
										entities.each(function(entity) {
											var menuItem = this.getConfigMenuItem(entity);
											menuCollection.add(menuItem.Id, Ext.create("Terrasoft.BaseViewModel", {
												values: menuItem
											}));
										}, this);
										var id = "end-menu-menu-item";
										menuCollection.add(id, Ext.create("Terrasoft.BaseViewModel", {
											values: {
												Id: id,
												Type: "Terrasoft.MenuSeparator"
											}
										}));
									}
									var mainMenuItems = this.get("MainMenuItems");
									menuCollection.loadAll(mainMenuItems);
									mainMenuItems.clear();
									mainMenuItems.loadAll(menuCollection);
								}, this);
							},

							loadItemsQuickAddMenu: function() {
								var collection = this.get("quickAddMenu");
								collection.clear();
								var quickItems = Terrasoft.configuration.QuickAddMenu.QuickAddMenu;
								Terrasoft.each(quickItems, function(item) {
									var id = item.itemId;
									collection.add(id, Ext.create("Terrasoft.BaseViewModel", {
										values: {
											Id: id,
											Caption: item.name,
											Click: {bindTo: "processQuickMenuClick"},
											ModuleName: item.ModuleName,
											Tag: id,
											TypeColumnName: item.TypeColumnName,
											TypeColumnValue: item.TypeColumnValue,
											EditPageName: item.EditPageName
										}
									}));
								}, this);
							},

							processQuickMenuClick: function(tag) {
								var collection = this.get("quickAddMenu");
								var quickMenuItem = collection.get(tag);
								var moduleName = quickMenuItem.get("ModuleName") || "SysModuleEditManageModule";
								require([moduleName], function(module) {
									if (module) {
										module.Run({
											sandbox: sandbox,
											item: quickMenuItem
										});
									}
								});
							},

							/**
							 * Заполняет коллекцию пунктов меню глобальной кнопки запуска бизнес-процессов
							 */
							loadItemsStartProcessMenu: function() {
								var filters = [];
								filters.push(
										Terrasoft.createExistsFilter("[RunButtonProcessList:SysSchemaUId:UId].Id"));
								var select = ProcessModuleUtilities.createRunProcessSelect(filters);
								select.getEntityCollection(function(result) {
									if (result.success) {
										var startProcessMenuItems = this.get("startProcessMenu");
										startProcessMenuItems.clear();
										var entities = result.collection;
										var existsAnyAvailableToRunProcess = entities.getCount() > 0;
										if (!existsAnyAvailableToRunProcess) {
											return;
										}
										var id = "caption-runprocess-menu-item";
										startProcessMenuItems.add(id, Ext.create("Terrasoft.BaseViewModel", {
											values: {
												Id: id,
												Type: "Terrasoft.MenuSeparator",
												Caption: resources.localizableStrings.RunProcessButtonMenuCaption
											}
										}));
										var idColumnName = "Id";
										var captionColumnName = "Caption";
										entities.each(function(entity) {
											id = entity.get(idColumnName);
											var caption = entity.get(captionColumnName);
											startProcessMenuItems.add(id, Ext.create("Terrasoft.BaseViewModel", {
												values: {
													Id: id,
													Caption: caption,
													Click: {bindTo: "runProcess"},
													Tag: id,
													MarkerValue: caption
												}
											}));
										}, this);
										id = "separator-runprocess-menu-item";
										startProcessMenuItems.add(id, Ext.create("Terrasoft.BaseViewModel", {
											values: {
												Id: id,
												Type: "Terrasoft.MenuSeparator",
												Caption: resources.localizableStrings.mainManuMenuItemCaption
											}
										}));
										id = "open-process-page";
										startProcessMenuItems.add(id, Ext.create("Terrasoft.BaseViewModel", {
											values: {
												Id: id,
												Caption: resources.localizableStrings.AnotherProcessMenuItemCaption,
												Click: {bindTo: "openProcessPage"},
												Tag: id
											}
										}));
									} else {
										throw new Terrasoft.QueryExecutionException();
									}
								}, this);
							},

							/**
							 * Возвращает конфигурацию отображения элементов.
							 * @return {Object}
							 */
							getViewConfig: function() {
								var view = {
									id: "side-bar-top-menu-module-container",
									selectors: {
										wrapEl: "#side-bar-top-menu-module-container"
									},
									classes: {
										wrapClassName: ["top-menu-module-container"]
									},
									items: this.getTopMenuConfig()
								};
								return view;
							},

							/**
							 * Возвращает объект меню.
							 * @return {Object}
							 */
							loadMenu: function() {
								this.loadItemsStartProcessMenu();
								sandbox.subscribe("ResetStartProcessMenuItems", function() {
									this.loadItemsStartProcessMenu();
								}, this);
								this.loadItemsQuickAddMenu();
								var menuCollection = Ext.create("Terrasoft.BaseViewModelCollection");
								var id = "process-menu-item";
								menuCollection.add(id, Ext.create("Terrasoft.BaseViewModel", {
									values: {
										Id: id,
										Tag: "ProcessExecute",
										Caption: resources.localizableStrings.processMenuItemCaption,
										Click: {bindTo: "openProcessPage"},
										Visible: {
											bindTo: "IsSSP",
											bindConfig: {
												converter: function(value) {
													return !value;
												}
											}
										}
									}
								}));
								id = "collapse-menu-item";
								menuCollection.add(id, Ext.create("Terrasoft.BaseViewModel", {
									values: {
										Id: id,
										Tag: "CollapseMenu",
										Caption: this.getCollapseSideBarMenuItemCaptionConfig(),
										Click: {bindTo: "collapseSideBar"}
									}
								}));
								var workplaceMenu = this.getWorkplaceMenu();
								if (workplaceMenu.getCount() > 0) {
									menuCollection.loadAll(workplaceMenu);
								}
								id = "system-designer-menu-item";
								menuCollection.add(id, Ext.create("Terrasoft.BaseViewModel", {
									values: {
										Id: id,
										Tag: "IntroPage/SystemDesigner",
										Caption: resources.localizableStrings.systemDesignerMenuItemCaption,
										Click: {bindTo: "goToFromMenu"},
										Visible: {bindTo: "IsSystemDesignerVisible"}
									}
								}));
								id = "profile-menu-item";
								menuCollection.add(id, Ext.create("Terrasoft.BaseViewModel", {
									values: {
										Id: id,
										Tag: "ProfileModule",
										Caption: resources.localizableStrings.userProfileMenuItemCaption,
										Click: {bindTo: "goToFromMenu"}
									}
								}));
								id = "exit-menu-item";
								menuCollection.add(id, Ext.create("Terrasoft.BaseViewModel", {
									values: {
										Id: id,
										Tag: "Exit",
										ClassName: "Terrasoft.MenuItem",
										Caption: resources.localizableStrings.exitMenuItemCaption,
										Click: {bindTo: "exitClick"}
									}
								}));
								var mainMenuItems = this.get("MainMenuItems");
								mainMenuItems.loadAll(menuCollection);
								this.loadItemsMainMenu();
							},

							/**
							 * Возвращает объект меню для рабочих мест.
							 * @return {Object}
							 */
							getWorkplaceMenu: function() {
								var workplaceMenuItems = Ext.create("Terrasoft.BaseViewModelCollection");
								var workplaces = Terrasoft.deepClone(Terrasoft.configuration.WorkplacesStructure.Workplaces);
								if (workplaces.length > 0) {
									var id = "separator-top-menu-item";
									workplaceMenuItems.add(id, Ext.create("Terrasoft.BaseViewModel", {
										values: {
											Id: id,
											Type: "Terrasoft.MenuSeparator",
											Caption: resources.localizableStrings.workPlaceMenuItemCaption
										}
									}));
									workplaces.sort(function(a, b) {
										if (a.name < b.name) {
											return -1;
										}
										if (a.name > b.name) {
											return 1;
										}
										return 0;
									});
									Terrasoft.each(workplaces, function(item) {
										if (item.hide) {
											return;
										}
										var menuItemConfig = {
											Caption: item.name,
											Tag: item.workplaceId,
											Click: {
												bindTo: "workPlaceMenuItemClick"
											}
										};
										workplaceMenuItems.add(Ext.create("Terrasoft.BaseViewModel", {
											values: menuItemConfig
										}));
									}, this);
									id = "separator-botom-menu-item";
									workplaceMenuItems.add(id, Ext.create("Terrasoft.BaseViewModel", {
										values: {
											Id: id,
											Type: "Terrasoft.MenuSeparator"
										}
									}));
								}
								return workplaceMenuItems;
							},

							/**
							 * Возвращает конфигурацию верхнего меню.
							 * @return {Object}
							 */
							getTopMenuConfig: function() {
								var menuConfig = [
									{
										id: "collapse-button",
										tag: "CollapseMenu",
										className: "Terrasoft.Button",
										style: Terrasoft.controls.ButtonEnums.style.TRANSPARENT,
										classes: {
											imageClass: ["button-image-size"],
											wrapperClass: ["collapse-button-wrapperEl"]
										},
										imageConfig: resources.localizableImages.collapseIcon,
										click: {
											bindTo: "collapseSideBar"
										},
										hint: this.getCollapseSideBarMenuItemCaptionConfig()
									},
									{
										id: "menu-button",
										tag: "MainMenu",
										className: "Terrasoft.Button",
										style: Terrasoft.controls.ButtonEnums.style.TRANSPARENT,
										hint: resources.localizableStrings.MenuButtonHint,
										classes: {
											imageClass: ["button-image-size"],
											wrapperClass: ["menu-button-wrapperEl"]
										},
										imageConfig: resources.localizableImages.menuIcon,
										menu: {
											items: {bindTo: "MainMenuItems"}
										}
									},
									{
										id: "menu-startprocess-button",
										tag: "StartProcessMenu",
										className: "Terrasoft.Button",
										style: Terrasoft.controls.ButtonEnums.style.TRANSPARENT,
										hint: resources.localizableStrings.StartProcessButtonHint,
										classes: {
											imageClass: ["button-image-size"],
											wrapperClass: ["menu-startprocess-button-wrapperEl"]
										},
										imageConfig: resources.localizableImages.processIcon,
										menu: {
											items: {bindTo: "startProcessMenu"}
										},
										click: {
											bindTo: "openProcessPage"
										},
										visible: {
											bindTo: "IsSSP",
											bindConfig: {
												converter: function(value) {
													return !value;
												}
											}
										}
									},
									{
										id: "menu-quickadd-button",
										tag: "quickAddMenu",
										className: "Terrasoft.Button",
										style: Terrasoft.controls.ButtonEnums.style.TRANSPARENT,
										classes: {
											imageClass: ["button-image-size"],
											wrapperClass: ["menu-quickadd-button-wrapperEl"]
										},
										hint: resources.localizableStrings.AddButtonHint,
										imageConfig: resources.localizableImages.quickaddIcon,
										menu: {
											items: {bindTo: "quickAddMenu"}
										},
										visible: {
											bindTo: "IsSSP",
											bindConfig: {
												converter: function(value) {
													return !value;
												}
											}
										}
									}
								];
								return menuConfig;
							},

							/**
							 * Возвращает конфигурацию для элемента переключения свёрнутости левой панели.
							 * @return {Object}
							 */
							getCollapseSideBarMenuItemCaptionConfig: function() {
								return {
									bindTo: "Collapsed",
									bindConfig: {
										converter: this.getCollapseSideBarMenuItemCaption
									}
								};
							},

							/**
							 * Запускает бизнес-процесс из списка глобальной кнопки запуска процессов
							 * @param {Object} tag UId схемы бизнес-процесса
							 */
							runProcess: function(tag) {
								ProcessModuleUtilities.executeProcess({
									sysProcessId: tag
								});
							},
							goTo: function() {
								var tag = arguments[3];
								var currentModule = sandbox.publish("GetHistoryState").hash.historyState;
								if (currentModule !== tag) {
									MaskHelper.ShowBodyMask();
									sandbox.publish("PushHistoryState", {hash: tag});
								}
							},
							exitClick: function() {
								var ajaxProvider = Terrasoft.AjaxProvider;
								var requestUrl = Terrasoft.workspaceBaseUrl + "/rest/MainMenuService/Logout";
								callServiceMethod(ajaxProvider, requestUrl, function() {
									window.logout = true;
									window.location.replace(Terrasoft.loaderBaseUrl + "/simpleLogin");
								}, {});
							},
							goToFromMenu: function(tag) {
								var currentHistoryState = sandbox.publish("GetHistoryState").hash.historyState;
								if (currentHistoryState !== tag) {
									if (tag !== "ProfileModule") {
										MaskHelper.ShowBodyMask();
									}
									sandbox.publish("PushHistoryState", {hash: tag});
								}
							},
							goToIntroPageFromMenu: function(tag) {
								var currentHistoryState = sandbox.publish("GetHistoryState").hash.historyState;
								if (currentHistoryState !== tag) {
									//MaskHelper.ShowBodyMask();
									var hash = "IntroPage/" + tag;
									sandbox.publish("PushHistoryState", {hash: hash});
								}
							},
							openProcessPage: function() {
								var vwSysProcessFilters = Terrasoft.createFilterGroup();
								vwSysProcessFilters.name = "vwSysProcessFiler";
								vwSysProcessFilters.logicalComparisonTypes = Terrasoft.LogicalOperatorType.AND;
								var sysWorkspaceFilter = Terrasoft.createColumnFilterWithParameter(
										Terrasoft.ComparisonType.EQUAL, "SysWorkspace",
										Terrasoft.SysValue.CURRENT_WORKSPACE.value);
								vwSysProcessFilters.addItem(sysWorkspaceFilter);
								var businessProcessTagFilter = Terrasoft.createColumnFilterWithParameter(
										Terrasoft.ComparisonType.EQUAL, "TagProperty",
										ConfigurationConstants.SysProcess.BusinessProcessTag);
								vwSysProcessFilters.addItem(businessProcessTagFilter);
								var isMaxVersionFilter = Terrasoft.createColumnFilterWithParameter(
										Terrasoft.ComparisonType.EQUAL, "IsMaxVersion", true);
								vwSysProcessFilters.addItem(isMaxVersionFilter);
								var config = {
									entitySchemaName: "VwSysProcess",
									isRunProcessPage: true,
									captionLookup: resources.localizableStrings.processLookupCaption,
									multiSelect: false,
									columnName: "Caption",
									filters: vwSysProcessFilters,
									hideActions: true
								};
								var handler = function(args) {
									var activeItems = args.selectedRows.getItems();
									if (!Ext.isEmpty(activeItems)) {
										ProcessModuleUtilities.executeProcess({
											sysProcessId: activeItems[0].Id
										});
									}
								};
								LookupUtilities.Open(sandbox, config, handler, this, null, false, false);
							},
							collapseSideBar: function() {
								LeftPanelUtilities.changeCollapsed();
							},
							showESN: function() {
								var esnHash = "SectionModuleV2/ESNFeedSectionV2/";
								var currentModule = sandbox.publish("GetHistoryState").hash.historyState;
								if (currentModule !== esnHash) {
									MaskHelper.ShowBodyMask();
									sandbox.publish("PushHistoryState", {hash: esnHash});
								}
							},
							/**
							 * Возвращает текст для элемента переключения свёрнутости левой панели.
							 * @param {Boolean} isCollapsed Признак свёрнутости.
							 * @return {String} Текст для элемента переключения свёрнутости левой панели.
							 */
							getCollapseSideBarMenuItemCaption: function(isCollapsed) {
								if (Ext.isEmpty(isCollapsed)) {
									isCollapsed = LeftPanelUtilities.getDefaultCollapsed();
								}
								if (isCollapsed) {
									return resources.localizableStrings.expandSideBarMenuItemCaption;
								} else {
									return resources.localizableStrings.collapseSideBarMenuItemCaption;
								}
							},
							workPlaceMenuItemClick: function(tag) {
								var workplaceItem = this.getWorkplaceData(tag);
								if (workplaceItem) {
									sandbox.publish("ChangeCurrentWorkplace", tag);
								}
							},
							getWorkplaceData: function(workplaceId) {
								var workplaces = Terrasoft.configuration.WorkplacesStructure.Workplaces;
								var workplaceItem = null;
								if (workplaces.length > 0) {
									Terrasoft.each(workplaces, function(item) {
										if (item.workplaceId === workplaceId) {
											workplaceItem = item;
										}
									}, this);
								}
								return workplaceItem;
							},
							/**
							 * Обработчик события изменения свёрнутости левой панели.
							 * @param {Boolean} isCollapsed Признак свёрнутости.
							 */
							onSideBarCollapsedChanged: function(isCollapsed) {
								sandbox.publish("ChangeSideBarCollapsed", isCollapsed);
								this.set("Collapsed", isCollapsed);
							}
						}
					});
					return viewModel;
				};

				var generate = function() {
					var viewModel = this.viewModel;
					var view = this.view;
					if (!Ext.isEmpty(viewModel) && !Ext.isEmpty(view)) {
						view.destroy();
					}
					var viewConfig = viewModel.getViewConfig();
					view = Ext.create("Terrasoft.Container", Terrasoft.deepClone(viewConfig));
					view.bind(viewModel);
					view.render(container);
					MaskHelper.HideBodyMask();
				};

				function render(renderTo) {
					container = renderTo;
					generate.call(this);
				}

				function init(callback, scope) {
					var viewModel = this.viewModel = getViewModel();
					callback = callback || Ext.emptyFn;
					scope = scope || this;
					viewModel.init(function() {
						callback.call(scope);
					}, this);
				}

				return Ext.define("Terrasoft.configuration.LeftPanelTopMenuModule", {
					extend: "Terrasoft.BaseModule",
					render: render,
					init: init,
					isAsync: false,
					viewModel: null,
					generate: generate
				});
			}

			return createConstructor;
		});
		

				// Autogenerated Code for schema LeftPanelTopMenuModule (End)
// Autogenerated Code for schema ProcessHelper (Start)
define('ProcessHelperResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={
	ContinueByProcessCaption: 'Продолжить по процессу'
};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("ProcessHelper", ['ext-base', 'terrasoft', "ProcessHelperResources"],
	function(Ext, Terrasoft, resources) {


	function cardOnLoadEntryPoint(response) {
		var buttonRenderTo = Ext.get('utils-left');
		if (!Ext.isArray(response) || response.length === 0 || Ext.isEmpty(buttonRenderTo)) {
			return;
		}
		var buttonConfig = {
			style: Terrasoft.controls.ButtonEnums.style.DEFAULT,
			caption: resources.localizableStrings.ContinueByProcessCaption,
			renderTo: buttonRenderTo
		}
		if (response.length > 1) {
			var buttonItems = [];
			Terrasoft.each(response, function(item) {
				buttonItems.push({
					caption: item.caption,
					tag: item.id,
					click: {
						bindTo: 'onEntryPointSelectFromItems'
					}
				});
			}, this);
			buttonConfig.menu = { items: buttonItems };
		} else {
			buttonConfig.tag = response[0].id;
			buttonConfig.click = {
				bindTo: 'onEntryPointSelectFromSingle'
			}
		}

		var entryPointsButton = Ext.create('Terrasoft.Button', buttonConfig);
		entryPointsButton.bind(this);
	}

	function onEntryPointSelectFromSingle(event, caller, fn, tag) {
		moveThroughEntryPoint.call(this, tag);
	}

	function onEntryPointSelectFromItems(tag) {
		moveThroughEntryPoint.call(this, tag);
	}

	function moveThroughEntryPoint(tag) {
		var sandbox = this.getSandbox();
		var id = this.get(this.entitySchema.primaryColumnName);
		var callback = function(args) {
			console.log(Ext.String.format('Process {0} Error', args.id));
		}
		processElementChanged(tag, id, sandbox, callback, this);
	}

	function prepareCard() {
		var processListeners = this.get('ProcessListeners');
		if (Ext.isEmpty(processListeners) || processListeners <= 0) {
			return;
		}
		var sandbox = this.getSandbox();
		if (Ext.isEmpty(this.entitySchema)) {
			return;
		}
		var entitySchema = this.entitySchema;
		var entitySchemaUId = entitySchema.uId;
		var id = this.get(entitySchema.primaryColumnName);
		if (!Terrasoft.isGUID(id)) {
			return;
		}

		this.onEntryPointSelectFromSingle = onEntryPointSelectFromSingle;
		this.onEntryPointSelectFromItems = onEntryPointSelectFromItems;

		sandbox.publish('GetProcessEntryPointsData', {
			entitySchemaUId: entitySchemaUId,
			recordId: id,
			callback: cardOnLoadEntryPoint,
			scope: this
		});
	}

	function processElementChanged(procElUId, recordId, sandbox, errorCallback, scope) {
		sandbox.publish('ProcessExecDataChanged', {
			procElUId: procElUId,
			recordId: recordId,
			scope: this,
			parentMethodArguments: { id: procElUId },
			parentMethod: errorCallback
		});
	}

	function getProcessElementData(sandbox) {
		return sandbox.publish('GetProcessExecData')
	}
	function getIsDateTimeDataValueType(dataValueType) {
		return (dataValueType && (dataValueType === Terrasoft.DataValueType.DATE
			|| dataValueType === Terrasoft.DataValueType.DATE_TIME
			|| dataValueType === Terrasoft.DataValueType.TIME));
	}

	function getClientValueByDataValueType(value, dataValueType) {
		try {
			if (getIsDateTimeDataValueType(dataValueType)) {
				return Terrasoft.parseDate(value);
			}
		} catch (e) {

		}
		return value;
	}

	function getServerValueByDataValueType(value, dataValueType) {
		try {
			if (getIsDateTimeDataValueType(dataValueType)) {
				return Terrasoft.encodeDate(value);
			}
		} catch (e) {
		}
		return value;
	}

	return {
		getClientValueByDataValueType: getClientValueByDataValueType,
		getServerValueByDataValueType: getServerValueByDataValueType,
		getProcessElementData: getProcessElementData,
		processElementChanged: processElementChanged,
		getIsDateTimeDataValueType: getIsDateTimeDataValueType,
		prepareCard: function(viewModel) {
			prepareCard.call(viewModel)
		}
	};
});

				// Autogenerated Code for schema ProcessHelper (End)
// Autogenerated Code for schema ProcessModuleUtilities (Start)
define('ProcessModuleUtilitiesResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={
	DisableInDemoMessage: 'Это действие недоступно в демонстрационной версии',
	ErrorStartBusinessProcess: 'Ошибка запуска бизнес процесса {0}. Ответ сервера {1}.',
	CustomPackageName: 'Custom',
	PublishMaskCaption: 'Публикация...'
};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("ProcessModuleUtilities", ["ext-base", "terrasoft", "ProcessModuleUtilitiesResources",
		"ConfigurationConstants", "MaskHelper",  "ConfigurationEnums"],
	function(Ext, Terrasoft, resources, ConfigurationConstants, MaskHelper, ConfigurationEnums) {
	/**
	 * @class Terrasoft.configuration.ProcessModuleUtilities
	 * Класс ProcessModuleUtilities содержит утилитные методы для работы со схемами процессов
	 */
	Ext.define("Terrasoft.configuration.ProcessModuleUtilities", {
		alternateClassName: "Terrasoft.ProcessModuleUtilities",
		singleton: true,
		PROCESS_ENGINE_SERVICE_NAME: "ServiceModel/ProcessEngineService.svc",
		PROCESS_SCHEMA_MANAGER_SERVICE_NAME: "ServiceModel/ProcessSchemaManagerService.svc",
		REQUEST_TIMEOUT: 900000000,

		/**
		 * Флаг, указывающий на то, что приложение работает в демо-режиме
		 * @protected
		 * @type {Boolean}
		 */
		isDemoBuild: false,

		/**
		 * Конструктор класса.
		 * @protected
		 */
		constructor: function() {
			this.callParent(arguments);
			this.setIsDemoBuild();
		},

		/**
		 * Инициализирует признак демо-сборки
		 * @private
		 */
		setIsDemoBuild: function() {
			Terrasoft.SysSettings.querySysSettingsItem("ShowDemoLinks", function(value) {
				this.isDemoBuild = value;
			}, this);
		},

		/**
		 * Проверяет, что приложение работает в демо-режиме и выводит соотв. сообщение
		 * @param {Object} scope Контекст модели, в рамках которого проводится проверка
		 */
		getIsDemoMode: function(scope) {
			if (this.isDemoBuild) {
				scope.showInformationDialog(resources.localizableStrings.DisableInDemoMessage);
			}
			return this.isDemoBuild;
		},

		/**
		 * Возвращает колличество запущенных элементов процесса
		 * @param procExecDataCollection Коллексция запущенных элементов процесса
		 * @returns {number}
		 */
		getProcExecDataCollectionCount: function(procExecDataCollection) {
			var itemsCount = 0;
			for (var propertyName in procExecDataCollection) {
				if (!procExecDataCollection.hasOwnProperty(propertyName) || propertyName === "previousProcElUId") {
					continue;
				}
				var item = procExecDataCollection[propertyName];
				if (item && (typeof item !== "function") && !Ext.isEmpty(item.procElUId)) {
					itemsCount++;
				}
			}
			return itemsCount;
		},

		/**
		 * Открывает 5x диграмму выполнения процессов
		 * @param {String} schemaUId Уникальный идентификатор cхемы
		 */
		showProcessDiagram: function(schemaUId) {
			var url = "../ViewPage.aspx?Id=" + ConfigurationConstants.ProcessLog.sysProcessLogViewPageId +
				"&recordId=" + schemaUId;
			window.open(url);
		},

		/**
		 * Открывает дизайнер процессов 5x
		 * @param {String} schemaUId Уникальный идентификатор cхемы, если не задан будет отрыт дизайнер новой схемы
		 */
		show5xProcessSchemaDesigner: function(schemaUId) {
			var schemaUIdParameter = Ext.isEmpty(schemaUId) ? "" : schemaUId;
			Terrasoft.AjaxProvider.request({
				url: "../ServiceModel/ProcessSchemaManagerService.svc/PrepareSchemaForEdit?schemaUId=" +
						schemaUIdParameter,
				method: "POST",
				scope: this,
				callback: function(request, success, response) {
					if (success) {
						var isNewSchema = (Ext.isEmpty(schemaUId) || Terrasoft.isEmptyGUID(schemaUId)) ? "1" : "0";
						var url = "../Designers/ProcessSchemaDesigner.aspx?Id=" +
								Ext.decode(response.responseText) + "&isNewSchema=" + isNewSchema;
						window.open(url);
					}
				}
			});
		},

		/**
		 * Открывает дизайнер процессов 7x
		 * @param {String} schemaUId Уникальный идентификатор cхемы, если не задан будет отрыт дизайнер новой схемы
		 */
		show7xProcessSchemaDesigner: function(schemaUId) {
			var isNewSchema = (Ext.isEmpty(schemaUId) || Terrasoft.isEmptyGUID(schemaUId)) ? "1" : "0";
			var schemaUIdParameter = Ext.isEmpty(schemaUId) ? Terrasoft.generateGUID() : schemaUId;
			window.open("./SchemaDesigner.aspx#process/" + schemaUIdParameter + "/" + isNewSchema);
		},

		/**
		 * Возвращает имя продукта необходимое для отображения контекстной справки
		 * @return {String} Имя продукта.
		 */
		getContextHelpProductName: function() {
			return "BPMS";
		},

		/**
		 * Открывает карточку редактирования активности по бизнес-процессу.
		 * @param {Object} config Объект конфигурации.
		 * Примеры вызова:
		 * 1. tryShowProcessCard(config);
		 * 2. tryShowProcessCard(prcElId, recordId, operation);
		 * @return {boolean} Открыта ли карточка редактирования.
		 */
		tryShowProcessCard: function(config) {
			var processExecDataConfig = {
					scope: this,
					parentMethodArguments: null,
					parentMethod: null,
				operation:  ConfigurationEnums.CardStateV2.EDIT
			};
			if (Ext.isObject(config)) {
				processExecDataConfig = Ext.apply(processExecDataConfig, config);
			} else {
				processExecDataConfig.procElUId = arguments[0];
				processExecDataConfig.recordId = arguments[1];
				if (arguments.length > 2) {
					processExecDataConfig.operation = arguments[2];
				}
			}
			if (processExecDataConfig.procElUId && !Terrasoft.isEmptyGUID(processExecDataConfig.procElUId)) {
				this.sandbox.publish("ProcessExecDataChanged", processExecDataConfig);
				return true;
			}
			return false;
		},

		/**
		 * Вызывает метод веб сервиса с указанными параметрами
		 * @param {Object} config обьект, который содержит название сервиса, название метода, данные
		 * @param {Function} callback Функция обратного вызова
		 * @param {Object} scope Контекст callback-функции.
		 * @returns {Object} обьект запроса
		 */
		callService: function(config, callback, scope) {
			var dataSend = config.data || {};
			var jsonData = (config.encodeData === false) ? dataSend : Ext.encode(dataSend);
			var requestUrl = Terrasoft.combinePath(Terrasoft.workspaceBaseUrl,
				config.serviceName, config.methodName);
			return Terrasoft.AjaxProvider.request({
				url: requestUrl,
				headers: {
					"Accept": "application/json",
					"Content-Type": "application/json"
				},
				method: "POST",
				jsonData: jsonData,
				callback: callback,
				scope: scope || this,
				timeout: config.timeout
			});
		},

		/**
		 * Функция, которая вызывается после выполнения метода сервиса
		 * @private
		 * @param {Object} request Экземпляр запроса
		 * @param {Boolean} success Признак успешного ответа сервера
		 * @param {Object} response Ответ сервера
		 */
		responseCallback: function(request, success, response) {
			MaskHelper.HideBodyMask();
			if (!success || !response.responseText) {
				return;
			}
			var responseData = Ext.decode(Ext.decode(response.responseText));
			if (!responseData) {
				return;
			}
			if (responseData.message) {
				Terrasoft.utils.showInformation(responseData.message);
			}
			if (responseData.success) {
				return;
			}
			if (window.console && window.console.warn) {
				window.console.warn(responseData.message);
			}
		},
		/**
		 * Запускает на выполнение бизнес-процесс
		 * @private
		 * @param {String} processName Имя схемы процесса
		 * @param {Object} processParameters Параметры процесса
		 * @param {Function} callback Функция обратного вызова
		 * @param {Terrasoft.BaseSchemaViewModel} scope Контекст выполнения
		 */
		runProcess: function(processName, processParameters, callback, scope) {
			var parametersQueryString = "";
			if (!Ext.isEmpty(processParameters)) {
				parametersQueryString += "?";
				var isNotFirstParameter = false;
				Terrasoft.each(processParameters, function(value, name) {
					if (isNotFirstParameter) {
						parametersQueryString += "&";
					} else {
						isNotFirstParameter = true;
					}
					parametersQueryString += name + "=" + value;
				}, scope);
			}
			MaskHelper.ShowBodyMask();
			this.callService({
				serviceName: this.PROCESS_ENGINE_SERVICE_NAME,
				methodName: processName + "/RunProcess" + parametersQueryString
			}, callback, scope);
		},

		/**
		 * Сохранить схему БП
		 */
		saveProcessSchema: function(scope, schema, callback) {
			var responseCallback = function(request, success, response) {
				if (!success) {
					return;
				}
				var responseObject = Ext.decode(Ext.decode(response.responseText));
				if (callback) {
					callback.call(scope || this, responseObject);
				}
				if (responseObject.success && responseObject.message) {
					Terrasoft.utils.showInformation(responseObject.message);
				}
			};
			this.callService({
				serviceName: this.PROCESS_SCHEMA_MANAGER_SERVICE_NAME,
				methodName: "Save",
				data: schema || {},
				timeout: this.REQUEST_TIMEOUT
			}, responseCallback, scope);
		},
		/**
		 * Загрузить данные схемы БП.
		 * @param {Object} scope Контекст выполнения функции
		 * @param {Guid} schemaUId идентификатор схемы процесса
		 * @param {Function} callback Функция обратного вызова
		 */
		loadProcessSchema: function(scope, schemaUId, callback) {
			MaskHelper.ShowBodyMask();
			var responseCallback = function(request, success, response) {
				MaskHelper.HideBodyMask();
				if (success && callback) {
					var data = Ext.decode(Ext.decode(response.responseText));
					callback.call(scope || this, data);
				}
			};
			this.callService({
				serviceName: this.PROCESS_SCHEMA_MANAGER_SERVICE_NAME,
				methodName: schemaUId + "/Load"
			}, responseCallback, scope);
		},
		/**
		 * Возвращает уникальное имя и заголовок схемы БП
		 * @private
		 */
		getUniqueNameAndCaption: function(callback, scope) {
			var responseCallback = function(request, success, response) {
				if (success) {
					var uniqueNameAndCaption = Ext.decode(Ext.decode(response.responseText));
					callback.call(scope || this, uniqueNameAndCaption);
				}
			};
			this.callService({
				serviceName: this.PROCESS_SCHEMA_MANAGER_SERVICE_NAME,
				methodName: "GetUniqueNameAndCaption"
			}, responseCallback, scope);
		},
		/**
		 * Запускает бизнес-процесс по идентификатору или по имени схемы процесса
		 * @param {String} sysProcessName Имя схемы процесса
		 * @param {String} sysProcessId Идентификатор схемы процесса
		 * @param {Object} parameters Параметры процесса
		 */
		executeProcess: function(args) {
			var sysProcessName = args.sysProcessName;
			var callback = this.responseCallback;
			if (!Ext.isEmpty(sysProcessName)) {
				this.runProcess(sysProcessName, args.parameters, callback, this);
				return;
			}
			var sysProcessId = args.sysProcessId;
			var scope = this;
			var esq = Ext.create("Terrasoft.EntitySchemaQuery", {
				rootSchemaName: "VwSysProcess"
			});
			esq.addColumn("Id", "Id");
			esq.addColumn("Name", "Name");
			esq.getEntity(sysProcessId, function(result) {
				if (!Ext.isEmpty(result.entity)) {
					var processName = result.entity.get("Name");
					this.runProcess(processName, args.parameters, callback, scope);
				}
			}, this);
		},
		/**
		 * Позволяет выполнить публикацию схем
		 * @param {Terrasoft.BaseSchemaViewModel} scope Контекст выполнения
		 */
		publish: function(scope) {
			MaskHelper.ShowBodyMask({
				caption: resources.localizableStrings.PublishMaskCaption
			});
			this.callService({
				serviceName: this.PROCESS_SCHEMA_MANAGER_SERVICE_NAME,
				methodName: "Publish",
				timeout: this.REQUEST_TIMEOUT
			}, this.responseCallback, scope || this);
		},
		/**
		 * Продолжает выполнение процесса.
		 * @param {String} processUId Уникальный идентификатор процесса.
		 * @param {Object} scope Контекст выполнения.
		 */
		continueExecuting: function(processUId, scope) {
			MaskHelper.ShowBodyMask();
			var callback = function() {
				MaskHelper.HideBodyMask();
			};
			this.callService({
				serviceName: this.PROCESS_ENGINE_SERVICE_NAME,
				methodName: processUId + "/ContinueExecuting",
				timeout: this.REQUEST_TIMEOUT
			}, callback, scope);
		},
		/**
		 * Отменяет выполнение всех запущенных экземпляров процессов по схеме
		 * @param {Object} scope Контекст выполнения функции
		 * @param {Guid} schemaId Идентификатор схемы в рабочем пространстве пользователя
		 * @param {Function} callback Функция обратного вызова
		 */
		cancelExecutionBySchemaId: function(scope, schemaId, callback) {
			MaskHelper.ShowBodyMask();
			var responseCallback = function(request, success, response) {
				MaskHelper.HideBodyMask();
				var responseObject = null;
				if (success) {
					responseObject = Ext.decode(Ext.decode(response.responseText));
					var message = responseObject.message;
					if (message) {
						Terrasoft.utils.showInformation(message);
					}
				}
				if (callback) {
					callback.call(scope, responseObject);
				}
			};
			this.callService({
				serviceName: this.PROCESS_ENGINE_SERVICE_NAME,
				methodName: "CancelExecutionBySchemaId?schemaId=" + schemaId,
				timeout: this.REQUEST_TIMEOUT
			}, responseCallback, scope);
		},
		/**
		 * Отображает маску
		 */
		showBodyMask: function() {
			MaskHelper.ShowBodyMask();
		},
		/**
		 * Удаляет маску
		 */
		hideBodyMask: function() {
			MaskHelper.HideBodyMask();
		},
		/**
		 * Запускает бизнес процесс.
		 * @param {Object} tag Параметры запуска процесса.
		 * @param {String} tag.name Название запускаемого процесса.
		 * @param {Object} tag.scope Контекст вызова.
		 * @param {Object} tag.parameters Параметры процесса.
		 * @param {Function} tag.callback  Функция обратного вызова.
		 */
		startBusinessProcess: function(tag) {
			var scope = tag.scope || this,
				parametersQueryString = "";
			if (!Ext.isEmpty(tag.parameters)) {
				parametersQueryString += "?";
				var isNotFirstParameter = false;
				Terrasoft.each(tag.parameters, function(value, name) {
					if (isNotFirstParameter) {
						parametersQueryString += "&";
					} else {
						isNotFirstParameter = true;
					}
					parametersQueryString += name + "=" + value;
				}, scope);
			}
			var responseCallback = function() {
			};
			var tagCallback = tag.callback;
			if (Ext.isFunction(tagCallback)) {
				responseCallback = function(request, success, response) {
					var completeExecutionData;
					var errorMessage = response.responseText;
					if (success) {
						if (response && response.responseXML && response.responseXML.firstChild) {
							var responseContent = response.responseXML.firstChild;
							var responseText = responseContent.textContent || responseContent.text || null;
							completeExecutionData = Ext.decode(responseText, true);
							if (!Ext.isEmpty(completeExecutionData)) {
								errorMessage = null;
							}
						}
					}
					if (!Ext.isEmpty(errorMessage)) {
						if (Ext.isDefined(Ext.global.console) && Ext.isFunction(Ext.global.console.error)) {
							var message = Ext.String.format(resources.localizableStrings.ErrorStartBusinessProcess,
								tag.name, errorMessage);
							Ext.global.console.error(message);
						}
					}
					tagCallback.call(scope, success, completeExecutionData);
				};
			}
			Terrasoft.AjaxProvider.request({
				url: Terrasoft.workspaceBaseUrl + "/ServiceModel/ProcessEngineService.svc/" +
				tag.name + "/Execute" + parametersQueryString,
				method: "POST",
				jsonData: {},
				scope: scope,
				callback: responseCallback
			});
		},

		/**
		 * Создает запрос, который вычитывает доступные процессы для запуска.
		 * @param {Array} filters Набор фильтров.
		 * @return {Terrasoft.EntitySchemaQuery} Объект запроса.
		 */
		createRunProcessSelect: function(filters) {
			var select = Ext.create("Terrasoft.EntitySchemaQuery", {
				rootSchemaName: "VwSysProcess"
			});
			var idColumnName = "Id";
			var captionColumnName = "Caption";
			select.addColumn(idColumnName);
			select.addColumn(captionColumnName);
			var vwSysProcessFilters = Terrasoft.createFilterGroup();
			vwSysProcessFilters.name = "vwSysProcessFiler";
			vwSysProcessFilters.logicalComparisonTypes = Terrasoft.LogicalOperatorType.AND;
			vwSysProcessFilters.addItem(Terrasoft.createColumnFilterWithParameter(
				Terrasoft.ComparisonType.EQUAL, "SysWorkspace",
				Terrasoft.SysValue.CURRENT_WORKSPACE.value));
			vwSysProcessFilters.addItem(Terrasoft.createColumnFilterWithParameter(
				Terrasoft.ComparisonType.EQUAL, "IsMaxVersion", true));
			if (filters) {
				Terrasoft.each(filters, function(filter) {
					vwSysProcessFilters.addItem(filter);
				}, this);
			}
			select.filters.add("availableProcesses", vwSysProcessFilters);
			return select;
		},
		/**
		 * Добавляет для выпадающего списка данные пакета Custom.
		 * @private
		 * @param {Object} rows Данные для выпадающего списка.
		 * @param {String} customPackageUId Идентификатор пакета Custom.
		 */
		addCustomPackage: function(rows, customPackageUId) {
			rows[customPackageUId] = {
				"UId": customPackageUId,
				"value": customPackageUId,
				"displayValue": resources.localizableStrings.CustomPackageName
			};
		},
		/**
		 * Добавляет в справочник SysPackage Custom пакет, если он еще не создан.
		 * @private
		 * @param {Terrasoft.Collection} list  Список пакетов.
		 * @param {Object} rows Данные для выпадающего списка.
		 * @param {Function} callback Функция обратного вызова.
		 * @param {Object} scope Контекст выполнения метода.
		 */
		tryAddCustomPackage: function(list, rows, callback, scope) {
			Terrasoft.SysSettings.querySysSettingsItem("CustomPackageUId",
				function(customPackageUId) {
					var guidEmpty = Terrasoft.GUID_EMPTY;
					customPackageUId = (customPackageUId && customPackageUId.value) ?
							customPackageUId.value : guidEmpty;
					if (!rows[customPackageUId] && !rows[guidEmpty]) {
						this.addCustomPackage(rows, guidEmpty);
					}
					callback.call(scope || this, list, rows);
				}, this);
		},
		/**
		 * Обработчик события подготовки данных для выпадающего списка пакетов
		 * @filter {Object} Фильры для подготовки данных
		 * @list {Terrasoft.Collection} Данные для выпадающего списка
		 * @public
		 */
		onPrepareSysPackageList: function(filter, list) {
			list.clear();
			var esq = Ext.create("Terrasoft.EntitySchemaQuery", {
				rootSchemaName: "SysPackage"
			});
			esq.addColumn("UId");
			esq.addColumn("Id");
			esq.addColumn("Name");
			esq.filters.add("SysWorkspace", Terrasoft.createColumnFilterWithParameter(
					Terrasoft.ComparisonType.EQUAL, "SysWorkspace",
					Terrasoft.SysValue.CURRENT_WORKSPACE.value));
			esq.filters.add("Maintainer", Terrasoft.createColumnFilterWithParameter(
					Terrasoft.ComparisonType.EQUAL, "Maintainer",
					Terrasoft.SysValue.CURRENT_MAINTAINER.value));
			esq.getEntityCollection(function(response) {
				var collection = response.collection;
				var rows = {};
				if (collection && collection.collection.length > 0) {
					Terrasoft.each(collection.collection.items, function(item) {
						var listValue = {
							UId: item.values.UId,
							value: item.values.Id,
							displayValue: item.values.Name
						};
						rows[item.values.UId] = listValue;
					}, this);
				}
				this.tryAddCustomPackage(list, rows, function(list, rows) {
					var sortedList = Ext.create("Terrasoft.Collection");
					sortedList.loadAll(rows);
					sortedList.sort("displayValue", Terrasoft.OrderDirection.ASC);
					list.loadAll(sortedList);
				}, this);
			}, this);
		},
		/**
		 * Получает список доступных результатов пользовательского действия
		 * @param {object} scope Контекст выполнения функции
		 * @param {object} processActivity Параметры пользовательского действия
		 * @param {Function} callback Функция обратного вызова
		 */
		getProcessActivityResultsLookupGridData: function(scope, processActivity, callback) {
			var responseCallback = function(request, success, response) {
				if (success) {
					var resultsLookupGridData = Ext.decode(Ext.decode(response.responseText));
					callback.call(scope || this, resultsLookupGridData);
				}
			};
			this.callService({
				serviceName: this.PROCESS_SCHEMA_MANAGER_SERVICE_NAME,
				methodName: "GetProcessActivityResultsLookupGridData",
				data: processActivity || {}
			}, responseCallback, scope || this);
		}
	});
	return Terrasoft.ProcessModuleUtilities;
});


				// Autogenerated Code for schema ProcessModuleUtilities (End)
// Autogenerated Code for schema ProcessModuleV2 (Start)
define('ProcessModuleV2Resources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={
	ElementNotFoundByUIdExceptionMessage: 'Элемент процесса с идентификатором \"{0}\" не найден'
};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("ProcessModuleV2", ["ext-base", "terrasoft", "sandbox", "ProcessModuleV2Resources",
		"ProcessModuleUtilities", "ProcessHelper", "MaskHelper"],
	function(Ext, Terrasoft, sandbox, resources, ProcessModuleUtilities, ProcessHelper, MaskHelper) {

		var processCardModuleName = "ProcessCardModuleV2";
		var isProcessModeRegExp = processCardModuleName + "/?";

		function init() {
			sandbox.subscribe("ProcessExecDataChanged", onProcessExecDataChanged);
			sandbox.subscribe("GetProcessExecData", onGetProcessExecData);
			sandbox.subscribe("GetProcessEntryPointsData", onGetProcessEntryPointsData);
			Terrasoft.ServerChannel.on(Terrasoft.EventName.ON_MESSAGE, onNextProcessElementReady, this);
		}

		function replaceHistoryState(currentState, newState) {
			sandbox.publish("ReplaceHistoryState", {
				stateObj: newState,
				pageTitle: null,
				hash: currentState.hash.historyState,
				silent: true
			});
		}

		function onNextProcessElementReady(scope, procExecDataMessage) {
			if (procExecDataMessage.Header.Sender === "ProcessEngine") {
				MaskHelper.HideBodyMask();
				var currentState = sandbox.publish("GetHistoryState");
				var isNew = Ext.isEmpty(currentState.hash.historyState.match(isProcessModeRegExp));
				var nextProcExecData = Ext.decode(procExecDataMessage.Body);
				var nextProcessId = nextProcExecData.processId;
				var processExecData = (currentState.state && currentState.state.executionData) || {};
				if (isNew === true ||
					Ext.isEmpty(processExecData.processId) || processExecData.processId === nextProcessId) {
					if (isNew === true) {
						processExecData = {};
					}
					processExecData = Ext.apply({}, processExecData, nextProcExecData);
					processExecData.isNew = isNew;
				} else {
					return;
				}
				changeNextProcExecDataHistoryState(processExecData);
			} else if (procExecDataMessage.Header.Sender === "ProcessEngineBackHistoryState") {
				Terrasoft.Router.back();
			}
		}

		function changeCurrentProcExecItemInHistoryState(processExecDataItem) {
			var currentState = sandbox.publish("GetHistoryState");
			var newState = Terrasoft.deepClone(currentState.state || {});
			newState.executionData.currentProcElUId = processExecDataItem.procElUId;
			changeHistoryState(processExecDataItem, currentState, newState);
		}

		function changeNextProcExecDataHistoryState(nextProcessExecData) {
			var currentState = sandbox.publish("GetHistoryState");
			var newState = Terrasoft.deepClone(currentState.state || {});
			var previousProcElUId = nextProcessExecData.currentProcElUId;
			var currentProcElUId;
			Terrasoft.each(nextProcessExecData, function(procExecDataItem) {
				if (currentProcElUId) {
					return;
				}
				if (procExecDataItem && (typeof procExecDataItem !== "function") &&
					procExecDataItem.procElUId !== previousProcElUId) {
					currentProcElUId = procExecDataItem.procElUId;
				}
			}, this);
			nextProcessExecData.currentProcElUId = currentProcElUId;
			delete nextProcessExecData[previousProcElUId];
			newState.executionData = nextProcessExecData;
			var processExecDataItem = nextProcessExecData[nextProcessExecData.currentProcElUId];
			changeHistoryState(processExecDataItem, currentState, newState);
		}

		function changeHistoryState(processExecDataItem, currentState, newState) {
			if (Ext.isEmpty(processExecDataItem)) {
				Terrasoft.Router.back();
				return;
			}
			var navigationEventName = "PushHistoryState";
			var historyState = currentState.hash.historyState;
			if (historyState.match(isProcessModeRegExp) || (processExecDataItem.isProcessExecutedBySignal === true) ||
					(newState.executionData.showNextPrcEl === false)) {
				navigationEventName = "ReplaceHistoryState";
			}
			var showNextPrcEl = newState.executionData.showNextPrcEl || !isInCardMode(currentState.state);
			showNextPrcEl = showNextPrcEl ||
				(newState.executionData.isNew === true) && (!processExecDataItem.isProcessExecutedBySignal);
			var token = historyState;
			if (showNextPrcEl) {
				if (processExecDataItem.urlToken) {
					token = processExecDataItem.urlToken;
				} else {
					var config = Terrasoft.configuration.ModuleStructure[processExecDataItem.entitySchemaName];
					var cardSchemaName = config.cardSchema;
					if (config.attribute) {
						processExecDataItem.typeColumnName = config.attribute;
					}
					Terrasoft.each(config.pages, function(page) {
						if (processExecDataItem.pageTypeId === page.UId && page.cardSchema) {
							cardSchemaName = page.cardSchema;
						}
					}, this);
					if (processExecDataItem.action === "add") {
						newState.valuePairs = getDefaultValues(processExecDataItem);
					}
					var recordId = processExecDataItem.recordId || processExecDataItem.activityRecordId;
					var action = processExecDataItem.action || "edit";
					token = processCardModuleName + "/" + cardSchemaName + "/" + action + "/" + recordId;
					newState.operation = action;
					newState.id = [
						processCardModuleName,
						cardSchemaName,
						processExecDataItem.procElUId
					].join("_");
				}
				token = token + "/" + processExecDataItem.procElUId;
			}
			newState.executionData.showNextPrcEl = false;
			newState.executionData.isOpened = showNextPrcEl;
			sandbox.publish(navigationEventName, {
				stateObj: newState,
				pageTitle: null,
				hash: token,
				silent: !showNextPrcEl
			});
		}

		function isInCardMode(state) {
			return !!state.operation;
		}

		function getDefaultValues(processExecDataItem) {
			var valuePairs = [];
			var recordId = processExecDataItem.recordId || processExecDataItem.activityRecordId;
			if (recordId) {
				valuePairs.push({
					name: "Id",
					value: recordId
				});
			}
			if (processExecDataItem.pageTypeId) {
				valuePairs.push({
					name: processExecDataItem.typeColumnName,
					value: processExecDataItem.pageTypeId
				});
			}
			var defaultValues = processExecDataItem.defaultValues;
			for (var propertyName in defaultValues) {
				if (!defaultValues.hasOwnProperty(propertyName)) {
					continue;
				}
				var propertyValue = defaultValues[propertyName];
				if (propertyValue) {
					var dataValueType = propertyValue.dataValueType;
					if (dataValueType && ProcessHelper.getIsDateTimeDataValueType(dataValueType)) {
						propertyValue = Terrasoft.parseDate(propertyValue.value);
					} else if (propertyValue.value) {
						propertyValue = propertyValue.value;
					}
				}
				valuePairs.push({
					name: propertyName,
					value: propertyValue
				});
			}
			return valuePairs;
		}

		function onCardModuleSaved(nextPrcElReady, cardModuleSandbox, showNextPrcEl) {
			var currentState = sandbox.publish("GetHistoryState");
			var state = currentState.state || {};
			if (Ext.isEmpty(state.executionData) || state.executionData.isOpened) {
				return false;
			}
			var newState = Terrasoft.deepClone(state);
			newState.showNextPrcEl = showNextPrcEl;
			var executionData = newState.executionData;
			executionData.showNextPrcEl = showNextPrcEl;
			if (nextPrcElReady === false && ProcessModuleUtilities.getProcExecDataCollectionCount(executionData) > 0) {
				var select = Ext.create("Terrasoft.EntitySchemaQuery", {
					rootSchemaName: "SysProcessData"
				});
				select.addColumn("Id");
				select.getEntity(executionData.processId, function(result) {
					var entity = result.entity;
					var currentState = sandbox.publish("GetHistoryState");
					var state = currentState.state || {};
					var executionData = state.executionData;
					executionData.showNextPrcEl = showNextPrcEl;
					if (entity && ProcessModuleUtilities.getProcExecDataCollectionCount(executionData) > 0) {
						changeNextProcExecDataHistoryState(executionData);
					} else {
						Terrasoft.Router.back();
					}
				}, this);
			} else if (nextPrcElReady === true) {
				changeHistoryState(executionData[executionData.currentProcElUId], currentState, newState);
			} else {
				return false;
			}
			return true;
		}

		function onProcessExecDataChanged(data) {
			getProcessExecData(this, data);
		}

		function onGetProcessEntryPointsData(dataSend) {
			callConfigurationServiceMethod("ProcessEngineService/GetProcessEntryPointsData",
				{
					entitySchemaUId: dataSend.entitySchemaUId,
					entityId: dataSend.recordId
				},
				function(response) {
					dataSend.callback.call(dataSend.scope, response.GetProcessEntryPointsDataResult);
				});
		}

		function onGetProcessExecData() {
			var currentState = sandbox.publish("GetHistoryState");
			var processExecData = (currentState.state && currentState.state.executionData) || {};
			return processExecData[processExecData.currentProcElUId];
		}

		function getProcessExecData(scope, data) {
			// TODO Переименовать метод сервиса GetExecutionData
			Terrasoft.AjaxProvider.request({
				url: "../ServiceModel/ProcessEngineService.svc/" +
					"GetExecutionData?ProcElUId=" + data.procElUId + "&RecordId=" + data.recordId,
				method: "POST",
				scope: scope,
				callback: function(request, success, response) {
					if (success) {
						var nextProcessExecData = Ext.decode(Ext.decode(response.responseText));
						if (nextProcessExecData.status) {
							if (nextProcessExecData.status === "404") {
								data.scope.showInformationDialog.call(data.scope, nextProcessExecData.message);
								return;
							}
							if (window.console && window.console.log) {
								var elementNotFoundMessage = resources.localizableStrings
									.ElementNotFoundByUIdExceptionMessage.replace("{0}", data.procElUId);
								window.console.log(elementNotFoundMessage);
							}
							if (data.parentMethod) {
								data.parentMethod.call(data.scope, data.parentMethodArguments);
							}
						} else {
							var processExecData = {
								processId: nextProcessExecData.processId,
								isNew: true
							};
							processExecData[data.procElUId] = nextProcessExecData;
							changeNextProcExecDataHistoryState(processExecData);
							if (data.callbackMethod) {
								data.callbackMethod.call(data.scope);
							}
						}
					}
				}
			});
		}

		function callConfigurationServiceMethod(serviceMethodName, dataSend, callback) {
			var data = dataSend || {};
			var requestUrl = Terrasoft.workspaceBaseUrl + "/rest/" + serviceMethodName;
			var request = Terrasoft.AjaxProvider.request({
				url: requestUrl,
				headers: {
					"Accept": "application/json",
					"Content-Type": "application/json"
				},
				method: "POST",
				jsonData: data,
				scope: this,
				callback: function(request, success, response) {
					if (!callback) {
						return;
					}
					var responseObject = {};
					if (success) {
						responseObject = Terrasoft.decode(response.responseText);
					}
					callback.call(this, responseObject);
				}
			});
			return request;
		}

		function completeExecution(scope, procElUId, params, callback) {
			MaskHelper.ShowBodyMask();
			var responseCallback = function() {
				MaskHelper.HideBodyMask();
			};
			if (callback) {
				responseCallback = function(request, success, response) {
					MaskHelper.HideBodyMask();
					var completeExecutionData = Ext.decode(Ext.decode(response.responseText));
					callback.call(scope || this, success, completeExecutionData);
				};
			}
			Terrasoft.AjaxProvider.request({
				url: "../ServiceModel/ProcessEngineService.svc/" + procElUId +
					"/CompleteExecution" + (params || ""),
				method: "POST",
				scope: this,
				callback: responseCallback
			});
		}

		function cancelExecution(scope, data, callback) {
			scope = scope || this;
			Terrasoft.AjaxProvider.request({
				url: "../ServiceModel/ProcessEngineService.svc/CancelExecution",
				headers: {
					"Accept": "application/json",
					"Content-Type": "application/json"
				},
				method: "POST",
				scope: this,
				jsonData: data,
				callback: function(request, success, response) {
					if (!callback) {
						return;
					}
					callback.call(scope, request, success, response);
				}
			});
		}

		var services = {
			completeExecution: completeExecution,
			cancelExecution: cancelExecution,
			callConfigurationServiceMethod: callConfigurationServiceMethod
		};

		function postponeProcessExecution() {
			var currentState = sandbox.publish("GetHistoryState");
			var newState = Terrasoft.deepClone(currentState.state || {});
			var executionData = newState.executionData;
			delete executionData[executionData.currentProcElUId];
			delete executionData.currentProcElUId;
			replaceHistoryState(currentState, newState);
			if (ProcessModuleUtilities.getProcExecDataCollectionCount(executionData) > 0) {
				changeNextProcExecDataHistoryState(executionData);
			} else {
				Terrasoft.Router.back();
			}
		}


		return {
			init: init,
			replaceHistoryState: replaceHistoryState,
			changeNextProcExecDataHistoryState: changeNextProcExecDataHistoryState,
			changeCurrentProcExecItemInHistoryState: changeCurrentProcExecItemInHistoryState,
			onCardModuleSaved: onCardModuleSaved,
			services: services,
			postponeProcessExecution: postponeProcessExecution
		};
	});

				// Autogenerated Code for schema ProcessModuleV2 (End)
// Autogenerated Code for schema SearchEdit (Start)
define('SearchEditResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
/**
 * @class Terrasoft.controls.SearchEdit
 * Класс элемента управления ввода текста в однострочное поле с задержкой ввода значения перед поиском.
 */
Ext.define("Terrasoft.controls.SearchEdit", {
	extend: "Terrasoft.TextEdit",
	alternateClassName: "Terrasoft.SearchEdit",

	/**
	 * Идентификатор таймера задержки перед фильтрацией.
	 * @private
	 * @type {Number}
	 */
	timerId: 0,

	/**
	 * Задержка перед фильтрацией.
	 * Количество миллисекунд между вводом пользователем значения фильтра в элемент и началом фильтрации.
	 * @type {Number}
	 */
	searchDelay: 1000,

	/**
	 * Уничтожает таймер по его имени.
	 * @private
	 * @param {String} timerName Имя таймера.
	 */
	clearTimer: function(timerName) {
		if (this[timerName] !== null) {
			clearTimeout(this[timerName]);
			this[timerName] = null;
		}
	},

	/**
	 * Инициализирует элемент управления.
	 * @protected
	 * @overridden
	 */
	init: function() {
		this.callParent(arguments);
		this.addEvents(
			/**
			 * @event searchValueChanged
			 * Срабатывает, когда происходит изменение значения поиска.
			 */
			"searchValueChanged"
		);
	},

	/**
	 * Обработчик события клавиша отжата. Делает паузу {@link Terrasoft.SearchEdit#searchDelay}, после чего генерирует
	 * событие {@link Terrasoft.SearchEdit#searchValueChanged}.
	 * @param {Ext.EventObjectImpl} e Объект события.
	 * @protected
	 * @overridden
	 */
	onKeyUp: function(e) {
		this.callParent(arguments);
		this.clearTimer("timerId");
		if (!this.enabled || this.readonly) {
			return;
		}
		var value = this.getTypedValue();
		if (!e.isNavKeyPress()) {
			this.timerId = Ext.defer(function() {
				this.fireEvent("searchValueChanged", value, this);
			}, this.searchDelay, this);
		}
	}
});


				// Autogenerated Code for schema SearchEdit (End)
// Autogenerated Code for schema IdentifiedSubscriberItem (Start)
define('IdentifiedSubscriberItemResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={
	'AccountIdentifiedPhoto': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'IdentifiedSubscriberItem', resourceItemName: 'AccountIdentifiedPhoto' }},
	'ContactEmptyPhotoWhite': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'IdentifiedSubscriberItem', resourceItemName: 'ContactEmptyPhotoWhite' }}
};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define('IdentifiedSubscriberItemStructure', ['IdentifiedSubscriberItemResources'], function(resources) {return {schemaUId:'b8157ec5-37dd-42bf-9865-c300534f417e',schemaCaption: 'Схема идентифицированного абонента', parentSchemaName: '', schemaName:'IdentifiedSubscriberItem',parentSchemaUId:'',extendParent:false,type:Terrasoft.SchemaType.GRID_DETAIL_VIEW_MODEL_SCHEMA,entitySchema:'',name:'',extend:'Terrasoft.model.BaseViewModel',schema:{leftPanel:[],rightPanel:[],actions:[],analytics:[]},methods:{},controlsConfig:{},customBindings:{},bindings:{},schemaDifferences:function(){

}};});
define("IdentifiedSubscriberItem", ["terrasoft", "CtiConstants"],
	function(Terrasoft, CtiConstants) {
		return {
			attributes: {

				/**
				 * Идентификатор абонента.
				 */
				"Id": {
					"dataValueType": Terrasoft.DataValueType.TEXT,
					"type": Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
					"value": ""
				},

				/**
				 * Тип абонента.
				 */
				"Type": {
					"dataValueType": Terrasoft.DataValueType.TEXT,
					"type": Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
					"value": ""
				},

				/**
				 * Имя абонента.
				 */
				"Name": {
					"dataValueType": Terrasoft.DataValueType.TEXT,
					"type": Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
					"value": ""
				},

				/**
				 * Идентификатор фото абонента.
				 */
				"Photo": {
					"dataValueType": Terrasoft.DataValueType.TEXT,
					"type": Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
					"value": ""
				},

				/**
				 * Департамент абонента.
				 */
				"Department": {
					"dataValueType": Terrasoft.DataValueType.TEXT,
					"type": Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
					"value": ""
				},

				/**
				 * Контрагент абонента.
				 */
				"AccountName": {
					"dataValueType": Terrasoft.DataValueType.TEXT,
					"type": Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
					"value": ""
				},

				/**
				 * Должность абонента.
				 */
				"Job": {
					"dataValueType": Terrasoft.DataValueType.TEXT,
					"type": Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
					"value": ""
				},

				/**
				 * Тип контрагента, когда абонент идентифицирован как контрагент.
				 */
				"AccountType": {
					"dataValueType": Terrasoft.DataValueType.TEXT,
					"type": Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
					"value": ""
				},

				/**
				 * Город абонента.
				 */
				"City": {
					"dataValueType": Terrasoft.DataValueType.TEXT,
					"type": Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
					"value": ""
				},

				/**
				 * Тип средства связи.
				 */
				"CommunicationType": {
					"dataValueType": Terrasoft.DataValueType.TEXT,
					"type": Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
					"value": ""
				},

				/**
				 * Номер, по которому удалось найти абонента.
				 */
				"Number": {
					"dataValueType": Terrasoft.DataValueType.TEXT,
					"type": Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
					"value": ""
				},

				/**
				 * Отображаемые данные по идентифицированному абоненту, в зависимости от его типа.
				 * Ключ - тип абонента, значение - массив имен полей данных идентификации, которые следует отобразить.
				 * @private
				 * @type {Object}
				 */
				"SubscriberColumnsByType": {
					"dataValueType": Terrasoft.DataValueType.CUSTOM_OBJECT,
					"value": {
						"Contact": ["AccountName", "Job"],
						"Account": ["AccountType", "City"],
						"Employee": ["Department"]
					}
				}
			},
			methods: {

				/**
				 * Возвращает конфигурацию изображения с фото абонента или иконкой контрагента.
				 * @private
				 * @returns {Object} Конфигурация изображения.
				 */
				getPhoto: function() {
					var subscriberType = this.get("Type");
					var photoId = this.get("Photo");
					if (subscriberType === CtiConstants.SubscriberTypes.Account) {
						return this.get("Resources.Images.AccountIdentifiedPhoto");
					}
					if (Ext.isEmpty(photoId) || this.Terrasoft.isEmptyGUID(photoId)) {
						return this.get("Resources.Images.ContactEmptyPhotoWhite");
					}
					var photoConfig =  {
						source: this.Terrasoft.ImageSources.ENTITY_COLUMN,
						params: {
							schemaName: "SysImage",
							columnName: "Data",
							primaryColumnValue: photoId
						}
					};
					return  {
						source: Terrasoft.ImageSources.URL,
						url: Terrasoft.ImageUrlBuilder.getUrl(photoConfig)
					};
				},

				/**
				 * Определяет, являются ли данные идентификации видимые по тэгу элемента управления.
				 * @param {String} tag Тэг отображаемого элемента.
				 * @returns {Boolean} Видимость данных.
				 */
				getIsInfoLabelVisible: function(tag) {
					var type = this.get("Type");
					var subscriberColumnsByType = this.get("SubscriberColumnsByType");
					var subscriberColumns = subscriberColumnsByType[type];
					if (Ext.isEmpty(subscriberColumns) || (subscriberColumns.indexOf(tag) === -1)) {
						return false;
					}
					var infoLabelValue = this.get(tag);
					return !Ext.isEmpty(infoLabelValue);
				}
			},
			diff: [
				{
					"operation": "insert",
					"name": "IdentifiedSubscriberItemContainer",
					"values": {
						"id": "IdentifiedSubscriberItemContainer",
						"selectors": {
							"wrapEl": "#IdentifiedSubscriberItemContainer"
						},
						"itemType": Terrasoft.ViewItemType.CONTAINER,
						"wrapClass": ["identified-subscriber-item-container"],
						"markerValue": {"bindTo": "Name"},
						"items": []
					}
				},
				{
					"operation": "insert",
					"name": "Photo",
					"parentName": "IdentifiedSubscriberItemContainer",
					"propertyName": "items",
					"values": {
						"itemType": Terrasoft.ViewItemType.BUTTON,
						"imageConfig": {"bindTo": "getPhoto"},
						"classes": {"wrapperClass": ["subscriber-photo"]},
						"markerValue": "Photo",
						"style": Terrasoft.controls.ButtonEnums.style.TRANSPARENT
					}
				},
				{
					"operation": "insert",
					"name": "SubscriberDataContainer",
					"parentName": "IdentifiedSubscriberItemContainer",
					"propertyName": "items",
					"values": {
						"itemType": Terrasoft.ViewItemType.CONTAINER,
						"wrapClass": ["subscriber-data-container"],
						"items": []
					}
				},
				{
					"operation": "insert",
					"name": "Name",
					"parentName": "SubscriberDataContainer",
					"propertyName": "items",
					"values": {
						"itemType": Terrasoft.ViewItemType.LABEL,
						"classes": {"labelClass": ["subscriber-name"]},
						"markerValue": {"bindTo": "Name"},
						"caption": {"bindTo": "Name"},
						"hint": {"bindTo": "Name"}
					}
				},
				{
					"operation": "insert",
					"name": "AccountName",
					"parentName": "SubscriberDataContainer",
					"propertyName": "items",
					"values": {
						"itemType": Terrasoft.ViewItemType.LABEL,
						"classes": {"labelClass": ["subscriber-data"]},
						"markerValue": {"bindTo": "AccountName"},
						"caption": {"bindTo": "AccountName"},
						"visible": {"bindTo": "getIsInfoLabelVisible"},
						"hint": {"bindTo": "AccountName"},
						"tag": "AccountName"
					}
				},
				{
					"operation": "insert",
					"name": "Department",
					"parentName": "SubscriberDataContainer",
					"propertyName": "items",
					"values": {
						"itemType": Terrasoft.ViewItemType.LABEL,
						"classes": {"labelClass": ["subscriber-data"]},
						"markerValue": {"bindTo": "Department"},
						"caption": {"bindTo": "Department"},
						"visible": {"bindTo": "getIsInfoLabelVisible"},
						"hint": {"bindTo": "Department"},
						"tag": "Department"
					}
				},
				{
					"operation": "insert",
					"name": "Job",
					"parentName": "SubscriberDataContainer",
					"propertyName": "items",
					"values": {
						"itemType": Terrasoft.ViewItemType.LABEL,
						"classes": {"labelClass": ["subscriber-data"]},
						"markerValue": {"bindTo": "Job"},
						"caption": {"bindTo": "Job"},
						"visible": {"bindTo": "getIsInfoLabelVisible"},
						"hint": {"bindTo": "Job"},
						"tag": "Job"
					}
				},
				{
					"operation": "insert",
					"name": "AccountType",
					"parentName": "SubscriberDataContainer",
					"propertyName": "items",
					"values": {
						"itemType": Terrasoft.ViewItemType.LABEL,
						"classes": {"labelClass": ["subscriber-data"]},
						"markerValue": {"bindTo": "AccountType"},
						"caption": {"bindTo": "AccountType"},
						"visible": {"bindTo": "getIsInfoLabelVisible"},
						"hint": {"bindTo": "AccountType"},
						"tag": "AccountType"
					}
				},
				{
					"operation": "insert",
					"name": "City",
					"parentName": "SubscriberDataContainer",
					"propertyName": "items",
					"values": {
						"itemType": Terrasoft.ViewItemType.LABEL,
						"classes": {"labelClass": ["subscriber-data"]},
						"markerValue": {"bindTo": "City"},
						"caption": {"bindTo": "City"},
						"visible": {"bindTo": "getIsInfoLabelVisible"},
						"hint": {"bindTo": "City"},
						"tag": "City"
					}
				},
				{
					"operation": "insert",
					"name": "NumberContainer",
					"parentName": "IdentifiedSubscriberItemContainer",
					"propertyName": "items",
					"values": {
						"itemType": Terrasoft.ViewItemType.CONTAINER,
						"wrapClass": ["subscriber-number-container"],
						"items": []
					}
				},
				{
					"operation": "insert",
					"name": "CommunicationType",
					"parentName": "NumberContainer",
					"propertyName": "items",
					"values": {
						"itemType": Terrasoft.ViewItemType.LABEL,
						"classes": {"labelClass": ["subscriber-communication-type-name"]},
						"markerValue": {"bindTo": "CommunicationType"},
						"caption": {"bindTo": "CommunicationType"},
						"hint": {"bindTo": "CommunicationType"}
					}
				},
				{
					"operation": "insert",
					"name": "Number",
					"parentName": "NumberContainer",
					"propertyName": "items",
					"values": {
						"itemType": Terrasoft.ViewItemType.LABEL,
						"classes": {"labelClass": ["subscriber-number"]},
						"markerValue": {"bindTo": "Number"},
						"caption": {"bindTo": "Number"},
						"hint": {"bindTo": "Number"}
					}
				}
			]
		};
	});


				// Autogenerated Code for schema IdentifiedSubscriberItem (End)
// Autogenerated Code for schema CtiContainerListGenerator (Start)
define('CtiContainerListGeneratorResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("CtiContainerListGenerator", ["ext-base", "terrasoft", "DesignViewGeneratorV2", "CtiContainerList"],
	function(Ext, Terrasoft) {
		var viewGenerator = Ext.define("Terrasoft.configuration.CtiContainerListGenerator", {
			extend: "Terrasoft.ViewGenerator",
			alternateClassName: "Terrasoft.CtiContainerListGenerator",

			/**
			 * Генерирует конфигурацию представления для {Terrasoft.CtiContainerList}.
			 * @protected
			 * @virtual
			 * @param {Object} config Описание элемента представления.
			 * @return {Object} Возвращает сгенерированное представление CtiContainerList.
			 */
			generateGrid: function(config) {
				var id = this.getControlId(config, "Terrasoft.Grid");
				var itemConfig = {
					itemType: Terrasoft.ViewItemType.CONTAINER,
					name: "row-container",
					items: config.itemConfig
				};
				this.generateItem(itemConfig);
				var result = {
					className: "Terrasoft.CtiContainerList",
					id: id,
					selectors: { wrapEl: "#" + id }
				};
				Ext.apply(result, this.getConfigWithoutServiceProperties(config, ["itemConfig"]));
				this.applyControlConfig(result, config);
				return result;
			}
		});

		return Ext.create(viewGenerator);
	});

				// Autogenerated Code for schema CtiContainerListGenerator (End)
// Autogenerated Code for schema ContainerList (Start)
define('ContainerListResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
/**
 * Класс реализует отображение коллекции элементов по конфигу контейнера.
 */
Ext.define("Terrasoft.controls.ContainerList", {
	extend: "Terrasoft.Container",
	alternateClassName: "Terrasoft.ContainerList",

	/**
	 * Флаг, указывающий, асинхронно ли загружается коллекция.
	 */
	isAsync: true,

	/**
	 * Ссылка на коллекцию элементов
	 * @type {Terrasoft.Collection}
	 */
	collection: null,

	/**
	 * Имя свойства, которое является идентификатором
	 * @type {String}
	 */
	idProperty: null,

	/**
	 * CSS класс контейнера элемента
	 * @type {String}
	 */
	selectableRowCss: "selectable",

	/**
	 * Массив идентификаторов элементов, для которых уже было сгенерировано событие попадания в видимую часть
	 * @protected
	 * @type {Array}
	 */
	observableRowHistory: [],

	/**
	 * Конфигурация представления элемента по умолчанию
	 *		defaultItemConfig: {
	 *			className: "Terrasoft.Container",
	 *			id: "item",
	 *			selectors: {
	 *				wrapEl: "#item"
	 *			},
	 *			classes: {
	 *				wrapClassName: ["post-class"]
	 *			},
	 *			items:[
	 *				{
	 *					className: "Terrasoft.Label",
	 *					caption: {
	 *						bindTo: "CreatedByName"
	 *					},
	 *					classes: {
	 *						labelClass: ["createdBy-name"]
	 *					}
	 *				},
	 *				{
	 *					className: "Terrasoft.Label",
	 *					caption: {
	 *						bindTo: "CreatedOn"
	 *					},
	 *					classes: {
	 *						labelClass: ["createdBy-date", "unimportant-color"]
	 *					}
	 *				}
	 *			]
	 *		}
	 * @protected
	 * @type {Object}
	 */
	defaultItemConfig: null,

	/**
	 * Функция, возвращающая конфигурацию представления элемента, отличную от конфигурации по умолчанию
	 * @protected
	 * @type {Function}
	 */
	getCustomItemConfig: null,

	/**
	 * Порядковый номер строки реестра с конца, появление которого в видимой части браузера нужно отслеживать
	 */
	observableRowNumber: 0,

	/**
	 *
	 */
	stillRendering: false,

	/**
	 *
	 */
	delayedObservableRowId: null,

	/**
	 * CSS селектор записи элемента управления
	 */
	rowCssSelector: ".esn-notification-container.selectable",

	/**
	 * Префикс для DOM идентификатора записи
	 */
	dataItemIdPrefix: "esn-notification-item",

	/**
	 * CSS класс выбранной записи
	 */
	selectedItemCssClass: "selected",

	/**
	 * Значение идентификатора активной записи списка
	 */
	activeItem: null,

	/**
	 * Коллекция с идентификаторами моделей представлений, в качестве ключей используется идентификаторы представлений.
	 * @type {Terrasoft.Collection}
	 */
	rowIds: null,

	/**
	 * Уникальный префикс для изменения идентификаторов представлений. Если свойство не определено,
	 * используется свойство sandbox.id модели представления.
	 * @type {String}
	 */
	itemPrefix: null,

	/**
	 * Указывает на наличие записей в списке.
	 * @protected
	 * @type {Boolean}
	 */
	isEmpty: false,

	/**
	 * @inheritDoc Terrasoft.Component#init
	 * @protected
	 */
	init: function() {
		this.callParent(arguments);
		this.rowIds = Ext.create("Terrasoft.Collection");
		this.addEvents(
			/**
			 * @event
			 * Событие появления отслеживаемой строки в видимой части
			 */
			"observableRowVisible",
			/**
			 * @event
			 * Событие получения конфигурации для элемента
			 */
			"onGetItemConfig",
			/**
			 * @event
			 * Событие клика по элементу списка
			 */
			"onItemClick",
			/**
			 * @event
			 * Событие проверки наличия конфигурации для пользовательского сообщения о пустом списке.
			 */
			"getEmptyMessageConfig"
		);
	},

	/**
	 * Выполнить привязку всех элементов к модели
	 * @param {Terrasoft.data.modules.BaseViewModel} model Модель данных
	 */
	bind: function(model) {
		this.mixins.bindable.bind.call(this, model);
	},

	/**
	 * Возвращает конфигурацию привязки к модели. Реализует интерфейс миксина {@link Terrasoft.Bindable}.
	 * @protected
	 * @overridden
	 */
	getBindConfig: function() {
		var bindConfig = this.callParent(arguments);
		var gridBindConfig = {
			collection: {
				changeMethod: "onCollectionDataLoaded"
			},
			isAsync: {
				changeMethod: "setIsAsync"
			},
			activeItem: {
				changeMethod: "scrollToItem"
			},
			isEmpty: {
				changeMethod: "setIsEmpty"
			}
		};
		return Ext.apply(gridBindConfig, bindConfig);
	},

	/**
	 * @inheritDoc Terrasoft.Component#initDomEvents
	 * @protected
	 * @overridden
	 */
	initDomEvents: function() {
		this.callParent(arguments);
		this.debounceWindowScroll = this.debounceWindowScroll || Terrasoft.debounce(this.onWindowScroll, 10);
		Ext.EventManager.addListener(window, "scroll", this.debounceWindowScroll, this);
		if (Ext.isIE9 || Ext.isChrome || Ext.isSafari || Ext.isOpera) {
			Ext.EventManager.addListener(window, "mousewheel", this.debounceWindowScroll, this);
		} else if (Ext.isGecko) {
			Ext.EventManager.addListener(window, "DOMMouseScroll", this.debounceWindowScroll, this);
		} else {
			Ext.EventManager.addListener(window, "onmousewheel", this.debounceWindowScroll, this);
		}
		var wrapEl = this.getWrapEl();
		if (wrapEl) {
			wrapEl.on("click", this.onClick, this);
		}
	},

	/**
	 * Обрабатывает событие click на элементе управления
	 * @param {Object} event объект события
	 */
	onClick: function(event) {
		var wrapEl = this.getWrapEl();
		var targetEl = Ext.get(event.target);
		var listItemEl = targetEl.findParent(this.rowCssSelector, wrapEl, true);
		if (Ext.isEmpty(listItemEl)) {
			return;
		}
		event.stopEvent();
		var itemId = this.rowIds.get(listItemEl.id);
		this.onItemClick(itemId);
		this.fireEvent("onItemClick", itemId);
	},

	/**
	 * Обрабатывает click на записи элемента управления.
	 * @param {String} itemId Идентификатор записи в коллекции.
	 */
	onItemClick: function(itemId) {
		this.setItemSelected(itemId);
	},

	/**
	 * Обрабатывает смену состояния записи элемента управления.
	 * @param {String} itemId Идентификатор записи в коллекции.
	 * @param {Boolean} status Состояние записи.
	 */
	setItemSelected: function(itemId) {
		var wrapEl = this.getWrapEl();
		if (!wrapEl) {
			return;
		}
		var markerValue = this.dataItemIdPrefix + "-" + itemId;
		var itemElSelection = wrapEl.select("[data-item-marker='" + markerValue + "']");
		var itemEl = itemElSelection.first();
		if (Ext.isEmpty(itemEl)) {
			return;
		}
		var selectedItemCssClass = this.selectedItemCssClass;
		var prevSelectedItemSelection = wrapEl.select(this.rowCssSelector + "." + selectedItemCssClass);
		var prevSelectedItemEl = prevSelectedItemSelection.first();
		if (!Ext.isEmpty(prevSelectedItemEl)) {
			prevSelectedItemEl.removeCls(selectedItemCssClass);
		}
		if (!itemEl.hasCls(selectedItemCssClass)) {
			itemEl.addCls(selectedItemCssClass);
		}
	},

	/**
	 * Обработчик события скролинга окна браузера.
	 * @protected
	 */
	onWindowScroll: function() {
		if (this.observableRowNumber > 0) {
			this.checkObservableRow();
		}
	},

	/**
	 * Метод получения ссылок на все строки реестра в DOM
	 * @returns {Array|selectableRows}
	 */
	getDomRows: function() {
		var root = null;
		var wrapEl = this.getWrapEl();
		if (wrapEl && wrapEl.dom) {
			root = wrapEl.dom;
		}
		if ((!this.selectableRows || !this.selectableRows.length) && root) {
			this.selectableRows =
				Ext.dom.Query.select("[class*=\"" + this.selectableRowCss + "\"]", root);
		}
		return this.selectableRows;
	},

	/**
	 * Получает ссылку на елемент записи списка в DOM.
	 * @private
	 * @param {String} id Идентификатор записи списка.
	 * @return {Object} Возвращает елемент записи списка в DOM.
	 */
	getDomItem: function(id) {
		if (!this.rendered || !id) {
			return null;
		}
		var wrapEl = this.getWrapEl();
		var root = (wrapEl && wrapEl.dom) ? wrapEl.dom : null;
		if (root) {
			return Ext.dom.Query.select("> [class*=" + id + "]", root)[0];
		}
		return null;
	},

	/**
	 * Позиционирует активную запись в видимой области окна браузера.
	 * @private
	 * @param {String} value Идентификатор записи списка.
	 */
	scrollToItem: function(value) {
		if (this.activeItem === value) {
			return;
		}
		var activeItem = this.activeItem = value;
		if (activeItem) {
			var activeItemDom = this.getDomItem(activeItem);
			if (activeItemDom) {
				if (activeItemDom.scrollIntoViewIfNeeded) {
					activeItemDom.scrollIntoViewIfNeeded(false);
				} else {
					activeItemDom.scrollIntoView(false);
				}
			}
		}
	},

	/**
	 * Устанавливает значение свойства указывающего, асинхронно ли загружается коллекция.
	 * @private
	 * @param {Boolean} value Значение свойства.
	 */
	setIsAsync: function(value) {
		if (this.isAsync === value) {
			return;
		}
		this.isAsync = value;
	},

	/**
	 * Проверка на видимости отслеживаемого элемента в видимой части окна браузера
	 * @protected
	 */
	checkObservableRow: function() {
		var rows = this.getDomRows();
		if (!rows || !rows.length) {
			return;
		}
		var observableRowNumber = rows.length - this.observableRowNumber;
		if (observableRowNumber < 0) {
			return;
		}
		var observableRow = Ext.get(rows[observableRowNumber]);
		var observableRowId = observableRow.dom.id;
		if (this.isElementVisible(observableRow)) {
			if (Ext.Array.indexOf(this.observableRowHistory, observableRowId) >= 0) {
				return;
			}
			this.observableRowHistory.push(observableRowId);
			if (this.stillRendering) {
				this.delayedObservableRowId = observableRowId;
			} else {
				this.fireEvent("observableRowVisible", observableRowId);
			}
		}
	},

	/**
	 * Проверка видимость элемента в видимой части окна браузера
	 * @returns {boolean}
	 */
	isElementVisible: function(el) {
		if (!el) {
			return false;
		}
		var body = Ext.getBody();
		var bodyViewRegion = body.getViewRegion();
		var elViewRegion = el.getViewRegion();
		return (elViewRegion.x <= bodyViewRegion.right &&
				elViewRegion.y <= bodyViewRegion.bottom);
	},

	/**
	 * Создание представления элементов, и добавление их в контейнер
	 * @protected
	 */
	addItems: function(items, index) {
		this.observableRowHistory = [];
		this.selectableRows = null;

//		алгоритм:
//			1. запоминаем состояние рендеринга и отключаем его;
//			2. генерируем представления элементов и добавляем их в текущий контейнер;
//			3. возвращаем состояние рендеринга;
//			4. если был отрендерен - асинхронно

		var rendered = this.rendered;
		this.rendered = false;
		this.stillRendering = true;
		var rowIds = this.rowIds;
		var views = [];
		for (var i = 0; i < items.length; i++) {
			var item = items[i];
			var id = item.get(this.idProperty);
			var view = this.getItemView(item);
			view.bind(item);
			views.push(view);
			rowIds.add(view.id, id);
		}
		if (Ext.isEmpty(index)) {
			this.add(views);
		} else {
			this.insert(views, index);
		}
		this.rendered = rendered;
		var me = this;
		if (this.rendered) {
			var renderIndex = this.indexOf(views[0]);
			var renderView = function(view, index) {
				if (view.rendered) {
					return;
				}
				var renderEl = me.getRenderToEl();
				view.render(renderEl, index);
			};
			if (views.length === 1) {
				renderView(views[0], renderIndex);
			} else {
				var viewIndex = 0;
				var renderNext = function() {
					if (viewIndex < views.length) {
						var renderNextView = function() {
							renderView(views[viewIndex], renderIndex + viewIndex);
							viewIndex++;
							renderNext();
						};
						if (me.isAsync) {
							setTimeout(renderNextView, 0);
						} else {
							renderNextView();
						}
					} else {
						me.stillRendering = false;
						if (me.delayedObservableRowId) {
							var delayedObservableRowId = me.delayedObservableRowId;
							me.delayedObservableRowId = null;
							me.fireEvent("observableRowVisible", delayedObservableRowId);
						}
					}
				};
				renderNext();
			}
		}
	},

	/**
	 * Декорирование вложенных контейнеров, добаление идентификатора
	 * @protected
	 */
	decorateView: function(items, id, prefix) {
		var itemSuffix = "-" + id + "-" + prefix;
		Terrasoft.each(items, function(item) {
			if (item.id) {
				item.id += itemSuffix;
			}
			if (item.inputId) {
				item.inputId += itemSuffix + "-el";
			}
			if (!item.markerValue) {
				item.markerValue = this.dataItemIdPrefix + "-" + id;
			}
			var innerItem = item.item;
			if (innerItem && innerItem.id) {
				innerItem.id += itemSuffix;
			}
			var selectors = item.selectors;
			if (selectors && selectors.wrapEl) {
				selectors.wrapEl += itemSuffix;
			}
			var innerItemSelectors = innerItem && innerItem.selectors;
			if (innerItemSelectors && innerItemSelectors.wrapEl) {
				innerItemSelectors.wrapEl += itemSuffix;
			}
			var classes = item.classes;
			if (classes) {
				classes.wrapClassName = classes.wrapClassName || [];
				if (item.id) {
					classes.wrapClassName.push(item.id);
				}
			}
			if (item.items) {
				this.decorateView(item.items, id, prefix);
			}
		}, this);
	},

	/**
	 * Создание представления элемента
	 * @protected
	 */
	getItemView: function(item) {
		var prefix = this.itemPrefix || item.sandbox.id;
		var itemConfig = this.defaultItemConfig;
		var itemCfg = {};
		this.fireEvent("onGetItemConfig", itemCfg, item);
		if (itemCfg.config) {
			itemConfig = itemCfg.config;
			this.defaultItemConfig = itemCfg.config;
		}
		if (Ext.isFunction(this.getCustomItemConfig)) {
			itemConfig = this.getCustomItemConfig(item) || itemConfig;
		}
		var id = item.get(this.idProperty);
		itemConfig = Terrasoft.deepClone(itemConfig);
		var classes = itemConfig.classes || {};
		classes.wrapClassName = classes.wrapClassName || [];
		classes.wrapClassName.push(this.selectableRowCss);
		itemConfig.classes = classes;
		this.decorateView([itemConfig], id, prefix);
		var className = itemConfig && itemConfig.className ? itemConfig.className : "Terrasoft.Container";
		return Ext.create(className, itemConfig);
	},

	/**
	 * Формирует уникальный идентификатор элемента интерфейса.
	 * @protected
	 * @param {Object} item Элемент коллекции панелей.
	 * @returns {String} Уникальный идентификатор элемента интерфейса.
	 */
	getItemElementId: function(item) {
		var id = item.get(this.idProperty);
		var prefix = this.itemPrefix || item.sandbox.id;
		return this.defaultItemConfig.id + "-" + id + "-" + prefix;
	},

	/**
	 * Обработчик события "dataLoaded" коллекции Terrasoft.Collection
	 * @protected
	 * @param {Terrasoft.Collection} items
	 * @param {Terrasoft.Collection} newItems
	 */
	onCollectionDataLoaded: function(items, newItems) {
		this.observableRowHistory = [];
		this.selectableRows = null;
		items = newItems || items;
		if (items && items.getCount() > 0) {
			this.setIsEmpty(false);
			this.addItems(items.getItems());
		}
	},

	/**
	 * Обработчик события "add" коллекции Terrasoft.Collection
	 * @protected
	 * @param {Terrasoft.BaseViewModel} item Элемент коллекции
	 */
	onAddItem: function(item, index) {
		this.observableRowHistory = [];
		this.selectableRows = null;
		this.setIsEmpty(false);
		this.addItems([item], index);
	},

	/**
	 * Обработчик события "remove" коллекции Terrasoft.Collection
	 * @protected
	 * @param {Object} item
	 */
	onDeleteItem: function(item) {
		this.selectableRows = null;
		this.observableRowHistory = [];
		var elementId = this.getItemElementId(item);
		var itemId = item.get(this.idProperty);
		var element = this.items.getByKey(elementId);
		this.rowIds.remove(itemId);
		element.destroy();
		var items = this.items;
		var isEmpty = (items.getCount() === 0);
		this.setIsEmpty(isEmpty);
		if (this.observableRowNumber > 0) {
			this.checkObservableRow();
		}
	},

	/**
	 * Метод очистки контейнера.
	 */
	clear: function() {
		this.observableRowHistory = [];
		this.selectableRows = null;
		var items = this.items;
		this.rowIds.clear();
		items.un("add", this.onItemAdd, this);
		items.un("remove", this.onItemRemove, this);
		items.each(function(item) {
			item.removed(this);
			item.destroy();
		}, this);
		items.clear();
		items.on("add", this.onItemAdd, this);
		items.on("remove", this.onItemRemove, this);
		this.setIsEmpty(true);
	},

	/**
	 * @inheritDoc Terrasoft.Bindable#subscribeForCollectionEvents
	 * @protected
	 * @overridden
	 */
	subscribeForCollectionEvents: function(binding, property, model) {
		this.callParent(arguments);
		var collection = model.get(binding.modelItem);
		collection.on("dataLoaded", this.onCollectionDataLoaded, this);
		collection.on("add", this.onAddItem, this);
		collection.on("remove", this.onDeleteItem, this);
		collection.on("clear", this.clear, this);
	},

	/**
	 * @inheritDoc Terrasoft.Bindable#unSubscribeForCollectionEvents
	 * @protected
	 * @overridden
	 */
	unSubscribeForCollectionEvents: function(binding, property, model) {
		if (!model) {
			// TODO: 193528
			return;
		}
		var collection = model.get(binding.modelItem);
		collection.un("dataLoaded", this.onCollectionDataLoaded, this);
		collection.un("add", this.onAddItem, this);
		collection.un("remove", this.onDeleteItem, this);
		collection.un("clear", this.clear, this);
		this.callParent(arguments);
	},

	/**
	 * @inheritDoc Terrasoft.Component#onDestroy
	 */
	onDestroy: function() {
		var wrapEl = this.getWrapEl();
		if (wrapEl) {
			wrapEl.un("click", this.onClick, this);
		}
		this.callParent(arguments);
	},

	/**
	 * @inheritDoc Terrasoft.Component#onAfterRender
	 * @protected
	 */
	onAfterRender: function() {
		this.callParent(arguments);
		var emptyMessageConfig = this.getEmptyMessageConfig();
		if (!Ext.isEmpty(emptyMessageConfig)) {
			this.isEmpty = this.items.length === 0;
			this.showEmptyMessage(emptyMessageConfig);
		}
	},

	/**
	 * Возвращает конфигурацию пользовательского сообщения о пустом списке.
	 * @private
	 * @return {Object}
	 */
	getEmptyMessageConfig: function() {
		var emptyMessageConfig = {};
		this.fireEvent("getEmptyMessageConfig", emptyMessageConfig);
		if (emptyMessageConfig && emptyMessageConfig.className) {
			return Terrasoft.deepClone(emptyMessageConfig);
		}
		return null;
	},

	/**
	 * Метод изменяющий атрибут состояния списка: пустой, не пустой.
	 * @param {Boolean} value Устанавливаемое значение.
	 */
	setIsEmpty: function(value) {
		if (this.isEmpty === value) {
			return;
		}
		this.isEmpty = value;
		if (value === true) {
			this.clear();
		}
		this.showEmptyMessage();
	},

	/**
	 * Метод отображающий сообщение для пустого списка.
	 * @protected
	 * @param {Object} emptyMessageConfig Параметры для создания элемента управления с сообщением о пустом списке.
	 */
	showEmptyMessage: function(emptyMessageConfig) {
		if (!this.rendered) {
			return;
		}
		var emptyMessageControl = this.emptyMessageControl;
		var isEmptyCls = "container-list-empty";
		var wrapEl = this.getWrapEl();
		if (Ext.isEmpty(emptyMessageConfig)) {
			emptyMessageConfig = this.getEmptyMessageConfig();
		}
		if (this.isEmpty) {
			if (wrapEl) {
				wrapEl.addCls(isEmptyCls);
			}
			if (!Ext.isEmpty(emptyMessageConfig) && Ext.isEmpty(emptyMessageControl)) {
				Ext.apply(emptyMessageConfig, {
					renderTo: wrapEl
				});
				this.emptyMessageControl = Ext.create(emptyMessageConfig.className, emptyMessageConfig);
			}
		} else {
			if (wrapEl) {
				wrapEl.removeCls(isEmptyCls);
			}
			if (!Ext.isEmpty(emptyMessageControl)) {
				emptyMessageControl.destroy();
				this.emptyMessageControl = null;
			}
		}
	}
});

				// Autogenerated Code for schema ContainerList (End)
// Autogenerated Code for schema CtiContainerList (Start)
define('CtiContainerListResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("CtiContainerList", ["terrasoft", "ext-base", "ContainerList", "SchemaBuilderV2"], function(Terrasoft, Ext) {

	/**
	 * Класс реализует отображение коллекции панелей.
	 */
	Ext.define("Terrasoft.controls.CtiContainerList", {
		extend: "Terrasoft.ContainerList",
		alternateClassName: "Terrasoft.CtiContainerList",

		/**
		 * Префикс идеднтификатора элемента панели.
		 * @type {String}
		 */
		dataItemIdPrefix: "cti-panel-item",

		/**
		 * Идеднтификатор sandbox.
		 * Используется для формирования уникального идентификатора элемента панели.
		 * @type {String}
		 */
		sandboxId: "",

		/**
		 * Класс внешнего контейнера панели.
		 * @type {String}
		 */
		wrapClassName: "list-item-container",

		/**
		 * CSS селектор элемента коллекции.
		 * @type {String}
		 */
		rowCssSelector: ".list-item-container",

		/**
		 * @inheritdoc Terrasoft.ContainerList#getItemElementId
		 * @overridden
		 */
		getItemElementId: function(item) {
			var id = item.get(this.idProperty);
			return this.dataItemIdPrefix + "-" + id + item.sandbox.id;
		},

		/**
		 * Получает уникальный marker value элемента интерфейса.
		 * @protected
		 * @param {Object} item Элемент коллекции панелей.
		 * @returns {String} Уникальный marker value элемента интерфейса.
		 */
		getItemMarkerValue: function(item) {
			var id = item.get(this.idProperty);
			return this.dataItemIdPrefix + "-" + id;
		},

		/**
		 * Возвращает конфигурация представления элемента панели.
		 * @protected
		 * @param {Object} item Элемент коллекции панелей.
		 * @returns {Object} Конфигурация представления элемента панели.
		 */
		getItemConfig: function(item) {
			var itemConfig = this.defaultItemConfig;
			var itemCfg = {};
			this.fireEvent("onGetItemConfig", itemCfg, item);
			if (itemCfg.config) {
				itemConfig = itemCfg.config;
				this.defaultItemConfig = itemCfg.config;
			}
			if (Ext.isFunction(this.getCustomItemConfig)) {
				itemConfig = this.getCustomItemConfig(item) || itemConfig;
			}
			return Terrasoft.deepClone(itemConfig);
		},

		/**
		 * @inheritdoc Terrasoft.ContainerList#getItemView
		 * @overridden
		 */
		getItemView: function(item) {
			this.sandboxId = item.sandbox.id;
			var itemConfig = this.getItemConfig(item);
			var itemMarkerValue = this.getItemMarkerValue(item);
			var itemElementId = this.getItemElementId(item);
			this.decorateView(itemConfig, itemElementId, this.sandboxId);
			return Ext.create("Terrasoft.Container", {
				id: itemElementId,
				markerValue: itemMarkerValue,
				items: itemConfig,
				classes: {"wrapClassName": [this.wrapClassName]}
			});
		}

	});

});

				// Autogenerated Code for schema CtiContainerList (End)
// Autogenerated Code for schema CtiProviderInitializer (Start)
define('CtiProviderInitializerResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={
	CtiProviderIsUndefinedMessage: 'Cti-провайдер не определен. Заполните системную настройку с кодом \'SysMsgLib\'',
	NotSupportedCtiProviderMessage: 'Выбранный Cti-провайдер (\'{0}\') не поддерживается'
};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("CtiProviderInitializer", ["ext-base", "CtiProviderInitializerResources", "core", "terrasoft"],
	function(Ext, resources, core, Terrasoft) {
		return {
			/**
			 * Инициализует специфичные для cti-провайдера параметры.
			 * @protected
			 * @param {Terrasoft.BaseCtiProvider} ctiProvider cti-провайдер
			 * @param {String} ctiProviderName Название класса cti-провайдера.
			 * @param {Function} callback Функция обратного вызова.
			 */
			initCustomCtiProvider: function(ctiProvider, ctiProviderName, callback) {
				callback(ctiProvider);
			},

			/**
			 * Инициализирует cti-провайдер и вызывает функцию обратного вызова.
			 * @param {String} ctiProviderName Название класса cti-провайдера.
			 * @param {Function} callback Функция обратного вызова.
			 */
			initializeCtiProvider: function(ctiProviderName, callback) {
				var ctiProvider = Terrasoft[ctiProviderName];
				if (Ext.isEmpty(ctiProvider)) {
					if (!core.getModuleDescriptor(ctiProviderName)) {
						var message = Ext.String.format(resources.localizableStrings.NotSupportedCtiProviderMessage,
							ctiProviderName);
						throw new Terrasoft.UnsupportedTypeException({
							message: message
						});
					}
					require([ctiProviderName], function() {
						ctiProvider = Terrasoft[ctiProviderName];
						this.initCustomCtiProvider(ctiProvider, ctiProviderName, callback);
					}.bind(this));
				} else {
					this.initCustomCtiProvider(ctiProvider, ctiProviderName, callback);
				}
			}
		};
	}
);

				// Autogenerated Code for schema CtiProviderInitializer (End)
// Autogenerated Code for schema CtiPanelModelUtilities (Start)
define('CtiPanelModelUtilitiesResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("CtiPanelModelUtilities", ["CtiConstants", "NetworkUtilities"],
	function(CtiConstants, NetworkUtilities) {

		/**
		 * @class Terrasoft.configuration.mixins.CtiPanelModelUtilities
		 * Миксин модели представления cti панели.
		 * @type {Terrasoft.BaseObject}
		 */
		Ext.define("Terrasoft.configuration.mixins.CtiPanelModelUtilities", {
			extend: "Terrasoft.BaseObject",
			alternateClassName: "Terrasoft.CtiPanelModelUtilities",

			// region Properties: Private

			/**
			 * Класс медиа-элемента, указывающий на то, что используется видео поток.
			 * @private
			 * @type {String}
			 */
			useVideoMediaElementClassName: "useVideo",

			// endregion

			//region Methods: Private

			/**
			 * Получает локализированную строку из ресурсов.
			 * @private
			 * @param {String} stringName Название локализированной строки.
			 * @returns {String} Локализированная строка.
			 */
			getResourceString: function(stringName) {
				return this.get("Resources.Strings." + stringName);
			},

			/**
			 * Получает локализированное изображение из ресурсов.
			 * @private
			 * @param {String} imageName Название локализированного изображения.
			 * @returns {Object} Локализированное изображение.
			 */
			getResourceImage: function(imageName) {
				return this.get("Resources.Images." + imageName);
			},

			/**
			 * Инициализирует коллекции идентифицируемых абонентов.
			 * @private
			 */
			initializeSubscribersCollections: function() {
				var events = ["add", "remove", "dataLoaded", "clear"];
				var identifiedSubscribers = this.get("IdentifiedSubscriberPanelCollection");
				var identifiedConsultSubscribers = this.get("IdentifiedConsultSubscriberPanelCollection");
				var searchResultSubscribers = this.get("SearchResultPanelCollection");
				Terrasoft.each(events, function(eventName) {
					identifiedSubscribers.on(eventName, function() {
						this.onIdentifiedSubscribersChanged(identifiedSubscribers, false);
					}.bind(this));
					identifiedConsultSubscribers.on(eventName, function() {
						this.onIdentifiedSubscribersChanged(identifiedConsultSubscribers, true);
					}.bind(this));
					searchResultSubscribers.on(eventName, function() {
						this.onSearchResultSubscribersChanged(searchResultSubscribers);
					}.bind(this));
				}, this);
			},

			/**
			 * Очищает поле номера.
			 * @private
			 */
			clearPhoneNumber: function() {
				this.set("PhoneNumber", "");
			},

			/**
			 * Совершает звонок (простой или консультационный) на номер введенный в поле PhoneNumber.
			 * @private
			 */
			callPhoneNumber: function() {
				var number = this.get("PhoneNumber");
				this.callByNumber(number);
			},

			/**
			 * Обрабатывает событие изменения значения в поле ввода номера.
			 * @param {String} value Текущее значение в поле ввода номера.
			 */
			onPhoneNumberChanged: function(value) {
				var oldValue = this.get("PhoneNumberOldValue");
				if (value === oldValue) {
					return;
				}
				this.set("PhoneNumberOldValue", value);
				if (this.isSearchValueValid(value) && !this.isPhoneNumberValid(value)) {
					this.searchSubscriberByPrimaryColumnValue(value);
				} else {
					this.set("IsSearchFinishedAndResultEmpty", false);
					this.clearSearchSubscriber();
				}
			},

			/**
			 * Обновляет строку длительности разговора.
			 * @private
			 */
			updateCallDuration: function() {
				var ctiModel = Terrasoft.CtiModel;
				var commutationStartedOn = ctiModel.get("CommutationStartedOn");
				var currentDate = new Date();
				var timeDifference = Ext.Date.getElapsed(currentDate, commutationStartedOn);
				var secondDifference = Math.floor(timeDifference / CtiConstants.TimeScale.MillisecondsInSecond);
				var minutes = Math.floor(secondDifference / CtiConstants.TimeScale.SecondsInMinute);
				if (minutes < CtiConstants.TimeScale.MinTwoDigitNumber) {
					minutes = "0" + minutes;
				}
				var seconds = secondDifference - (minutes * CtiConstants.TimeScale.SecondsInMinute);
				if (seconds < CtiConstants.TimeScale.MinTwoDigitNumber) {
					seconds = "0" + seconds;
				}
				var msg = Ext.String.format("{0}:{1}", minutes, seconds);
				ctiModel.set("CallDuration", msg);
			},

			//endregion

			//region Methods: Protected

			/**
			 * Инициализирует свойства модели при подключении телефонии.
			 * @protected
			 */
			initOnConnected: function() {
				var capabilities = this.getProviderCapabilities();
				/*jshint bitwise:false */
				this.set("IsVideoSupported",
					(capabilities.callCapabilities & Terrasoft.CallFeaturesSet.CAN_VIDEO) !== 0);
				/*jshint bitwise:true */
			},

			/**
			 * Возвращает признак широкой кнопки Завершить.
			 * @protected
			 * @return {Boolean} Возвращает true, если необходима широкая кнопка Завершить.
			 */
			getIsDropButtonLong: function() {
				var buttonsCount = this.getCanAnswer() + this.getCanHoldOrUnhold() +
					this.getCanStartOrCompleteTransfer();
				return (buttonsCount < 2);
			},

			/**
			 * Возвращает конфигурацию изображения кнопки "Положить трубку".
			 * @protected
			 * @return {Object} Конфигурация изображения.
			 */
			getDropButtonImageConfig: function() {
				var imageName = this.getIsDropButtonLong() ? "DropButtonLongIcon" : "DropButtonShortIcon";
				return this.getResourceImage(imageName);
			},

			/**
			 * Возвращает стиль кнопки "Положить трубку".
			 * @protected
			 * @return {String} Стиль кнопки "Положить трубку".
			 */
			getDropButtonStyle: function() {
				var style = this.getIsDropButtonLong() ? "call-button-long" : "call-button-middle";
				return style;
			},

			/**
			 * Возвращает конфигурацию изображения для кнопки "Снять/поставить на удержание".
			 * @protected
			 * @return {Object} Конфигурация изображения.
			 */
			getHoldButtonImageConfig: function() {
				var imageName;
				switch (true) {
					case this.getCanUnhold():
						imageName = "UnholdButtonIcon";
						break;
					case this.getCanHold():
						imageName = "HoldButtonIcon";
						break;
					default:
						imageName = "HoldButtonIconDisabled";
						break;
				}
				return this.getResourceImage(imageName);
			},

			/**
			 * Возвращает текст подсказки для кнопки "Снять/поставить на удержание".
			 * @protected
			 * @return {String|*} Текст подсказки.
			 */
			getHoldButtonHint: function() {
				var stringName = this.getCanUnhold() ? "UnholdButtonHint" : "HoldButtonHint";
				return this.getResourceString(stringName);
			},

			/**
			 * Возвращает URL изображения, если нет записей удовлетворяющих условиям поиска.
			 * @protected
			 * @return {String} URL изображения, если нет записей удовлетворяющих условиям поиска.
			 */
			getEmptySearchResultImageUrl: function() {
				var emptySearchResultImage = this.getResourceImage("EmptySearchResultImage");
				return Terrasoft.ImageUrlBuilder.getUrl(emptySearchResultImage);
			},

			/**
			 * Возвращает возможность позвонить либо совершить консультационный звонок.
			 * @protected
			 * @returns {Boolean} true, если можно позвонить либо совершить консультационный звонок. Иначе - false.
			 */
			getCanMakeCallOrMakeConsultCall: function() {
				if (this.getCanCall()) {
					return true;
				}
				return (this.get("IsTransferPrepared") && this.getCanMakeConsultCall());
			},

			/**
			 * Формирует признак видимости контейнера с найденными абонентами в результате поиска.
			 * @protected
			 * @returns {Boolean} Признак видимости контейнера с найденными абонентами в результате поиска.
			 */
			getIsSearchResultItemsListContainerVisible: function() {
				return (!this.get("IsSearchResultPanelCollectionEmpty") && this.getCanMakeCallOrMakeConsultCall());
			},

			/**
			 * Определяет видимость вкладки истории звонков.
			 * @private
			 * @returns {Boolean} true, если нет активного звонка и нет текста в поле поиска абонентоа. Иначе - false.
			 */
			getIsCommunicationHistoryVisible: function() {
				return (!this.getIsIdentificationGroupContainerVisible() &&
					this.get("IsSearchResultPanelCollectionEmpty") && !this.get("IsSearchFinishedAndResultEmpty") &&
					this.getCanMakeCallOrMakeConsultCall());
			},

			/**
			 * Возвращает признак возможности совершить DTMF набор.
			 * @protected
			 * @returns {Boolean} true, если можно совершить DTMF набор. Иначе - false.
			 */
			getCanMakeDtmf: function() {
				var isDtmfPrepared = this.get("IsDtmfPrepared");
				return (isDtmfPrepared && this.getCanDtmf());
			},

			/**
			 * Возвращает возможность инициировать начало перевода либо завершить перевод.
			 * @protected
			 * @returns {Boolean} true, если доступна инициация либо завершение перевода, иначе - false.
			 */
			getCanStartOrCompleteTransfer: function() {
				var canStartOrCompleteTransfer = this.getCanMakeConsultCall() || this.getCanBlindTransfer() ||
					this.getCanTransfer();
				return canStartOrCompleteTransfer;
			},

			/**
			 * Возвращает конфигурацию изображения кнопки "Подготовка к переводу".
			 * @protected
			 * @return {Object} Конфигурация изображения.
			 */
			getPrepareTransferButtonImageConfig: function() {
				var imageName = !this.get("IsTransferPrepared")
					? "PrepareTransferButtonIcon"
					: "PrepareTransferButtonIconDisabled";
				return this.getResourceImage(imageName);
			},

			/**
			 * Определяет, отображаются ли кнопки "Панель набора номера", "Отключить звук", "Отключить видео".
			 * @protected
			 * @return {Boolean} Кнопка видима.
			 */
			getIsAdditionalButtonsVisible: function() {
				//TODO #CC-213 #CC-347 #CC-348 Дополнительные кнопки панели.
				return this.getCanStartOrCompleteTransfer() || this.getCanHoldOrUnhold();
			},

			/**
			 * Возвращает конфигурацию изображения кнопки отображения/скрытия поля ввода DTMF наборa.
			 * @protected
			 * @return {Object} Конфигурация изображения.
			 */
			getDtmfButtonImageConfig: function() {
				var imageName = this.get("IsDtmfPrepared") ? "DtmfButtonIconPressed" : "DtmfButtonIcon";
				return this.getResourceImage(imageName);
			},

			/**
			 * Возвращает конфигурацию изображения кнопки "Панель набора номера".
			 * @protected
			 * @return {Object} Конфигурация изображения.
			 */
			getDialPanelButtonImageConfig: function() {
				var canOpenDialPanel = false;
				var imageName = canOpenDialPanel ? "DialPanelButtonIcon" : "DialPanelButtonIconDisabled";
				return this.getResourceImage(imageName);
			},

			/**
			 * Определяет, отображается ли кнопка "Отключить звук".
			 * @protected
			 * @return {Boolean} Кнопка видима.
			 */
			getIsMuteButtonVisible: function() {
				//TODO #CC-347 Реализовать работу функции "Отключить звук" (реализовать проверку).
				return this.getIsAdditionalButtonsVisible();
			},

			/**
			 * Определяет, доступность кнопки "Отключить звук".
			 * @protected
			 * @return {Boolean} Кнопка доступна.
			 */
			getIsMuteButtonEnabled: function() {
				//TODO #CC-347 Реализовать работу функции "Отключить звук" (реализовать проверку).
				return false;
			},

			/**
			 * Возвращает конфигурацию изображения кнопки "Отключить звук".
			 * @protected
			 * @return {Object} Конфигурация изображения.
			 */
			getMuteButtonImageConfig: function() {
				var canMute = false;
				var imageName = canMute ? "MuteButtonIcon" : "MuteButtonIconDisabled";
				return this.getResourceImage(imageName);
			},

			/**
			 * Возвращает текст подсказки для кнопки "Отключить звук".
			 * @protected
			 * @return {String} Текст подсказки.
			 */
			getMuteButtonHint: function() {
				var canMute = false;
				var stringName = canMute ? "MuteButtonHint" : "UnmuteButtonHint";
				return this.getResourceString(stringName);
			},

			/**
			 * Возвращает стиль контейнера с видео.
			 * @return {String}
			 */
			getVideoContainerStyle: function() {
				if (this.get("IsVideoHidden")) {
					return "video-hidden";
				}
			},

			/**
			 * Возвращает конфигурацию изображения кнопки "Отключить видео".
			 * @protected
			 * @return {Object} Конфигурация изображения.
			 */
			getVideoButtonImageConfig: function() {
				var imageName;
				var isVideoHidden = this.get("IsVideoHidden");
				var isVideoSupported = this.get("IsVideoSupported");
				if (!isVideoSupported) {
					imageName = "VideoOffButtonIconDisabled";
				} else {
					imageName = (isVideoHidden) ? "VideoOffButtonIcon" : "VideoOnButtonIcon";
				}
				return this.getResourceImage(imageName);
			},

			/**
			 * Возвращает текст подсказки для кнопки "Отключить видео".
			 * @protected
			 * @return {String} Текст подсказки.
			 */
			getVideoButtonHint: function() {
				var isVideoHidden = this.get("IsVideoHidden");
				var stringName = isVideoHidden ? "VideoOnButtonHint" : "VideoOffButtonHint";
				return this.getResourceString(stringName);
			},

			/**
			 * Возвращает конфигурацию изображения с фото абонента, а если абонент не определен - иконку
			 * неизвестного контакта.
			 * @protected
			 * @param {String} tag Тэг элемента управления фото панели идентификации.
			 * @param {String} collectionName (optional) Название коллекции идентифицируемых абонентов.
			 * @param {String} subscriberKeyName (optional) Название свойства с ключом
			 * идентифицированного абонента.
			 * @returns {Object} Конфигурация изображения.
			 */
			getSubscriberPhoto: function(tag, collectionName, subscriberKeyName) {
				var subscriberPanel = this.getIdentifiedSubscriberPanel(collectionName, subscriberKeyName);
				if (!subscriberPanel) {
					return this.getResourceImage("UnidentifiedSubscriberPhoto");
				}
				var photoId = subscriberPanel.get("Photo");
				if (subscriberPanel.get("Type") === CtiConstants.SubscriberTypes.Account) {
					return this.getResourceImage("AccountIdentifiedPhoto");
				}
				if (Ext.isEmpty(photoId) || this.Terrasoft.isEmptyGUID(photoId)) {
					return this.getResourceImage("ContactEmptyPhoto");
				}
				var photoConfig = {
					source: this.Terrasoft.ImageSources.ENTITY_COLUMN,
					params: {
						schemaName: "SysImage",
						columnName: "Data",
						primaryColumnValue: photoId
					}
				};
				return {
					source: Terrasoft.ImageSources.URL,
					url: Terrasoft.ImageUrlBuilder.getUrl(photoConfig)
				};
			},

			/**
			 * Возвращает конфигурацию изображения с фото абонента консультационного звонка.
			 * @protected
			 * @param {String} tag Тэг элемента управления фото панели идентификации.
			 * @returns {Object} Конфигурация изображения.
			 */
			getConsultSubscriberPhoto: function(tag) {
				return this.getSubscriberPhoto(tag, "IdentifiedConsultSubscriberPanelCollection",
					"IdentifiedConsultSubscriberKey");
			},

			/**
			 * Возвращает информацию об абоненте по тэгу элемента управления в блоке идентификации.
			 * @protected
			 * @param {String} tag Тэг элемента управления идентификации абонента.
			 * @param {String} collectionName (optional) Название коллекции идентифицируемых абонентов.
			 * @param {String} subscriberKeyName (optional) Название свойства с ключом идентифицированного абонента.
			 * @returns {String} Информация об абоненте.
			 */
			getSubscriberData: function(tag, collectionName, subscriberKeyName) {
				var subscriberPanel = this.getIdentifiedSubscriberPanel(collectionName, subscriberKeyName);
				if (!subscriberPanel) {
					return "";
				}
				return subscriberPanel.get(tag) || "";
			},

			/**
			 * Возвращает информацию об абоненте по тэгу элемента управления в блоке идентификации консультационного
			 * звонка.
			 * @protected
			 * @param {String} tag Тэг элемента управления идентификации абонента.
			 * @returns {String} Информация об абоненте.
			 */
			getConsultSubscriberData: function(tag) {
				return this.getSubscriberData(tag, "IdentifiedConsultSubscriberPanelCollection",
					"IdentifiedConsultSubscriberKey");
			},

			/**
			 * Определяет, являются ли данные идентификации видимые по тэгу элемента управления в блоке идентификации.
			 * @protected
			 * @param {String} tag Тэг элемента управления идентификации абонента.
			 * @param {String} collectionName (optional) Название коллекции идентифицируемых абонентов.
			 * @param {String} subscriberKeyName (optional) Название свойства с ключом идентифицированного абонента.
			 * @return {Boolean} Видимость данных идентификации.
			 */
			getIsInfoLabelVisible: function(tag, collectionName, subscriberKeyName) {
				var subscriberPanel = this.getIdentifiedSubscriberPanel(collectionName, subscriberKeyName);
				if (!subscriberPanel) {
					return false;
				}
				var identificationDataLabels = this.get("IdentificationDataLabels");
				var currentIdentificationDataLabels = identificationDataLabels[subscriberPanel.get("Type")];
				var isInfoLabelVisible = (!Ext.isEmpty(subscriberPanel.get(tag)) &&
					currentIdentificationDataLabels.indexOf(tag) !== -1);
				return isInfoLabelVisible;
			},

			/**
			 * Определяет, являются ли данные идентификации видимые по тэгу элемента управления в блоке идентификации
			 * консультационного звонка.
			 * @protected
			 * @param {String} tag Тэг элемента управления идентификации абонента.
			 * @return {Boolean} Видимость данных идентификации.
			 */
			getIsConsultInfoLabelVisible: function(tag) {
				return this.getIsInfoLabelVisible(tag, "IdentifiedConsultSubscriberPanelCollection",
					"IdentifiedConsultSubscriberKey");
			},

			/**
			 * Определяет, является ли абонент идентифицированным, в зависимости от значения параметра с ключом
			 * коллекции идентифицированных абонентов.
			 * @private
			 * @param {String} keyValue Значение ключа.
			 * @returns {Boolean} Абонент идентифицирован.
			 */
			getIsSubscriberIdentified: function(keyValue) {
				return !Ext.isEmpty(keyValue);
			},

			/**
			 * Определяет, является ли абонент неизвестным.
			 * @protected
			 * @return {Boolean} Абонент неизвестен.
			 */
			getIsSubscriberUnknown: function() {
				var identifiedSubscriberKey = this.get("IdentifiedSubscriberKey");
				return Ext.isEmpty(identifiedSubscriberKey) && this.getIsCallExists();
			},

			/**
			 * Определяет, является ли абонент консультационного звонка неизвестным.
			 * @protected
			 * @return {Boolean} Абонент неизвестен.
			 */
			getIsConsultSubscriberUnknown: function() {
				var identifiedSubscriberKey = this.get("IdentifiedConsultSubscriberKey");
				return Ext.isEmpty(identifiedSubscriberKey) && this.get("IsConsulting");
			},

			/**
			 * Определяет существует ли звонок в модели.
			 * @protected
			 * @returns {Boolean} true, если звонок существует. Иначе - false.
			 */
			getIsCallExists: function() {
				return !Ext.isEmpty(this.get("CurrentCall"));
			},

			/**
			 * @inheritdoc Terrasoft.CtiModel#callStarted.
			 * @protected
			 */
			getIsCallDurationVisible: function() {
				return !Ext.isEmpty(this.get("CommutationStartedOn"));
			},

			/**
			 * Определяет вилимость сообщения, что нет записей удовлетворяющих условиям поиска.
			 * @private
			 * @returns {Boolean} true, если нет записей удовлетворяющих условиям поиска. Иначе - false.
			 */
			getIsEmptySearchResultContainerVisible: function() {
				var isVisible = this.get("IsSearchFinishedAndResultEmpty") && this.getCanMakeCallOrMakeConsultCall();
				return isVisible;
			},

			//endregion

			// region Methods: Public

			/**
			 * Совершает звонок (простой или консультационный) на номер телефона.
			 * @param {String} number Номер телефона.
			 */
			callByNumber: function(number) {
				number = number.replace(/\D/g, "");
				if (this.isPhoneNumberValid(number)) {
					var isTransferPrepared = this.get("IsTransferPrepared");
					if (isTransferPrepared && this.getCanMakeConsultCall()) {
						this.makeConsultCall(number);
						this.set("IsTransferPrepared", false);
					} else {
						this.makeCall(number);
					}
					this.clearPhoneNumber();
				}
			},

			//endregion

			//region Events

			/**
			 * Производит переход в карточку абонента основного звонка.
			 */
			onSubscriberNameClick: function() {
				this.onNameClick(false);
			},

			/**
			 * Производит переход в карточку абонента консультационного звонка.
			 */
			onConsultSubscriberNameClick: function() {
				this.onNameClick(true);
			},

			/**
			 * Производит переход в карточку абонента.
			 * @private
			 * @param {Boolean} isConsultSubscriber Признак абонента консультанционного звонка.
			 */
			onNameClick: function(isConsultSubscriber) {
				var collectionName = isConsultSubscriber
					? "IdentifiedConsultSubscriberPanelCollection"
					: "IdentifiedSubscriberPanelCollection";
				var identifiedSubscriberKeyName = isConsultSubscriber
					? "IdentifiedConsultSubscriberKey"
					: "IdentifiedSubscriberKey";
				var subscriberPanel = this.getIdentifiedSubscriberPanel(collectionName, identifiedSubscriberKeyName);
				if (!subscriberPanel) {
					return;
				}
				var subscriberType = subscriberPanel.get("Type");
				var schemaName = (subscriberType !== CtiConstants.SubscriberTypes.Employee)
					? subscriberType
					: CtiConstants.SubscriberTypes.Contact;
				var hash = NetworkUtilities.getEntityUrl(schemaName, subscriberPanel.get("Id"));
				this.sandbox.publish("PushHistoryState", {hash: hash});
			},

			/**
			 * Обрабатывает нажатие кнопки "Подготовка к переводу".
			 */
			onPrepareTransferButtonClick: function() {
				var isTransferPrepared = this.get("IsTransferPrepared");
				this.set("IsTransferPrepared", !isTransferPrepared);
				if (!isTransferPrepared) {
					this.set("IsDtmfPrepared", false);
				}
			},

			/**
			 * Обрабатывает нажатие кнопки "Панель набора номера".
			 * @private
			 */
			onDtmfButtonClick: function() {
				var isDtmfPrepared = this.get("IsDtmfPrepared");
				this.set("IsDtmfPrepared", !isDtmfPrepared);
				if (!isDtmfPrepared) {
					this.set("IsTransferPrepared", false);
				}
			},

			/**
			 * Обработчик нажатия кнопки DTMF наборa.
			 * @private
			 */
			enterDtmf: function() {
				var dtmfDigit = arguments[3];
				this.sendDtmf(dtmfDigit);
			},

			/**
			 * Обрабатывает нажатие кнопки "Отключить звук".
			 * @private
			 */
			onMuteButtonClick: function() {
				//TODO #CC-347 Реализовать работу функции "Отключить звук".
			},

			/**
			 * Обрабатывает нажатие кнопки "Отключить видео".
			 * @private
			 */
			onVideoButtonClick: function() {
				var currentCall = this.get("CurrentCall");
				this.checkCurrentCallExists(currentCall);
				var isStartVideo = this.get("IsVideoHidden");
				this.setVideoState(currentCall, isStartVideo, this.onSetVideoState.bind(this));
				
			},

			/**
			 * @inheritdoc Terrasoft.CtiModel#commutationStarted.
			 * @private
			 */
			onCommutationStarted: function(call) {
				var currentCall = this.get("CurrentCall");
				if (currentCall && currentCall.id === call.id) {
					var durationTimerIntervalId = setInterval(this.updateCallDuration,
						CtiConstants.TalkDuration.RefreshRate);
					this.set("DurationTimerIntervalId", durationTimerIntervalId);
					this.set("CommutationStartedOn", new Date());
				}
			},

			/**
			 * Обрабатывает событие изменения состояния оператора.
			 * @param {Backbone.Model} model Cti-модель.
			 * @param {String} agentStateCode Код состояния оператора.
			 */
			onAgentStateCodeChanged: function(model, agentStateCode) {
				this.sandbox.publish("AgentStateChanged", agentStateCode);
			},

			/**
			 * Текущий звонок изменился.
			 * @param {Backbone.Model} model Cti-модель.
			 * @param {Terrasoft.integration.telephony.Call} call Объект звонка.
			 * @private
			 */
			onChangeCurrentCall: function(model, call) {
				if (call) {
					var communicationPanelConfig = {selectedItem: "CtiPanel"};
					this.sandbox.publish("SelectCommunicationPanelItem", communicationPanelConfig);
				}
			},

			/**
			 * Длительность звонка изменилась.
			 * @param {Backbone.Model} model Cti-модель.
			 * @param {String} callDuration Длительность звонка в формате mm:ss.
			 * @private
			 */
			onChangeCallDuration: function(model, callDuration) {
				this.sandbox.publish("CallDurationChanged", callDuration);
			},

			/**
			 * @inheritdoc Terrasoft.CtiModel#connected.
			 * @private
			 */
			onConnected: function() {
				//TODO #CC-349 Реализовать запрос состояния клиента при соединении/перезагрузке страницы в браузере.
				this.initializeSubscribersCollections();
				this.sandbox.publish("CtiPanelConnected");
				this.initOnConnected();
			},

			/**
			 * Обработчик события изменения номера текущего звонка.
			 * @private
			 * @param {Backbone.Model} model Модель.
			 * @param {String} number Номер текущего звонка.
			 */
			onChangeCurrentCallNumber: function(model, number) {
				var panelCollection = this.get("IdentifiedSubscriberPanelCollection");
				panelCollection.clear();
				if (!Ext.isEmpty(number)) {
					this.identifySubscriber(number);
				} else {
					this.loadCommunicationHistory();
				}
			},

			/**
			 * Обработчик события изменения номера консультационного звонка.
			 * @param {Backbone.Model} model Модель.
			 * @param {String} number Номер консультационного звонка.
			 */
			onChangeConsultCallNumber: function(model, number) {
				var panelCollection = this.get("IdentifiedConsultSubscriberPanelCollection");
				panelCollection.clear();
				if (!Ext.isEmpty(number)) {
					this.identifySubscriber(number, "IdentifiedConsultSubscriberPanelCollection",
						"IdentifiedConsultSubscriberKey");
				}
			},

			/**
			 * Обрабатывает событие изменения ключа идентифицированного абонента основного звонка.
			 * @param {Backbone.Model} model Cti-модель.
			 * @param {String} identifiedSubscriberKey Ключ идентифицированного абонента основного звонка.
			 */
			onIdentifiedSubscriberKeyChanged: function(model, identifiedSubscriberKey) {
				this.updateCallByIdentifiedSubscriber("IdentifiedSubscriberPanelCollection", identifiedSubscriberKey);
			},

			/**
			 * Обрабатывает событие изменения ключа идентифицированного абонента консультационного звонка.
			 * @param {Backbone.Model} model Cti-модель.
			 * @param {String} identifiedSubscriberKey Ключ идентифицированного абонента консультационного звонка.
			 */
			onIdentifiedConsultSubscriberKeyChanged: function(model, identifiedSubscriberKey) {
				this.updateCallByIdentifiedSubscriber("IdentifiedConsultSubscriberPanelCollection", identifiedSubscriberKey);
			},

			/**
			 * @inheritDoc Terrasoft.BaseCtiProvider#callSaved
			 */
			onCallSavedEvent: function(call) {
				var activeCall = this.activeCalls.find(call.id);
				if (activeCall) {
					this.updateCallByIdentificationData(activeCall);
				}
			},

			/**
			 * Обработчик события изменения коллекции идентифицированных абонентов звонка. По умолчанию выполняется для
			 * основного звонка.
			 * @private
			 * @param {Terrasoft.Collection} subscribersCollection Коллекция идентифицируемых абонентов.
			 * @param {String} isConsult (optional) Признак, указывающий является ли звонок консультационным.
			 */
			onIdentifiedSubscribersChanged: function(subscribersCollection, isConsult) {
				var subscribersCount = subscribersCollection.getCount();
				var identifiedSubscriberKeyPropertyName = (isConsult)
					? "IdentifiedConsultSubscriberKey"
					: "IdentifiedSubscriberKey";
				var identifiedSubscriberCountPropertyName = (isConsult)
					? "IdentifiedConsultSubscribersCount"
					: "IdentifiedSubscribersCount";
				if (subscribersCount === 1) {
					var subscriberKeys = subscribersCollection.getKeys();
					this.set(identifiedSubscriberKeyPropertyName, subscriberKeys[0]);
				} else {
					this.set(identifiedSubscriberKeyPropertyName, null);
				}
				this.set(identifiedSubscriberCountPropertyName, subscribersCount);
			},

			/**
			 * Обработчик события изменения коллекции абонентов, найденных в результате поиска.
			 * @private
			 * @param {Terrasoft.Collection} subscribersCollection Коллекция абонентов, найденных в результате поиска.
			 */
			onSearchResultSubscribersChanged: function(subscribersCollection) {
				var isSubscribersCollectionEmpty = subscribersCollection.isEmpty();
				this.set("IsSearchResultPanelCollectionEmpty", isSubscribersCollectionEmpty);
			},

			/**
			 * Обработчик события звонка клиенту.
			 * @private
			 * @param {Object} numberInfo Информация о параметрах звонка.
			 * @param {String} numberInfo.number Номер телефона клиента.
			 */
			onCallCustomer: function(numberInfo) {
				var phoneNumber = numberInfo.number;
				if (numberInfo.customerId) {
					this.set("AdvisedIdentifiedSubscriber", numberInfo.customerId);
				}
				this.makeCall(phoneNumber);
			},

			/**
			 * Обработчик события о необходимости получения записей разговоров звонка.
			 * @private
			 * @param {Object} callInfo Информация для получения записей разговоров звонка.
			 * @param {String} callInfo.callId Идентификатор звонка.
			 * @param {Function} callInfo.callback Функция обратного вызова.
			 * @param {Boolean} callInfo.callback.canGetCallRecords Признак, что есть возможность получать записи
			 * разговоров звонка.
			 * @param {String[]} callInfo.callback.callRecords (optional) Массив ссылок на записи разговоров звонка.
			 */
			onGetCallRecords: function(callInfo) {
				var callId = callInfo.callId;
				var callback = callInfo.callback;
				if (Ext.isEmpty(callId)) {
					callback(false);
					return;
				}
				var canGetCallRecords = this.get("IsConnected") && this.getCanGetCallRecords();
				if (!canGetCallRecords) {
					callback(canGetCallRecords);
					return;
				}
				this.queryCallRecords(callId, function(callRecords) {
					callback(canGetCallRecords, callRecords);
				});
			},

			/**
			 * Срабатывает при удалении звонка из списка активных @link Terrasoft.CtiModel#activeCalls.
			 * @private
			 */
			onCtiPanelActiveCallRemoved: function() {
				if (this.activeCalls.isEmpty()) {
					this.onCtiPanelActiveCallsEmpty();
				}
			},

			/**
			 * Срабатывает, если очистилась коллекция активных звонков @link Terrasoft.CtiModel#activeCalls.
			 * @private
			 */
			onCtiPanelActiveCallsEmpty: function() {
				this.clearPhoneNumber();
				this.set("IsTransferPrepared", false);
				this.set("IsDtmfPrepared", false);
				this.set("DtmfDigits", "");
				var durationTimerIntervalId = this.get("DurationTimerIntervalId");
				clearInterval(durationTimerIntervalId);
				this.set("CommutationStartedOn", null);
				this.set("CallDuration", null);
				this.set("IsVideoHidden", false);
			},

			/**
			 * Срабатывает на событии DTMF набора. Устанавливает в свойство "DtmfDigits" строку из последних набранных
			 * символов.
			 * @param {String} dtmfDigit Символ, нажатый при DTMF наборе.
			 * @private
			 */
			onDtmfEntered: function(dtmfDigit) {
				var dtmfDigits = this.get("DtmfDigits") || "";
				if (dtmfDigits.length >= CtiConstants.DtmfMaxDisplayedDigits) {
					dtmfDigits = dtmfDigits.substr(1);
				}
				this.set("DtmfDigits", dtmfDigits + dtmfDigit);
			},

			/**
			 * Обрабатывает старт webRtc сессии.
			 * @param {String} sessionId Идентификатор webRtc сессии.
			 * @param {Object} config Параметры события.
			 * @param {String} config.mediaElementId Идентификатор элемента dom, в который будет направлены аудио и
			 * видео потоки. Значение должно быть установлено в обработчике события.
			 * @private
			 */
			onWebRtcStarted: function(sessionId, config) {
				var videoContainer = Ext.getCmp("ctiPanelVideoContainer");
				if (!videoContainer) {
					return;
				}
				////TODO #CC-724 Webitel. Видеозвонки. Не работать с dom напрямую
				var videoNotSupportedMessage = this.getResourceString("VideoNotSupportedMessage");
				var videoTag = Ext.DomHelper.append(videoContainer.id, {
					tag: "video",
					id:  Ext.String.htmlEncode(sessionId),
					controls: "controls",
					html:  Ext.String.htmlEncode(videoNotSupportedMessage)
				});
				config.mediaElementId = videoTag.id;
			},

			/**
			 * Срабатывает при старте видеопотока webRtc сессии.
			 * @param {String} sessionId Идентификатор webRtc сессии.
			 * @private
			 */
			onWebRtcVideoStarted: function(sessionId) {
				////TODO #CC-724 Webitel. Видеозвонки. Не работать с dom напрямую
				var videoTag = Ext.get(sessionId);
				if (videoTag) {
					videoTag.addCls(this.useVideoMediaElementClassName);
				}
			},

			/**
			 * Срабатывает при завершении webRtc сессии.
			 * @param {String} sessionId Идентификатор webRtc сессии.
			 * @private
			 */
			onWebRtcDestroyed: function(sessionId) {
				////TODO #CC-724 Webitel. Видеозвонки. Не работать с dom напрямую
				var videoTag = Ext.get(sessionId);
				if (videoTag) {
					videoTag.remove();
				}
			},

			/**
			 * Обрабатывает изменение признака того, что видео должно быть скрыто.
			 * @private
			 * @param {Backbone.Model} model Модель.
			 * @param {String} isHidden Признак того, что видео должно быть скрыто.
			 */
			onVideoHidden: function(model, isHidden) {
				var container = Ext.getCmp("ctiPanelVideoContainer");
				if (!container || !container.wrapEl) {
					return;
				}
				var containerWrapEl = container.wrapEl;
				if (isHidden) {
					containerWrapEl.addCls("video-hidden");
				} else {
					containerWrapEl.removeCls("video-hidden");
				}
			},

			/**
			 * Обрабатывает изменение состояния использования видео во время звонка.
			 * @private
			 * @param {Boolean} isVideoActive Признак использования видео во время звонка.
			 */
			onSetVideoState: function(isVideoActive) {
				this.set("IsVideoHidden", !isVideoActive);
			}

			//endregion

		});
	});


				// Autogenerated Code for schema CtiPanelModelUtilities (End)
// Autogenerated Code for schema CtiPanel (Start)
define('CtiPanelResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={
	ConnectionConfigEmptyError: 'Ошибка получения параметров подключения к телефонии. Укажите параметры в меню \"Настройки параметров Call Centre\" в профиле пользователя',
	AccountNameLabelCaption: 'Контрагент',
	JobLabelCaption: 'Должность',
	AccountTypeLabelCaption: 'Тип',
	CityLabelCaption: 'Город',
	CallDurationLabelCaption: 'Длительность:',
	DepartmentLabelCaption: 'Департамент',
	NumberLabelCaption: 'Номер',
	AnswerButtonHint: 'Ответить на звонок',
	DropButtonHint: 'Завершить звонок',
	HoldButtonHint: 'Поставить на удержание',
	UnholdButtonHint: 'Снять с удержания',
	PrepareTransferButtonHint: 'Перевести звонок',
	CompleteTransferButtonHint: 'Соединить абонентов',
	CancelTransferButtonHint: 'Отменить перевод',
	CompleteTransferTip: 'Нажмите, для соединения абонентов',
	DtmfButtonHint: 'Панель набора номера',
	MuteButtonHint: 'Отключить звук',
	UnmuteButtonHint: 'Включить звук',
	VideoOnButtonHint: 'Включить видео',
	VideoOffButtonHint: 'Отключить видео',
	IdentificationItemsControlGroupCaption: 'Результаты поиска',
	SubscriberPanelNotFoundExceptionMessage: 'Не удалось найти панель идентифицированного абонента по идентификатору \'{0}\'',
	SelectAnotherSubscriberCaption: 'Выбрать другую запись',
	IdentificationSavingMessage: 'Сохранение идентификации звонка с id \'{0}\'',
	IdentificationFieldSavingMessage: 'Поле \'{0}\', значение \'{1}\'',
	IdentificationSavedSuccessfullyMessage: 'выполнено успешно',
	IdentificationSavedFailedMessage: 'выполнено с ошибкой',
	PhoneNumberCantBeEmptyMessage: 'Поле Номер не может быть пустым',
	EmptySearchResultMessage: 'Нет записей удовлетворяющих условиям поиска.',
	VideoNotSupportedMessage: 'Ваш браузер не поддерживает отображение видео',
	EmptyHistoryMessage: 'Узнайте больше о работе со звонками в {0}Академии{1}.',
	EmptyHistoryTitleLabel: 'Похоже, вы еще не совершали звонков'
};
var localizableImages={
	'SwitchAbonentDropBoxIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CtiPanel', resourceItemName: 'SwitchAbonentDropBoxIcon' }},
	'TransferringArrows': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CtiPanel', resourceItemName: 'TransferringArrows' }},
	'MakeCallButtonIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CtiPanel', resourceItemName: 'MakeCallButtonIcon' }},
	'ContactEmptyPhoto': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CtiPanel', resourceItemName: 'ContactEmptyPhoto' }},
	'AnswerButtonLongIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CtiPanel', resourceItemName: 'AnswerButtonLongIcon' }},
	'DropButtonLongIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CtiPanel', resourceItemName: 'DropButtonLongIcon' }},
	'DropButtonShortIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CtiPanel', resourceItemName: 'DropButtonShortIcon' }},
	'HoldButtonIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CtiPanel', resourceItemName: 'HoldButtonIcon' }},
	'HoldButtonIconDisabled': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CtiPanel', resourceItemName: 'HoldButtonIconDisabled' }},
	'UnholdButtonIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CtiPanel', resourceItemName: 'UnholdButtonIcon' }},
	'PrepareTransferButtonIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CtiPanel', resourceItemName: 'PrepareTransferButtonIcon' }},
	'PrepareTransferButtonIconDisabled': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CtiPanel', resourceItemName: 'PrepareTransferButtonIconDisabled' }},
	'CompleteTransferButtonIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CtiPanel', resourceItemName: 'CompleteTransferButtonIcon' }},
	'CancelTransferButtonIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CtiPanel', resourceItemName: 'CancelTransferButtonIcon' }},
	'DtmfButtonIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CtiPanel', resourceItemName: 'DtmfButtonIcon' }},
	'DtmfButtonIconPressed': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CtiPanel', resourceItemName: 'DtmfButtonIconPressed' }},
	'MuteButtonIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CtiPanel', resourceItemName: 'MuteButtonIcon' }},
	'MuteButtonIconDisabled': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CtiPanel', resourceItemName: 'MuteButtonIconDisabled' }},
	'VideoOffButtonIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CtiPanel', resourceItemName: 'VideoOffButtonIcon' }},
	'VideoOffButtonIconDisabled': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CtiPanel', resourceItemName: 'VideoOffButtonIconDisabled' }},
	'VideoOnButtonIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CtiPanel', resourceItemName: 'VideoOnButtonIcon' }},
	'UnidentifiedSubscriberPhoto': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CtiPanel', resourceItemName: 'UnidentifiedSubscriberPhoto' }},
	'AccountIdentifiedPhoto': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CtiPanel', resourceItemName: 'AccountIdentifiedPhoto' }},
	'ContactEmptyPhotoWhite': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CtiPanel', resourceItemName: 'ContactEmptyPhotoWhite' }},
	'EmptySearchResultImage': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CtiPanel', resourceItemName: 'EmptySearchResultImage' }}
};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define('CtiPanelStructure', ['CtiPanelResources'], function(resources) {return {schemaUId:'301b2d1f-5901-4fa5-b7b5-40b18b6cfdaa',schemaCaption: 'CTI панель', parentSchemaName: '', schemaName:'CtiPanel',parentSchemaUId:'',extendParent:false,type:Terrasoft.SchemaType.EDIT_VIEW_MODEL_SCHEMA,entitySchema:'',name:'',extend:'Terrasoft.model.BaseViewModel',schema:{leftPanel:[],rightPanel:[],actions:[],analytics:[]},methods:{},controlsConfig:{},customBindings:{},bindings:{},schemaDifferences:function(){

}};});
define("CtiPanel", ["terrasoft", "CtiProviderInitializer", "CtiBaseHelper", "CtiPanelResources", "CtiConstants",
		"CtiPanelModelUtilities", "CtiPanelUtils", "CtiPanelIdentificationUtilities", "CtiContainerListGenerator",
		"CtiContainerList", "SearchEdit", "CtiPanelCommunicationHistoryUtilities", "CtiPanelEmptyHistoryMixin"],
	function(Terrasoft, CtiProviderInitializer, CtiBaseHelper, resources, ctiConstants) {
		return {
			messages: {
				/**
				 * @message CallCustomer
				 * Уведомляет о необходимости звонка клиенту.
				 * @param {Object} Информация о параметрах звонка.
				 */
				"CallCustomer": {
					mode: Terrasoft.MessageMode.PTP,
					direction: Terrasoft.MessageDirectionType.SUBSCRIBE
				},

				/**
				 * @message GetCallRecords
				 * Уведомляет о необходимости получения записей разговоров звонка.
				 * @param {Object} Информация о параметрах звонка.
				 */
				"GetCallRecords": {
					"mode": Terrasoft.MessageMode.PTP,
					"direction": Terrasoft.MessageDirectionType.SUBSCRIBE
				},

				/**
				 * @message SelectCommunicationPanelItem
				 * Выбирает пункт в коммуникационной панели.
				 * @param {Object} Информация о выбранном пункте коммуникационной панели.
				 */
				"SelectCommunicationPanelItem": {
					"mode": Terrasoft.MessageMode.PTP,
					"direction": Terrasoft.MessageDirectionType.PUBLISH
				},

				/**
				 * @message CallDurationChanged
				 * Изменяет строку с длительностью соответствующего звонка.
				 * @param {String} Длительность звонка.
				 */
				"CallDurationChanged": {
					"mode": Terrasoft.MessageMode.PTP,
					"direction": Terrasoft.MessageDirectionType.PUBLISH
				},

				/**
				 * @message CtiPanelConnected
				 * Публикация сообщения о загрузке cti панели.
				 */
				"CtiPanelConnected": {
					"mode": Terrasoft.MessageMode.PTP,
					"direction": Terrasoft.MessageDirectionType.PUBLISH
				},

				/**
				 * @message PushHistoryState
				 * Публикация сообщения установки состояния.
				 * @param {Object} Конфигурационный объект нового состояния.
				 */
				"PushHistoryState": {
					"mode": Terrasoft.MessageMode.BROADCAST,
					"direction": Terrasoft.MessageDirectionType.PUBLISH
				},

				/**
				 * @message AgentStateChanged
				 * Сообщение изменения текущего статуса оператора.
				 * @param {String} Длительность звонка.
				 */
				"AgentStateChanged": {
					"mode": Terrasoft.MessageMode.PTP,
					"direction": Terrasoft.MessageDirectionType.PUBLISH
				}
			},
			mixins: {
				/**
				 * Миксин модели представления.
				 */
				CtiPanelModelUtilities: Terrasoft.CtiPanelModelUtilities,

				/**
				 * Миксин модели динамически генерируемых панелей Cti панели.
				 */
				CtiPanelUtils: Terrasoft.CtiPanelUtils,

				/**
				 * Миксин идентификации абонента.
				 */
				CtiPanelIdentificationUtilities: Terrasoft.CtiPanelIdentificationUtilities,

				/**
				 * Миксин истории звонков.
				 */
				CtiPanelCommunicationHistoryUtilities: Terrasoft.CtiPanelCommunicationHistoryUtilities,

				/**
				 * Миксин для показа сообщения при пустой истории звонков.
				 */
				CtiPanelEmptyHistoryMixin: Terrasoft.CtiPanelEmptyHistoryMixin
			},
			attributes: {

				/**
				 * Набранный номер телефона.
				 * @private
				 * @type {String}
				 */
				"PhoneNumber": {
					"dataValueType": Terrasoft.DataValueType.TEXT,
					"type": Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
					"value": ""
				},

				/**
				 * Предыдущее значение в поле Номер телефона. Необходимо, чтобы избежать избыточного числа срабатываний
				 * обработчиков изменения значения номера телефона.
				 * @private
				 * @type {String}
				 */
				"PhoneNumberOldValue": {
					"dataValueType": Terrasoft.DataValueType.TEXT,
					"type": Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
					"value": ""
				},

				/**
				 * Коллекция со списком событий и их обработчиков, на которые произошла подписка
				 * при создании соединения.
				 * @private
				 * @type {Object[]}
				 */
				"SubscribedEvents": {
					"value": null
				},

				/**
				 * Коллекция элементов с данными идентификации для различных типов абонентов.
				 * Ключ - тип абонента, значение - массив элементов идентификации, которые следует отобразить.
				 * @private
				 * @type {Object}
				 */
				"IdentificationDataLabels": {
					"dataValueType": Terrasoft.DataValueType.CUSTOM_OBJECT,
					"value": {
						"Contact": ["AccountName", "Job"],
						"Account": ["AccountType", "City"],
						"Employee": ["Department"]
					}
				},

				/**
				 * Количество идентифицированных абонентов основного звонка.
				 * @private
				 * @type {Number}
				 */
				"IdentifiedSubscribersCount": {
					"dataValueType": Terrasoft.DataValueType.INTEGER,
					"value": 0
				},

				/**
				 * Ключ идентифицированного абонента основного звонка в коллекции с данными идентифицированных
				 * абонентов.
				 * @private
				 * @type {String}
				 */
				"IdentifiedSubscriberKey": {
					"dataValueType": Terrasoft.DataValueType.TEXT,
					"value": ""
				},

				/**
				 * Количество идентифицированных абонентов консультационного звонка.
				 * @private
				 * @type {Number}
				 */
				"IdentifiedConsultSubscribersCount": {
					"dataValueType": Terrasoft.DataValueType.INTEGER,
					"value": 0
				},

				/**
				 * Ключ идентифицированного абонента консультационного звонка в коллекции с данными идентифицированных
				 * абонентов.
				 * @private
				 * @type {String}
				 */
				"IdentifiedConsultSubscriberKey": {
					"dataValueType": Terrasoft.DataValueType.TEXT,
					"value": ""
				},

				/**
				 * Строка отображающая длительность разговора основного звонка в формате mm:ss.
				 * @private
				 * @type {String}
				 */
				"CallDuration": {
					"dataValueType": Terrasoft.DataValueType.TEXT,
					"type": Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
					"value": null
				},

				/**
				 * Время начала разговора.
				 * @private
				 * @type {String}
				 */
				"CommutationStartedOn": {
					"dataValueType": Terrasoft.DataValueType.DATE_TIME,
					"type": Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
					"value": null
				},

				/**
				 * Идентификатор таймера.
				 * @private
				 * @type {String}
				 */
				"DurationTimerIntervalId": {
					"dataValueType": Terrasoft.DataValueType.TEXT,
					"type": Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
					"value": ""
				},

				/**
				 * Строка отображающая длительность разговора консультационного звонка в формате mm:ss.
				 * @private
				 * @type {String}
				 */
				"ConsultCallDuration": {
					"dataValueType": Terrasoft.DataValueType.TEXT,
					"type": Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
					"value": "00:00"
				},

				/**
				 * Была запрошена подготовка к началу перевода.
				 * @private
				 * @type {Boolean}
				 */
				"IsTransferPrepared": {
					"dataValueType": Terrasoft.DataValueType.BOOLEAN,
					"value": false
				},

				/**
				 * Идентификатор абонента, которого следует сделать идентифицируемым, сразу по завершению
				 * процесса идентификации.
				 * @private
				 * @type {String}
				 */
				"AdvisedIdentifiedSubscriber": {
					"dataValueType": Terrasoft.DataValueType.TEXT,
					"type": Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
					"value": ""
				},

				/**
				 * Коллекция панелей идентифицированных абонентов основного звонка.
				 * @private
				 * @type {Terrasoft.Collection}
				 */
				"IdentifiedSubscriberPanelCollection": {
					"dataValueType": Terrasoft.DataValueType.COLLECTION
				},

				/**
				 * Коллекция панелей идентифицированных абонентов консультационного звонка.
				 * @private
				 * @type {Terrasoft.Collection}
				 */
				"IdentifiedConsultSubscriberPanelCollection": {
					"dataValueType": Terrasoft.DataValueType.COLLECTION
				},

				/**
				 * Коллекция панелей с результатами поиска абонента.
				 * @private
				 * @type {Terrasoft.Collection}
				 */
				"SearchResultPanelCollection": {
					"dataValueType": Terrasoft.DataValueType.COLLECTION
				},

				/**
				 * Коллекция панелей с историей звонков.
				 * @private
				 * @type {Terrasoft.Collection}
				 */
				"CommunicationHistoryPanelCollection": {
					"dataValueType": Terrasoft.DataValueType.COLLECTION
				},

				/**
				 * Признак, что поиск абонентов завершен и
				 * не вернул записей, соответствующих установленным фильтрам.
				 * @private
				 * @type {Boolean}
				 */
				"IsSearchFinishedAndResultEmpty": {
					"dataValueType": Terrasoft.DataValueType.BOOLEAN,
					"value": false
				},

				/**
				 * Признак того, что колекция абонентов, найденных в результате поиска, пустая.
				 * @private
				 * @type {Boolean}
				 */
				"IsSearchResultPanelCollectionEmpty": {
					"dataValueType": Terrasoft.DataValueType.BOOLEAN,
					"value": true
				},

				/**
				 * Строка символов, которые были отправлены через DTMF набор.
				 * @private
				 * @type {String}
				 */
				"DtmfDigits": {
					"dataValueType": Terrasoft.DataValueType.TEXT,
					"type": Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
					"value": ""
				},

				/**
				 * Была запрошена подготовка к началу DTMF набора.
				 * @private
				 * @type {Boolean}
				 */
				"IsDtmfPrepared": {
					"dataValueType": Terrasoft.DataValueType.BOOLEAN,
					"value": false
				},

				/**
				 * Настройки телефонии.
				 * @private
				 * @type {Object}
				 */
				"CtiSettings": {
					"dataValueType": Terrasoft.DataValueType.Object,
					"value": null
				},

				/**
				 * Поддерживает ли провайдер телефонии передачу видео.
				 * @private
				 * @type {Boolean}
				 */
				"IsVideoSupported": {
					"dataValueType": Terrasoft.DataValueType.BOOLEAN,
					"value": false
				},

				/**
				 * Скрыт ли контейнер с видео.
				 * @private
				 * @type {Boolean}
				 */
				"IsVideoHidden": {
					"dataValueType": Terrasoft.DataValueType.BOOLEAN,
					"value": false
				},

				/**
				 * Признак, указывающий на необходимость отображения сообщения о пустой истории.
				 * @private
				 * @type {Boolean}
				 */
				"DisplayEmptyHistoryMessage": {
					"dataValueType": Terrasoft.DataValueType.BOOLEAN,
					"value": false
				}
			},
			methods: {

				//region Methods: Private

				/**
				 * Выводит сообщение об ошибке в консоль.
				 * @private
				 * @param {Object} message Сообщение.
				 */
				logError: function(message) {
					var console = Ext.global.console;
					if (console && console.error) {
						console.error(message);
					}
				},

				//endregion

				//region Methods: Protected

				/**
				 * Инициализирует коллекции схемы.
				 * @protected
				 */
				initCollections: function() {
					this.set("SearchResultPanelCollection", this.Ext.create("Terrasoft.Collection"));
					this.initCallHistoryCollection();
					this.set("IdentifiedSubscriberPanelCollection",
						this.Ext.create("Terrasoft.BaseViewModelCollection"));
					this.set("IdentifiedConsultSubscriberPanelCollection",
						this.Ext.create("Terrasoft.BaseViewModelCollection"));
				},

				/**
				 * Инициализирует коллекцию истории звонков и выполняет подписку на ее изменение.
				 * @protected
				 */
				initCallHistoryCollection: function() {
					var collection = this.Ext.create("Terrasoft.Collection");
					collection.on("add", this.onCallHistoryChanged, this);
					collection.on("dataLoaded", this.onCallHistoryChanged, this);
					collection.on("remove", this.onCallHistoryChanged, this);
					collection.on("clear", this.onCallHistoryChanged, this);
					this.set("CommunicationHistoryPanelCollection", collection);
				},

				/**
				 * Обрабатывает изменение коллекции истории звонков.
				 * @protected
				 */
				onCallHistoryChanged: function() {
					var collection = this.get("CommunicationHistoryPanelCollection");
					this.set("DisplayEmptyHistoryMessage", collection.isEmpty());
				},

				/**
				 * Создает подключение к телефонии.
				 * @protected
				 */
				createConnection: function() {
					this.subscribeEvents();
					this.connect(null, function(success, error) {
						if (error) {
							this.onConnectError(error);
						}
					}.bind(this));
				},

				/**
				 * Инициализирует Cti модель.
				 * @param {Terrasoft.BaseCtiProvider} provider Провайдер функций телефонии.
				 * @protected
				 */
				initializeCtiModel: function(provider) {
					this.ctiProvider = provider;
					this.createConnection();
				},

				/**
				 * Подписывает на события Cti модели.
				 * @protected
				 */
				subscribeEvents: function() {
					var ctiPanelEvents = [
						{
							eventName: "connected",
							eventHandler: this.onConnected
						},
						{
							eventName: "commutationStarted",
							eventHandler: this.onCommutationStarted
						},
						{
							eventName: "change:CurrentCallNumber",
							eventHandler: this.onChangeCurrentCallNumber
						},
						{
							eventName: "change:CurrentCall",
							eventHandler: this.onChangeCurrentCall
						},
						{
							eventName: "change:CallDuration",
							eventHandler: this.onChangeCallDuration
						},
						{
							eventName: "change:ConsultCallNumber",
							eventHandler: this.onChangeConsultCallNumber
						},
						{
							eventName: "change:IsConsulting",
							eventHandler: this.onChangeIsConsulting
						},
						{
							eventName: "change:AgentState",
							eventHandler: this.onAgentStateCodeChanged
						},
						{
							eventName: "change:IdentifiedSubscriberKey",
							eventHandler: this.onIdentifiedSubscriberKeyChanged
						},
						{
							eventName: "change:IdentifiedConsultSubscriberKey",
							eventHandler: this.onIdentifiedConsultSubscriberKeyChanged
						},
						{
							eventName: "callSaved",
							eventHandler: this.onCallSavedEvent
						},
						{
							eventName: "dtmfEntered",
							eventHandler: this.onDtmfEntered
						},
						{
							eventName: "webRtcStarted",
							eventHandler: this.onWebRtcStarted
						},
						{
							eventName: "webRtcVideoStarted",
							eventHandler: this.onWebRtcVideoStarted
						},
						{
							eventName: "webRtcDestroyed",
							eventHandler: this.onWebRtcDestroyed
						},
						{
							eventName: "change:IsVideoHidden",
							eventHandler: this.onVideoHidden
						}
					];
					Terrasoft.each(ctiPanelEvents, function(item) {
						this.on(item.eventName, item.eventHandler, this);
					}, this);
					this.set("SubscribedEvents", ctiPanelEvents);
					this.sandbox.subscribe("CallCustomer", this.onCallCustomer.bind(this));
					this.sandbox.subscribe("GetCallRecords", this.onGetCallRecords.bind(this),
						[ctiConstants.CallRecordsContextMessageId]);
					this.activeCalls.on("clear", this.onCtiPanelActiveCallsEmpty, this);
					this.activeCalls.on("remove", this.onCtiPanelActiveCallRemoved, this);
				},

				/**
				 * Обрабатывает ошибку при подключении к телефонии.
				 * @protected
				 * @param {Object} error Объект ошибки.
				 * @param {Terrasoft.MsgErrorType} error.errorType Тип ошибки.
				 * @param {String} error.internalErrorCode Код ошибки.
				 * @param {String} error.data Текст ошибки.
				 * @param {String} error.source Источник ошибки.
				 */
				onConnectError: function(error) {
					if (error.errorType === Terrasoft.MsgErrorType.CONNECTION_CONFIG_ERROR) {
						this.logError(this.get("Resources.Strings.ConnectionConfigEmptyError"));
					}
				},

				/**
				 * Определяет необходимость показа сообщения о пустой истории звонков.
				 * @return {Boolean} Если история звонков отображается и она пустая, то true.
				 * @protected
				 */
				isEmptyCallHistoryMessageVisible: function() {
					return this.getIsCommunicationHistoryVisible() && this.get("DisplayEmptyHistoryMessage");
				},

				//endregion

				//region Methods: Public

				/**
				 * Инициализация схемы.
				 * @public
				 */
				init: function() {
					this.initCollections();
					this.callParent(arguments);
					var initialize = function() {
						CtiBaseHelper.queryCtiSettings(function(ctiSettings) {
							this.set("CtiSettings", ctiSettings);
							CtiProviderInitializer.initializeCtiProvider(ctiSettings.ctiProviderName,
								this.initializeCtiModel.bind(this));
							this.loadCommunicationHistory();
						}.bind(this));
					}.bind(this);
					if (this.get("Restored") !== true) {
						this.generateIdentifiedSubscriberPanelItemConfig(function() {
							this.generateСommunicationPanelItemConfig(function() {
								this.generateSearchResultPanelItemConfig(function() {
									this.generateCommunicationHistoryItemPanelItemConfig(initialize);
								}.bind(this));
							}.bind(this));
						}.bind(this));
					}
					this.on("destroyed", this.onDestroyed);
					this.initHelpUrl();
					this.emptyMessageConfig = {
						title: this.get("Resources.Strings.EmptyHistoryTitleLabel"),
						description: this.get("Resources.Strings.EmptyHistoryMessage"),
						image: this.get("Resources.Images.EmptySearchResultImage")
					};
				},

				/**
				 * Обработка события уничтожения схемы.
				 * @public
				 */
				onDestroyed: function() {
					var ctiPanelEvents = this.get("SubscribedEvents");
					Terrasoft.each(ctiPanelEvents, function(item) {
						this.un(item.eventName, item.eventHandler, this);
					}, this);
					this.set("SubscribedEvents", "");
					this.activeCalls.un("clear", this.onCtiPanelActiveCallsEmpty, this);
					this.activeCalls.un("remove", this.onCtiPanelActiveCallRemoved, this);
					var collection = this.get("CommunicationHistoryPanelCollection");
					collection.un("add", this.onCallHistoryChanged, this);
					collection.un("dataLoaded", this.onCallHistoryChanged, this);
					collection.un("clear", this.onCallHistoryChanged, this);
					collection.un("remove", this.onCallHistoryChanged, this);
				}

				//endregion

			},
			diff: [
				{
					"operation": "insert",
					"name": "ctiPanelMainContainer",
					"values": {
						"id": "ctiPanelMainContainer",
						"selectors": {"wrapEl": "#ctiPanelMainContainer"},
						"itemType": Terrasoft.ViewItemType.CONTAINER,
						"wrapClass": ["ctiPanelMain"],
						"items": []
					}
				},
				{
					"operation": "insert",
					"name": "ctiPanelVideoContainer",
					"parentName": "ctiPanelMainContainer",
					"propertyName": "items",
					"values": {
						"id": "ctiPanelVideoContainer",
						"selectors": {"wrapEl": "#ctiPanelVideoContainer"},
						"itemType": Terrasoft.ViewItemType.CONTAINER,
						"wrapClass": ["ctiPanelVideo"],
						"items": []
					}
				},

				//region current call identification controls

				{
					"operation": "insert",
					"name": "IdentificationPanel",
					"parentName": "ctiPanelMainContainer",
					"propertyName": "items",
					"values": {
						"id": "IdentificationPanel",
						"markerValue": {"bindTo": "CurrentCallNumber"},
						"selectors": {"wrapEl": "#IdentificationPanel"},
						"itemType": Terrasoft.ViewItemType.CONTAINER,
						"wrapClass": ["identification-panel"],
						"visible": {"bindTo": "getIsCallExists"},
						"items": []
					}
				},
				{
					"operation": "insert",
					"name": "IdentificationPanelLeft",
					"parentName": "IdentificationPanel",
					"propertyName": "items",
					"values": {
						"id": "IdentificationPanelLeft",
						"selectors": {"wrapEl": "#IdentificationPanelLeft"},
						"itemType": Terrasoft.ViewItemType.CONTAINER,
						"wrapClass": ["identification-panel-left"],
						"items": []
					}
				},
				{
					"operation": "insert",
					"name": "IdentificationPanelRight",
					"parentName": "IdentificationPanel",
					"propertyName": "items",
					"values": {
						"id": "IdentificationPanelRight",
						"selectors": {"wrapEl": "#IdentificationPanelRight"},
						"itemType": Terrasoft.ViewItemType.CONTAINER,
						"wrapClass": ["identification-panel-right"],
						"items": []
					}
				},
				{
					"operation": "insert",
					"name": "IdentificationDataPanel",
					"parentName": "IdentificationPanelRight",
					"propertyName": "items",
					"values": {
						"id": "IdentificationDataPanel",
						"selectors": {"wrapEl": "#IdentificationDataPanel"},
						"itemType": Terrasoft.ViewItemType.CONTAINER,
						"wrapClass": ["identification-data-panel"],
						"items": []
					}
				},
				{
					"operation": "insert",
					"name": "SubscriberPhoto",
					"parentName": "IdentificationPanelLeft",
					"propertyName": "items",
					"values": {
						"id": "SubscriberPhoto",
						"itemType": Terrasoft.ViewItemType.BUTTON,
						"imageConfig": {"bindTo": "getSubscriberPhoto"},
						"classes": {"wrapperClass": ["subscriber-photo"]},
						"markerValue": "SubscriberPhoto",
						"selectors": {"wrapEl": "#SubscriberPhoto"},
						"style": Terrasoft.controls.ButtonEnums.style.TRANSPARENT,
						"tag": "Photo"
					}
				},
				{
					"operation": "insert",
					"name": "TransferringArrows",
					"parentName": "IdentificationPanelLeft",
					"propertyName": "items",
					"values": {
						"id": "TransferringArrows",
						"itemType": Terrasoft.ViewItemType.BUTTON,
						"imageConfig": {"bindTo": "Resources.Images.TransferringArrows"},
						"classes": {"wrapperClass": ["transferring-arrows"]},
						"markerValue": "TransferringArrows",
						"selectors": {"wrapEl": "#TransferringArrows"},
						"style": Terrasoft.controls.ButtonEnums.style.TRANSPARENT,
						"visible": {"bindTo": "IsConsulting"}
					}
				},
				{
					"operation": "insert",
					"name": "PrimaryCallInfo",
					"parentName": "IdentificationPanelRight",
					"propertyName": "items",
					"values": {
						"id": "PrimaryCallInfo",
						"itemType": Terrasoft.ViewItemType.LABEL,
						"caption": {"bindTo": "CurrentCallNumber"},
						"markerValue": "PrimaryCallInfo",
						"classes": {"labelClass": "primary-call-info"},
						"visible": {"bindTo": "getIsSubscriberUnknown"}
					}
				},
				{
					"operation": "insert",
					"name": "SubscriberName",
					"parentName": "IdentificationDataPanel",
					"propertyName": "items",
					"values": {
						"id": "SubscriberName",
						"markerValue": {"bindTo": "getSubscriberData"},
						"itemType": Terrasoft.ViewItemType.BUTTON,
						"caption": {"bindTo": "getSubscriberData"},
						"hint": {"bindTo": "getSubscriberData"},
						"tag": "Name",
						"visible": {
							"bindTo": "IdentifiedSubscriberKey",
							"bindConfig": {"converter": "getIsSubscriberIdentified"}
						},
						"click": {"bindTo": "onSubscriberNameClick"},
						"classes": {"wrapperClass": ["subsciber-menu-button"]},
						"style": Terrasoft.controls.ButtonEnums.style.TRANSPARENT,
						"menu": {
							"items": [
								{
									"id": "SelectAnotherSubscriberMenuItem",
									"caption": {"bindTo": "Resources.Strings.SelectAnotherSubscriberCaption"},
									"markerValue": "SelectAnotherSubscriberMenuItem",
									"click": {"bindTo": "clearSubscriber"}
								}
							]
						}
					}
				},
				{
					"operation": "insert",
					"name": "SubscriberNumberInfo",
					"parentName": "IdentificationPanelRight",
					"propertyName": "items",
					"values": {
						"id": "SubscriberNumberInfo",
						"selectors": {"wrapEl": "#SubscriberNumberInfo"},
						"itemType": Terrasoft.ViewItemType.CONTAINER,
						"markerValue": "SubscriberNumberInfo",
						"items": [
							{
								"id": "CommunicationTypeLabel",
								"itemType": Terrasoft.ViewItemType.LABEL,
								"classes": {"labelClass": ["label-caption"]},
								"markerValue": {"bindTo": "getSubscriberData"},
								"selectors": {"wrapEl": "#CommunicationTypeLabel"},
								"caption": {"bindTo": "getSubscriberData"},
								"tag": "CommunicationType"
							},
							{
								"id": "CallNumber",
								"itemType": Terrasoft.ViewItemType.LABEL,
								"classes": {"labelClass": ["subscriber-info"]},
								"markerValue": {"bindTo": "getSubscriberData"},
								"selectors": {"wrapEl": "#CallNumber"},
								"caption": {"bindTo": "getSubscriberData"},
								"tag": "Number"
							}
						]
					}
				},
				{
					"operation": "insert",
					"name": "AccountName",
					"parentName": "IdentificationDataPanel",
					"propertyName": "items",
					"values": {
						"generator": "CtiBaseHelper.getIdentificationDataLabel"
					}
				},
				{
					"operation": "insert",
					"name": "SubscriberJob",
					"parentName": "IdentificationDataPanel",
					"propertyName": "items",
					"values": {
						"tag": "Job",
						"generator": "CtiBaseHelper.getIdentificationDataLabel"
					}
				},
				{
					"operation": "insert",
					"name": "SubscriberDepartment",
					"parentName": "IdentificationDataPanel",
					"propertyName": "items",
					"values": {
						"tag": "Department",
						"generator": "CtiBaseHelper.getIdentificationDataLabel"
					}
				},
				{
					"operation": "insert",
					"name": "AccountType",
					"parentName": "IdentificationDataPanel",
					"propertyName": "items",
					"values": {
						"generator": "CtiBaseHelper.getIdentificationDataLabel"
					}
				},
				{
					"operation": "insert",
					"name": "AccountCity",
					"parentName": "IdentificationDataPanel",
					"propertyName": "items",
					"values": {
						"tag": "City",
						"generator": "CtiBaseHelper.getIdentificationDataLabel"
					}
				},
				{
					"operation": "insert",
					"name": "CallDurationInfo",
					"parentName": "IdentificationPanelRight",
					"propertyName": "items",
					"values": {
						"id": "CallDurationInfo",
						"selectors": {"wrapEl": "#CallDurationInfo"},
						"itemType": Terrasoft.ViewItemType.CONTAINER,
						"visible": {"bindTo": "getIsCallDurationVisible"},
						"classes": {
							wrapClassName: ["call-duration-container"]
						},
						"items": [
							{
								"id": "CallDurationLabel",
								"itemType": Terrasoft.ViewItemType.LABEL,
								"classes": {"labelClass": ["label-caption"]},
								"markerValue": "CallDurationLabel",
								"selectors": {"wrapEl": "#CallDurationLabel"},
								"caption": {"bindTo": "Resources.Strings.CallDurationLabelCaption"}
							},
							{
								"id": "CallDuration",
								"itemType": Terrasoft.ViewItemType.LABEL,
								"classes": {"labelClass": ["call-duration"]},
								"markerValue": "CallDuration",
								"selectors": {"wrapEl": "#CallDuration"},
								"caption": {"bindTo": "CallDuration"}
							}
						]
					}
				},

				//endregion

				//region consult call identification controls

				{
					"operation": "insert",
					"name": "ConsultIdentificationPanel",
					"parentName": "ctiPanelMainContainer",
					"propertyName": "items",
					"values": {
						"id": "ConsultIdentificationPanel",
						"markerValue": {"bindTo": "ConsultCallNumber"},
						"selectors": {"wrapEl": "#ConsultIdentificationPanel"},
						"itemType": Terrasoft.ViewItemType.CONTAINER,
						"wrapClass": ["identification-panel", "consult-identification-panel"],
						"visible": {"bindTo": "IsConsulting"},
						"items": []
					}
				},
				{
					"operation": "insert",
					"name": "ConsultIdentificationPanelLeft",
					"parentName": "ConsultIdentificationPanel",
					"propertyName": "items",
					"values": {
						"id": "ConsultIdentificationPanelLeft",
						"selectors": {"wrapEl": "#ConsultIdentificationPanelLeft"},
						"itemType": Terrasoft.ViewItemType.CONTAINER,
						"wrapClass": ["identification-panel-left"],
						"items": []
					}
				},
				{
					"operation": "insert",
					"name": "ConsultIdentificationPanelRight",
					"parentName": "ConsultIdentificationPanel",
					"propertyName": "items",
					"values": {
						"id": "ConsultIdentificationPanelRight",
						"selectors": {"wrapEl": "#ConsultIdentificationPanelRight"},
						"itemType": Terrasoft.ViewItemType.CONTAINER,
						"wrapClass": ["identification-panel-right"],
						"items": []
					}
				},
				{
					"operation": "insert",
					"name": "ConsultIdentificationDataPanel",
					"parentName": "ConsultIdentificationPanelRight",
					"propertyName": "items",
					"values": {
						"id": "ConsultIdentificationDataPanel",
						"selectors": {"wrapEl": "#ConsultIdentificationDataPanel"},
						"itemType": Terrasoft.ViewItemType.CONTAINER,
						"wrapClass": ["identification-data-panel"],
						"items": []
					}
				},
				{
					"operation": "insert",
					"name": "ConsultSubscriberPhoto",
					"parentName": "ConsultIdentificationPanelLeft",
					"propertyName": "items",
					"values": {
						"id": "ConsultSubscriberPhoto",
						"itemType": Terrasoft.ViewItemType.BUTTON,
						"imageConfig": {"bindTo": "getConsultSubscriberPhoto"},
						"classes": {"wrapperClass": ["subscriber-photo"]},
						"markerValue": "ConsultSubscriberPhoto",
						"selectors": {"wrapEl": "#ConsultSubscriberPhoto"},
						"style": Terrasoft.controls.ButtonEnums.style.TRANSPARENT,
						"tag": "Photo"
					}
				},
				{
					"operation": "insert",
					"name": "ConsultCallInfo",
					"parentName": "ConsultIdentificationPanelRight",
					"propertyName": "items",
					"values": {
						"id": "ConsultCallInfo",
						"itemType": Terrasoft.ViewItemType.LABEL,
						"caption": {"bindTo": "ConsultCallNumber"},
						"markerValue": "ConsultCallInfo",
						"classes": {"labelClass": "primary-call-info"},
						"visible": {"bindTo": "getIsConsultSubscriberUnknown"}
					}
				},
				{
					"operation": "insert",
					"name": "ConsultSubscriberName",
					"parentName": "ConsultIdentificationDataPanel",
					"propertyName": "items",
					"values": {
						"id": "ConsultSubscriberName",
						"markerValue": {"bindTo": "getConsultSubscriberData"},
						"itemType": Terrasoft.ViewItemType.BUTTON,
						"caption": {"bindTo": "getConsultSubscriberData"},
						"hint": {"bindTo": "getConsultSubscriberData"},
						"tag": "Name",
						"visible": {
							"bindTo": "IdentifiedConsultSubscriberKey",
							"bindConfig": {"converter": "getIsSubscriberIdentified"}
						},
						"click": {"bindTo": "onConsultSubscriberNameClick"},
						"classes": {"wrapperClass": ["subsciber-menu-button"]},
						"style": Terrasoft.controls.ButtonEnums.style.TRANSPARENT,
						"menu": {
							"items": [
								{
									"id": "SelectAnotherConsultSubscriberMenuItem",
									"caption": {"bindTo": "Resources.Strings.SelectAnotherSubscriberCaption"},
									"markerValue": "SelectAnotherConsultSubscriberMenuItem",
									"click": {"bindTo": "clearConsultSubscriber"}
								}
							]
						}
					}
				},
				{
					"operation": "insert",
					"name": "ConsultSubscriberNumberInfo",
					"parentName": "ConsultIdentificationPanelRight",
					"propertyName": "items",
					"values": {
						"id": "ConsultSubscriberNumberInfo",
						"selectors": {"wrapEl": "#ConsultSubscriberNumberInfo"},
						"itemType": Terrasoft.ViewItemType.CONTAINER,
						"markerValue": "SubscriberNumberInfo",
						"items": [
							{
								"id": "ConsultCommunicationTypeLabel",
								"itemType": Terrasoft.ViewItemType.LABEL,
								"classes": {"labelClass": ["label-caption"]},
								"markerValue": {"bindTo": "getConsultSubscriberData"},
								"selectors": {"wrapEl": "#ConsultCommunicationTypeLabel"},
								"caption": {"bindTo": "getConsultSubscriberData"},
								"tag": "CommunicationType"
							},
							{
								"id": "ConsultCallNumber",
								"itemType": Terrasoft.ViewItemType.LABEL,
								"classes": {"labelClass": ["subscriber-info"]},
								"markerValue": {"bindTo": "getConsultSubscriberData"},
								"selectors": {"wrapEl": "#ConsultCallNumber"},
								"caption": {"bindTo": "getConsultSubscriberData"},
								"tag": "Number"
							}
						]
					}
				},
				{
					"operation": "insert",
					"name": "ConsultAccountName",
					"parentName": "ConsultIdentificationDataPanel",
					"propertyName": "items",
					"values": {
						"tag": "AccountName",
						"visible": {"bindTo": "getIsConsultInfoLabelVisible"},
						"value": {"bindTo": "getConsultSubscriberData"},
						"generator": "CtiBaseHelper.getIdentificationDataLabel"
					}
				},
				{
					"operation": "insert",
					"name": "ConsultSubscriberJob",
					"parentName": "ConsultIdentificationDataPanel",
					"propertyName": "items",
					"values": {
						"tag": "Job",
						"visible": {"bindTo": "getIsConsultInfoLabelVisible"},
						"value": {"bindTo": "getConsultSubscriberData"},
						"generator": "CtiBaseHelper.getIdentificationDataLabel"
					}
				},
				{
					"operation": "insert",
					"name": "ConsultSubscriberDepartment",
					"parentName": "ConsultIdentificationDataPanel",
					"propertyName": "items",
					"values": {
						"tag": "Department",
						"visible": {"bindTo": "getIsConsultInfoLabelVisible"},
						"value": {"bindTo": "getConsultSubscriberData"},
						"generator": "CtiBaseHelper.getIdentificationDataLabel"
					}
				},
				{
					"operation": "insert",
					"name": "ConsultAccountType",
					"parentName": "ConsultIdentificationDataPanel",
					"propertyName": "items",
					"values": {
						"tag": "AccountType",
						"visible": {"bindTo": "getIsConsultInfoLabelVisible"},
						"value": {"bindTo": "getConsultSubscriberData"},
						"generator": "CtiBaseHelper.getIdentificationDataLabel"
					}
				},
				{
					"operation": "insert",
					"name": "ConsultAccountCity",
					"parentName": "ConsultIdentificationDataPanel",
					"propertyName": "items",
					"values": {
						"tag": "City",
						"visible": {"bindTo": "getIsConsultInfoLabelVisible"},
						"value": {"bindTo": "getConsultSubscriberData"},
						"generator": "CtiBaseHelper.getIdentificationDataLabel"
					}
				},
				{
					"operation": "insert",
					"name": "CallDurationInfo",
					"parentName": "ConsultIdentificationPanelRight",
					"propertyName": "items",
					"values": {
						"id": "CallDurationInfo",
						"selectors": {"wrapEl": "#CallDurationInfo"},
						"itemType": Terrasoft.ViewItemType.CONTAINER,
						"visible": false,
						"classes": {
							wrapClassName: ["call-duration-container"]
						},
						"items": [
							{
								"id": "CallDurationLabel",
								"itemType": Terrasoft.ViewItemType.LABEL,
								"classes": {"labelClass": ["label-caption"]},
								"markerValue": "CallDurationLabel",
								"selectors": {"wrapEl": "#CallDurationLabel"},
								"caption": {"bindTo": "Resources.Strings.CallDurationLabelCaption"}
							},
							{
								"id": "ConsultCallDuration",
								"itemType": Terrasoft.ViewItemType.LABEL,
								"classes": {"labelClass": ["call-duration"]},
								"markerValue": "ConsultCallDuration",
								"selectors": {"wrapEl": "#ConsultCallDuration"},
								"caption": {"bindTo": "ConsultCallDuration"}
							}
						]
					}
				},

				//endregion

				//region call buttons controls

				{
					"operation": "insert",
					"name": "ButtonsPanelWrapper",
					"parentName": "ctiPanelMainContainer",
					"propertyName": "items",
					"values": {
						"markerValue": "ButtonsPanelWrapper",
						"itemType": Terrasoft.ViewItemType.CONTAINER,
						"visible": {"bindTo": "getIsCallExists"},
						"items": []
					}
				},
				{
					"operation": "insert",
					"name": "DtmfButtonsContainer",
					"parentName": "ButtonsPanelWrapper",
					"propertyName": "items",
					"values": {
						"onButtonClick": {"bindTo": "enterDtmf"},
						"dtmfDigitsLabel": {"bindTo": "DtmfDigits"},
						"visible": {"bindTo": "getCanMakeDtmf"},
						"generator": "CtiBaseHelper.getDtmfButtonsContainer"
					}
				},
				{
					"operation": "insert",
					"name": "ButtonsPanel",
					"parentName": "ButtonsPanelWrapper",
					"propertyName": "items",
					"values": {
						"markerValue": "ButtonsPanel",
						"itemType": Terrasoft.ViewItemType.CONTAINER,
						"wrapClass": ["buttons-panel"],
						"items": []
					}
				},
				{
					"operation": "insert",
					"index": 1,
					"name": "HoldButton",
					"parentName": "ButtonsPanel",
					"propertyName": "items",
					"values": {
						"id": "HoldButton",
						"itemType": Terrasoft.ViewItemType.BUTTON,
						"click": {"bindTo": "holdOrUnholdCall"},
						"visible": {"bindTo": "getCanHoldOrUnhold"},
						"imageConfig": {"bindTo": "getHoldButtonImageConfig"},
						"classes": {"wrapperClass": ["call-hold-button"]},
						"markerValue": "HoldButton",
						"selectors": {"wrapEl": "#HoldButton"},
						"style": Terrasoft.controls.ButtonEnums.style.TRANSPARENT,
						"hint": {"bindTo": "getHoldButtonHint"},
						"tag": "HoldButton"
					}
				},
				{
					"operation": "insert",
					"index": 2,
					"name": "PrepareTransferButton",
					"parentName": "ButtonsPanel",
					"propertyName": "items",
					"values": {
						"id": "PrepareTransferButton",
						"itemType": Terrasoft.ViewItemType.BUTTON,
						"click": {"bindTo": "onPrepareTransferButtonClick"},
						"visible": {"bindTo" : "getCanMakeConsultCall"},
						"imageConfig": {"bindTo": "getPrepareTransferButtonImageConfig"},
						"classes": {"wrapperClass": ["call-prepare-transfer-button"]},
						"markerValue": "PrepareTransferButton",
						"selectors": {"wrapEl": "#PrepareTransferButton"},
						"style": Terrasoft.controls.ButtonEnums.style.TRANSPARENT,
						"hint": {"bindTo": "Resources.Strings.PrepareTransferButtonHint"},
						"tag": "PrepareTransferButton"
					}
				},
				{
					"operation": "insert",
					"index": 3,
					"name": "CompleteTransferButton",
					"parentName": "ButtonsPanel",
					"propertyName": "items",
					"values": {
						"id": "CompleteTransferButton",
						"itemType": Terrasoft.ViewItemType.BUTTON,
						"click": {"bindTo": "transferCall"},
						"visible": {"bindTo" : "getCanTransfer"},
						"imageConfig": {"bindTo": "Resources.Images.CompleteTransferButtonIcon"},
						"classes": {"wrapperClass": ["call-complete-transfer-button",
							"t-btn-style-call-button-middle"]},
						"markerValue": "CompleteTransferButton",
						"selectors": {"wrapEl": "#CompleteTransferButton"},
						"style": Terrasoft.controls.ButtonEnums.style.TRANSPARENT,
						"showTooltip": true,
						"tooltipText": { "bindTo": "Resources.Strings.CompleteTransferTip" },
						"tag": "CompleteTransferButton"
					}
				},
				{
					"operation": "insert",
					"index": 4,
					"name": "DtmfButton",
					"parentName": "ButtonsPanel",
					"propertyName": "items",
					"values": {
						"id": "DtmfButton",
						"itemType": Terrasoft.ViewItemType.BUTTON,
						"click": {"bindTo": "onDtmfButtonClick"},
						"visible": {"bindTo": "getCanDtmf"},
						"imageConfig": {"bindTo": "getDtmfButtonImageConfig"},
						"markerValue": "DtmfButton",
						"selectors": {"wrapEl": "#DtmfButton"},
						"style": Terrasoft.controls.ButtonEnums.style.TRANSPARENT,
						"hint": {"bindTo": "Resources.Strings.DtmfButtonHint"},
						"tag": "DtmfButton"
					}
				},
				{
					"operation": "insert",
					"index": 5,
					"name": "MuteButton",
					"parentName": "ButtonsPanel",
					"propertyName": "items",
					"values": {
						"id": "MuteButton",
						"itemType": Terrasoft.ViewItemType.BUTTON,
						"click": {"bindTo": "onMuteButtonClick"},
						"visible": {"bindTo": "getIsMuteButtonVisible"},
						"enabled": {"bindTo": "getIsMuteButtonEnabled"},
						"imageConfig": {"bindTo": "getMuteButtonImageConfig"},
						"classes": {"wrapperClass": ["call-mute-button"]},
						"markerValue": "MuteButton",
						"selectors": {"wrapEl": "#MuteButton"},
						"style": Terrasoft.controls.ButtonEnums.style.TRANSPARENT,
						"hint": {"bindTo": "getMuteButtonHint"},
						"tag": "MuteButton"
					}
				},
				{
					"operation": "insert",
					"index": 6,
					"name": "VideoButton",
					"parentName": "ButtonsPanel",
					"propertyName": "items",
					"values": {
						"id": "VideoButton",
						"itemType": Terrasoft.ViewItemType.BUTTON,
						"click": {"bindTo": "onVideoButtonClick"},
						"visible": {"bindTo": "getIsAdditionalButtonsVisible"},
						"enabled": {"bindTo": "IsVideoSupported"},
						"imageConfig": {"bindTo": "getVideoButtonImageConfig"},
						"classes": {"wrapperClass": ["call-video-button"]},
						"markerValue": "VideoButton",
						"selectors": {"wrapEl": "#VideoButton"},
						"style": Terrasoft.controls.ButtonEnums.style.TRANSPARENT,
						"hint": {"bindTo": "getVideoButtonHint"},
						"tag": "VideoOffButton"
					}
				},
				{
					"operation": "insert",
					"index": 7,
					"name": "CancelTransferButton",
					"parentName": "ButtonsPanel",
					"propertyName": "items",
					"values": {
						"id": "CancelTransferButton",
						"itemType": Terrasoft.ViewItemType.BUTTON,
						"click": {"bindTo": "cancelTransfer"},
						"visible": {"bindTo" : "getCanCancelTransfer"},
						"imageConfig": {"bindTo": "Resources.Images.CancelTransferButtonIcon"},
						"classes": {"wrapperClass": ["call-cancel-transfer-button", "t-btn-style-call-button-middle"]},
						"markerValue": "CancelTransferButton",
						"selectors": {"wrapEl": "#CancelTransferButton"},
						"style": Terrasoft.controls.ButtonEnums.style.TRANSPARENT,
						"hint": {"bindTo": "Resources.Strings.CancelTransferButtonHint"},
						"tag": "TransferButton"
					}
				},
				{
					"operation": "insert",
					"index": 8,
					"name": "AnswerButton",
					"parentName": "ButtonsPanel",
					"propertyName": "items",
					"values": {
						"id": "AnswerButton",
						"itemType": Terrasoft.ViewItemType.BUTTON,
						"click": {"bindTo": "answerCall"},
						"visible": {"bindTo": "getCanAnswer"},
						"imageConfig": {"bindTo": "Resources.Images.AnswerButtonLongIcon"},
						"classes": {"wrapperClass": ["call-answer-button", "t-btn-style-call-button-long"]},
						"markerValue": "AnswerButton",
						"selectors": {"wrapEl": "#AnswerButton"},
						"style": Terrasoft.controls.ButtonEnums.style.TRANSPARENT,
						"hint": {"bindTo": "Resources.Strings.AnswerButtonHint"},
						"tag": "AnswerButton"
					}
				},
				{
					"operation": "insert",
					"index": 9,
					"name": "DropButton",
					"parentName": "ButtonsPanel",
					"propertyName": "items",
					"values": {
						"id": "DropButton",
						"itemType": Terrasoft.ViewItemType.BUTTON,
						"click": {"bindTo": "dropCall"},
						"visible": {"bindTo": "getCanDrop"},
						"imageConfig": {"bindTo": "getDropButtonImageConfig"},
						"classes": {"wrapperClass": ["call-drop-button"]},
						"markerValue": "DropButton",
						"selectors": {"wrapEl": "#DropButton"},
						"style": {"bindTo": "getDropButtonStyle"},
						"hint": {"bindTo": "Resources.Strings.DropButtonHint"},
						"tag": "DropButton"
					}
				},

				//endregion

				{
					"operation": "insert",
					"parentName": "ctiPanelMainContainer",
					"propertyName": "items",
					"name": "PhoneNumber",
					"values": {
						"id": "PhoneNumber",
						"className": "Terrasoft.SearchEdit",
						"contentType": Terrasoft.ContentType.SHORT_TEXT,
						"labelConfig": {"visible": false},
						"bindTo": "PhoneNumber",
						"enterkeypressed": { "bindTo": "callPhoneNumber"},
						"change": {"bindTo": "onPhoneNumberChanged"},
						"searchValueChanged": {"bindTo": "onPhoneNumberChanged"},
						"visible": {"bindTo": "getCanMakeCallOrMakeConsultCall"},
						"classes": {
							"wrapClass": ["phone-number-edit"]
						},
						"rightIconClick": {
							"bindTo": "callPhoneNumber"
						},
						"rightIconConfig": {
							"source": Terrasoft.ImageSources.URL,
							"url": Terrasoft.ImageUrlBuilder.getUrl(resources.localizableImages.MakeCallButtonIcon)
						}
					}
				},

				//region search and identification panels

				{
					"operation": "insert",
					"name": "SearchResultItemsListContainer",
					"parentName": "ctiPanelMainContainer",
					"propertyName": "items",
					"values": {
						"id": "SearchResultItemsListContainer",
						"itemType": Terrasoft.ViewItemType.GRID,
						"markerValue": "SearchResultItemsListContainer",
						"selectors": {"wrapEl": "#SearchResultItemsListContainer"},
						"idProperty": "Id",
						"collection": {"bindTo": "SearchResultPanelCollection"},
						"onGetItemConfig": {"bindTo": "getSearchResultPanelViewConfig"},
						"classes": {"wrapClassName": ["search-result-items-list-container"]},
						"visible": {"bindTo": "getIsSearchResultItemsListContainerVisible"},
						"generator": "CtiContainerListGenerator.generatePartial"
					}
				},
				{
					"operation": "insert",
					"parentName": "ctiPanelMainContainer",
					"name": "IdentificationItemsControlGroup",
					"propertyName": "items",
					"values": {
						"id": "IdentificationItemsControlGroup",
						"itemType": Terrasoft.ViewItemType.CONTROL_GROUP,
						"markerValue": "IdentificationItemsControlGroup",
						"selectors": {"wrapEl": "#IdentificationItemsControlGroup"},
						"caption": {"bindTo": "Resources.Strings.IdentificationItemsControlGroupCaption"},
						"visible": {"bindTo": "getIsIdentificationGroupContainerVisible"},
						"controlConfig": {"collapsed": false},
						"items": []
					}
				},
				{
					"operation": "insert",
					"name": "IdentificationItemsListContainer",
					"parentName": "IdentificationItemsControlGroup",
					"propertyName": "items",
					"values": {
						"id": "IdentificationItemsListContainer",
						"itemType": Terrasoft.ViewItemType.GRID,
						"markerValue": "IdentificationItemsListContainer",
						"selectors": {"wrapEl": "#IdentificationItemsListContainer"},
						"idProperty": "Id",
						"collection": {"bindTo": "IdentifiedSubscriberPanelCollection"},
						"onGetItemConfig": {"bindTo": "getIdentifiedSubscriberPanelViewConfig"},
						"classes": {"wrapClassName": ["identification-items-list-container"]},
						"onItemClick": {"bindTo": "setIdentifiedSubscriber"},
						"visible": {"bindTo": "getIsCurrentCallIdentificationContainerVisible"},
						"generator": "CtiContainerListGenerator.generatePartial"
					}
				},
				{
					"operation": "insert",
					"name": "IdentificationConsultItemsListContainer",
					"parentName": "IdentificationItemsControlGroup",
					"propertyName": "items",
					"values": {
						"id": "IdentificationConsultItemsListContainer",
						"itemType": Terrasoft.ViewItemType.GRID,
						"markerValue": "IdentificationConsultItemsListContainer",
						"selectors": {"wrapEl": "#IdentificationConsultItemsListContainer"},
						"idProperty": "Id",
						"collection": {"bindTo": "IdentifiedConsultSubscriberPanelCollection"},
						"onGetItemConfig": {"bindTo": "getIdentifiedSubscriberPanelViewConfig"},
						"classes": {"wrapClassName": ["identification-items-list-container"]},
						"onItemClick": {"bindTo": "setIdentifiedSubscriber"},
						"visible": {"bindTo": "getIsConsultCallIdentificationContainerVisible"},
						"generator": "CtiContainerListGenerator.generatePartial"
					}
				},

				//endregion

				//region empty panel elements

				{
					"operation": "insert",
					"name": "EmptySearchResultContainer",
					"parentName": "ctiPanelMainContainer",
					"propertyName": "items",
					"values": {
						"itemType": Terrasoft.ViewItemType.CONTAINER,
						"visible": {"bindTo": "getIsEmptySearchResultContainerVisible"},
						"classes": {
							"wrapClassName": ["empty-search-result-container"]
						},
						"items": []
					}
				},
				{
					"operation": "insert",
					"name": "EmptySearchResultImage",
					"parentName": "EmptySearchResultContainer",
					"propertyName": "items",
					"values": {
						"generator": "ImageCustomGeneratorV2.generateSimpleCustomImage",
						"onPhotoChange": Terrasoft.emptyFn,
						"getSrcMethod": "getEmptySearchResultImageUrl",
						"classes": {
							"wrapClass": ["image-container"]
						},
						"items": []
					}
				},
				{
					"operation": "insert",
					"name": "EmptySearchResultLabel",
					"parentName": "EmptySearchResultContainer",
					"propertyName": "items",
					"values": {
						"itemType": Terrasoft.ViewItemType.LABEL,
						"classes": {
							"labelClass": [
								"description-label"
							]
						},
						"caption": {"bindTo": "Resources.Strings.EmptySearchResultMessage"}
					}
				},

				//endregion

				//region communication history panels

				{
					"operation": "insert",
					"name": "CommunicationHistoryContainerList",
					"parentName": "ctiPanelMainContainer",
					"propertyName": "items",
					"values": {
						"id": "CommunicationHistoryContainerList",
						"itemType": Terrasoft.ViewItemType.GRID,
						"markerValue": "CommunicationHistoryContainerList",
						"selectors": {"wrapEl": "#CommunicationHistoryContainerList"},
						"idProperty": "Id",
						"collection": {"bindTo": "CommunicationHistoryPanelCollection"},
						"onGetItemConfig": {"bindTo": "getCommunicationHistoryPanelViewConfig"},
						"classes": {"wrapClassName": ["communication-history-items-list-container"]},
						"visible": {"bindTo": "getIsCommunicationHistoryVisible"},
						"generator": "CtiContainerListGenerator.generatePartial",
						"getEmptyMessageConfig": {"bindTo": "prepareEmptyGridMessageConfig"},
						"isEmpty": {"bindTo": "isEmptyCallHistoryMessageVisible"}
					}
				}

				//endregion

			]
		};
	}
);

				// Autogenerated Code for schema CtiPanel (End)
// Autogenerated Code for schema ViewUtilities (Start)
define('ViewUtilitiesResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={
	UnsupportedItemType: 'Тип не поддерживается'
};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("ViewUtilities", ['ext-base', 'terrasoft', "ViewUtilitiesResources", 'ConfigurationEnums'],
	function(Ext, Terrasoft, resources, ConfigurationEnums){
	var elementContainerSuffix = '-ValueConatiner';
	var elementListSuffix = 'List';

	var mainContainers = ['leftContainer', 'rightContainer'];
	var controlBindingProperties = ['visible', 'enabled', 'isRequired'];
	var labelBindingProperties = ['visible'];
	var containerBindingProperties = ['visible'];
	var buttonBindingProperties = ['visible', 'enabled', 'style'];
	var labelBindingClasses = {
		default: ['controlCaption '],
		isRequired: {
			true: ['required-caption']
		}
	};
		/*
	 item config structure:
	 {
	 name: '' - used for generating controlsIds, need to be unique
	 columnPath: '' - name property or column in viewModel
	 caption: '' - control caption
	 referenceSchemaName: ''
	 dataValueType: Terrasoft.DataValueType - used for select what control to generate
	 customContainerConfig: {} - config for update container config
	 customControlConfig: {} - config for update container config
	 customLabelConfig: {} - config for update container config
	 }
	 */
	/*
	main view config structure
	header: {
	headerCaption: '' - header caption property
	},
	utils: {
	leftButtons: [] - configsForLestButtons
	}
	mainContainers: []	- names of main containers
	*/

	function isLookup(itemConfig) {
		var dataValueType = itemConfig.dataValueType;
		return dataValueType === Terrasoft.DataValueType.LOOKUP ||
			dataValueType === Terrasoft.DataValueType.ENUM;
	}
	function isBoolean(itemConfig) {
		var dataValueType = itemConfig.dataValueType;
		return dataValueType === Terrasoft.DataValueType.BOOLEAN;
	}
    function getIsMemoEdit(itemConfig) {
        var dataValueType = itemConfig.dataValueType;
        var isMultiLine = itemConfig.isMultiLine;
        return dataValueType === Terrasoft.DataValueType.TEXT && isMultiLine;
    }
	function getLookupListName(columnName) {
		return columnName + elementListSuffix;
	}
	function getControlViewModelApplyConfig(config) {
        var columnPath = config.columnPath;
        var applyConfig = {
            values: {},
            methods: {},
            columns: {}
        };
        if (config.items) {
            var propertyName = getControlGroupName(config) + 'collapsed';
            applyConfig.values[propertyName] = Ext.isEmpty(config.collapsed) ? false : config.collapsed;
            return applyConfig;
        }
        if (!Ext.isEmpty(config.value)) {
            applyConfig.values[columnPath] = config.value;
        }
        applyConfig.columns = getViewModelColumns(config);
        if (isLookup(config)) {
            applyConfig.values[getLookupListName(columnPath)] = new Terrasoft.Collection();
        }
        return applyConfig;
	}
	function getButton(config) {
		var buttonConfig = {
			className: 'Terrasoft.Button',
			caption: config.caption || '',
			tag: config.name,
			style: Terrasoft.controls.ButtonEnums.style.DEFAULT
		};
		if (!Ext.isEmpty(config.methodName)) {
			buttonConfig.click = {
				bindTo: config.methodName
			};
		}
		pushBindingProperties(buttonConfig, config, buttonBindingProperties);
		Ext.apply(buttonConfig, config.customButtonConfig);
		return buttonConfig;
	}
	function pushBindingProperties(component, config, properties) {
		Terrasoft.each(properties, function(property) {
			if (!Ext.isEmpty(config[property])) {
				component[property] = config[property];
			}
		});
	}
	function getControl(config) {
		var columnPath = config.columnPath;
		var dataValueType = config.dataValueType;
		if (dataValueType === Terrasoft.DataValueType.DATE_TIME) {
			var controlConfig = generateDataTimeControlConfig(config);
			return controlConfig;
		}
		var controlConfig = getIsMemoEdit(config)
            ? getMemoEditConfig() : Terrasoft.getControlConfigByDataValueType(dataValueType);
		if (isBoolean(config)) {
			controlConfig.checked = {
				bindTo: columnPath
			};
		} else {
			controlConfig.value = {
				bindTo: columnPath
			};
		}
        if (isLookup(config)) {
			controlConfig.list = {
				bindTo: getLookupListName(columnPath)
			};
			if (config.dataValueType === Terrasoft.DataValueType.LOOKUP) {
				controlConfig.tag = columnPath;
				controlConfig.loadVocabulary = {
					bindTo: 'loadVocabulary'
				};
			}
		}
		pushBindingProperties(controlConfig, config, controlBindingProperties);
		Ext.apply(controlConfig, config.customControlConfig);
		return controlConfig;
	}
	function pushLabelClasses(component, config) {
		var labelClasses = [];
		for(var classBindName in labelBindingClasses) {
			if (classBindName === 'default') {
				Terrasoft.each(labelBindingClasses[classBindName], function(labelClass) {
					labelClasses.push(labelClass);
				});
				continue;
			}
			var bindValue = config[classBindName];
			if (!Ext.isEmpty(bindValue)
				&& !Ext.isEmpty(labelBindingClasses[classBindName][bindValue])) {
				Terrasoft.each(labelBindingClasses[classBindName][bindValue], function(labelClass) {
					labelClasses.push(labelClass);
				});
				continue;
			}
		}
		component.classes = {
			labelClass: labelClasses
		};
	}
	function getLabel(config) {
		var labelConfig = {
			className: "Terrasoft.Label",
			caption: config.caption || ''
		};
		pushBindingProperties(labelConfig, config, labelBindingProperties);
		pushLabelClasses(labelConfig, config);
		Ext.apply(labelConfig, config.customLabelConfig);
		return labelConfig;
	}
    function getCommentaryLabel(config) {
        var labelConfig = {
            className: "Terrasoft.Label",
            caption: config.text || '',
            labelClass: 'commentary'
        };
        Ext.apply(labelConfig, config.customLabelConfig);
        return labelConfig;
    }
	function getHeaderConfig(headerConfig) {
		var mainContainer = getContainerConfig('header', 'header');
		var headerNameContainer = getContainerConfig('header-name-container', 'header-name-container');
		var commandLineContainer = getContainerConfig('card-command-line-container', 'card-command-line');
		var contextHelpContainer = getContainerConfig('card-context-help-container', 'card-context-help');
		if (Ext.isEmpty(headerConfig)) {
			headerConfig = {};
		}
		headerNameContainer.items = [{
			className: "Terrasoft.Label",
			id: 'header-name',
			caption: headerConfig.headerCaption || {
				bindTo: 'header'
			}
		}];
		mainContainer.items = [
			headerNameContainer,
			commandLineContainer,
			contextHelpContainer
		];
		return mainContainer;
	}
	function getUtilsConfig(utilsConfig) {
		if (Ext.isEmpty(utilsConfig)) {
			utilsConfig = []
		}
		var utilsContainer = getContainerConfig('utils');
		var utilsLeftContainer = getContainerConfig('utils-left');
		Terrasoft.each(utilsConfig, function(button) {
			utilsLeftContainer.items.push(getButton(button));
		});
		return utilsLeftContainer;
	}
	function pushItemsToContainerConfig(container, items) {
		Terrasoft.each(itemsConfig, function(item) {
			var itemConfig = getItemConfig(item);
			itemsContainer.items.push(itemConfig);
		});

	}
	function getMainViewConfig(config) {
		var headerConfig = config.header;
		var utilsConfig = config.utils;
		var mainContainersNames = config.mainContainers || mainContainers;
		var headerControlConfig = getHeaderConfig(headerConfig);
		var utilsControlConfig = getUtilsConfig(utilsConfig);
		var mainContainer = getContainerConfig('CardMainContainer');
		var result  = {
			mainContainer: mainContainer
		};
		mainContainer.items = [
			headerControlConfig,
			utilsControlConfig
		];
		Terrasoft.each(mainContainersNames, function(containerName) {
			var itemContainer = getContainerConfig(containerName);
			mainContainer.items.push(itemContainer);
			result[containerName] = itemContainer;
		});
		return result;
	}
	function generateDataTimeControlConfig(config) {
		var containerConfig = getContainerConfig('DateTimeContainer' + config.name,
			['datetimeeditcontainer-class', 'controlBaseedit']);
		var dateControl = {
			className: 'Terrasoft.DateEdit',
			classes: {
				wrapClass: ['dimension-class', 'datetime-datecontrol']
			},
			id: 'date-edit-' + config.name,
			selectors: {
				wrapEl: '#date-edit-' + config.name
			},
			value: {
				bindTo: config.columnPath
			}
		};
		var timeControl = {
			className: 'Terrasoft.TimeEdit',
			id: 'time-edit-' + config.name,
			selectors: {
				wrapEl: '#time-edit-' +  config.name
			},
			classes: {
				wrapClass: ['dimension-class', 'datetime-timecontrol']
			},
			value: {
				bindTo: config.columnPath
			}
		};
		containerConfig.items = [dateControl, timeControl];
		pushBindingProperties(dateControl, config, controlBindingProperties);
		pushBindingProperties(timeControl, config, controlBindingProperties);
		Ext.apply(dateControl, config.customDateControlConfig);
		Ext.apply(timeControl, config.customTimeControlConfig);
		return containerConfig;
	}
	function getControlViewConfig(config) {
		var elementContainerId = config.name + elementContainerSuffix;
		var containerConfig = getContainerConfig(elementContainerId);
		var containerConfigItems = containerConfig.items;
		pushBindingProperties(containerConfig, config, containerBindingProperties);
		Ext.apply(containerConfig, config.customContainerConfig);
        if (config.text) {
            var commentaryConfig = getCommentaryLabel(config);
            containerConfigItems.push(commentaryConfig);
            return containerConfig;
        }
		var labelConfig = getLabel(config);
		var controlConfig = getControl(config);
		if (config.dataValueType === Terrasoft.DataValueType.BOOLEAN) {
			containerConfigItems.push(generateCheckBoxContainer(labelConfig, controlConfig, config.name));
		} else {
			containerConfigItems.push(labelConfig, controlConfig);
		}

		return containerConfig;
	}

	function generateCheckBoxContainer(labelConfig, controlConfig, name) {
		controlConfig.id = name + '-checkbox';
		labelConfig.inputId = controlConfig.id + '-el';
		var container = getContainerConfig(name + 'container', ['check-box-container']);//custom-view-container
		container.visible = !Ext.isEmpty(labelConfig.visible) ? labelConfig.visible : true;
		labelConfig.labelClass = 't-label custom-label-container check-box-label-container';
		controlConfig.classes = {wrapClass: ['custom-control-container']};
		container.items.push(controlConfig, labelConfig);
		return container;
	}

    function generateRadioButtonContainer(labelConfig, controlConfig, name) {
        controlConfig.id = name + '-radiobutton';
        labelConfig.inputId = controlConfig.id + '-el';
        var container = getContainerConfig(name + 'container', ['custom-view-container']);
        labelConfig.labelClass = 't-label custom-label-container check-box-label-container';
        controlConfig.classes = {wrapClass: ['custom-control-container']};
        container.items.push(controlConfig, labelConfig);
        return container;
    }

    function getRadioButtonGroupName(name) {
        return name + '-radioGroup';
    }

    function getMemoEditConfig(){
        var memoEditConfig = {
            className: 'Terrasoft.MemoEdit',
            height: '77px'
        }
        return memoEditConfig;
    }

	function getPageConfig(schemaConfig) {
		var config = Terrasoft.deepClone(schemaConfig);
		config.mainContainers = [];
		for (var containerName in config.schema) {
			config.mainContainers.push(containerName);
		}
		var mainConfig = getMainViewConfig(config);
		for (var containerName in config.schema) {
			var itemsContainer = mainConfig[containerName]
			var itemsConfig = config.schema[containerName];
			getContainerItemsConfig(itemsContainer, itemsConfig);
		}
		return mainConfig.mainContainer;
	}

	function getContainerItemsConfig(container, items) {
		Terrasoft.each(items, function(item) {
			var itemConfig = getItemConfig(item);
			if (item.type == Terrasoft.ViewModelSchemaItem.GROUP && Ext.isArray(item.items)) {
				getContainerItemsConfig(itemConfig, item.items);
			}
			container.items.push(itemConfig);
		});
	}

	function getItemConfig(config) {
		switch (config.type) {
			case ConfigurationEnums.CustomViewModelSchemaItem.BUTTON:
				return getButton(config);
			case Terrasoft.ViewModelSchemaItem.ATTRIBUTE:
				return getControlViewConfig(config);
			case Terrasoft.ViewModelSchemaItem.GROUP:
				return getGroupConfig(config);
			default:
				throw new Terrasoft.UnsupportedTypeException({
					message: resources.localizableStrings.UnsupportedItemType
				});
		}

	}
	function generateViewModelColumn(schemaItem) {
		return {
			type: Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
			dataValueType: schemaItem.dataValueType,
			caption: schemaItem.caption,
			name: schemaItem.name,
			columnPath: schemaItem.columnPath,
			IsRequired: schemaItem.IsRequired
		};
	}
	function getViewModelColumns(config) {
		var columns = {};
		var column = generateViewModelColumn(config);
		if (!Ext.isEmpty(config.isRequired)) {
			column.isRequired = config.isRequired
		}
		columns[column.name] = column;
		if (isLookup(config)) {
			column.isLookup = true;
			column.referenceSchemaName = config.referenceSchemaName;
			var lookupListColumnConfig = {
				type: Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
				name: getLookupListName(config.name),
				isCollection: true
			};
			columns[lookupListColumnConfig.name] = lookupListColumnConfig;
		}
		return columns;
	}
	function getContainerConfig(id, wrapClassName) {
		var container = {
			className: 'Terrasoft.Container',
			items: [],
			id: id,
			selectors: {
				wrapEl: '#' + id
			}
		};
		if (!Ext.isEmpty(wrapClassName)) {
			container.classes = {
				wrapClassName: wrapClassName
			};
		}
		return container;
    }
    function getControlGroupName(config){
        return config.name + '-control-group';
    }
    function getGroupConfig(config) {
        var wrapContainerClasses = ['control-group-container'];
        if (config.wrapContainerClass) {
            wrapContainerClasses.push(config.wrapContainerClass);
        }
        var groupName = getControlGroupName(config);
        var container = {
            id: Ext.isEmpty(config.id) ? groupName : config.id,
            className: 'Terrasoft.ControlGroup',
            caption: config.caption,
            markerValue: config.caption,
            collapsed: {
                bindTo: groupName + 'collapsed'
            },
            visible: Ext.isEmpty(config.visible) ? true : config.visible,
            classes: { wrapContainerClass: wrapContainerClasses },
            tag: config.name,
            items: []
        };
        var customConfig = Terrasoft.deepClone(config.customConfig || {});
        Ext.apply(container, customConfig);
        return container;
    }
	return {
		getContainerConfig: getContainerConfig,
		getGroupConfig: getGroupConfig,
		getControlViewConfig: getControlViewConfig,
		getControlViewModelApplyConfig: getControlViewModelApplyConfig,
		getMainViewConfig: getMainViewConfig,
		getPageConfig: getPageConfig
	}
});

				// Autogenerated Code for schema ViewUtilities (End)
// Autogenerated Code for schema RightSideBarModule (Start)
define('RightSideBarModuleResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={
	FeedTabCaption: 'Лента',
	RemindingTabCaption: 'Напоминания',
	KPITabCaption: 'KPI',
	VisaTabCaption: 'Визы'
};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("RightSideBarModule", ["RightSideBarModuleResources", "ViewUtilities", "BaseModule"],
	function(resources, ViewUtilities) {

		/**
		 * @class Terrasoft.configuration.RightSideBarModule
		 * Класс RightSideBarModule предназначен для создания экземпляра правой боковой панели
		 */
		var rightSideBarModule = Ext.define("Terrasoft.configuration.RightSideBarModule", {
			extend: "Terrasoft.BaseModule",
			alternateClassName: "Terrasoft.RightSideBarModule",
			Ext: null,
			sandbox: null,
			Terrasoft: null,

			/**
			 * Формирует конфигурацию представления.
			 * @protected
			 * @virtual
			 * @return {Object} Возвращает конфигурацию представления.
			 */
			getViewConfig: function() {
				var rightPanelModulesContainer = ViewUtilities.getContainerConfig("rightPanelModulesContainer",
					["right-panel-modules-container"]);
				return {
					id: "rightSideBarContainer",
					selectors: {wrapEl: "#rightSideBarContainer"},
					classes: {wrapClassName: ["right-side-bar-container"]},
					items: [rightPanelModulesContainer]
				};
			},

			/**
			 * Создает объект представления.
			 * @protected
			 * @virtual
			 * @return {Terrasoft.Container} Возвращает экземпляр контейнера представления.
			 */
			getView: function() {
				return this.Ext.create("Terrasoft.Container", this.getViewConfig());
			},

			/**
			 * Создает объект модели представления.
			 * @protected
			 * @param {Terrasoft.configuration.RightSideBarModule} scope Экземпляр класса модуля RightSideBarModule.
			 * @return {Terrasoft.BaseViewModel} Возвращает экземпляр модели представления.
			 */
			getViewModel: function(scope) {
				var viewModel = this.Ext.create("Terrasoft.BaseViewModel", {
					values: {
						/**
						 * Шаблон именования контейнеров отображения модулей.
						 * @private
						 * @type {String}
						 */
						wrapContainerNamePattern: "{0}_WrapContainer"
					},
					methods: {

						/**
						 * Инициалицизует параметры модели.
						 * @private
						 */
						init: function() {
							this.sandbox.subscribe("CommunicationPanelItemSelected",
								this.onCommunicationPanelItemSelected, this);
						},

						/**
						 * Обрабатывает событие выбора элемента меню панели.
						 * @virtual
						 * @param {Object} itemConfig Конфигурация элемента меню панели.
						 * @example
						 * Для каждого модуля создается/активируется собственный контейнер.
						 * Каждый из модулей имеет флаг keepAlive.
						 * В данном случае этот флаг указывает на то, что будет ли выгружен модуль при смене активного
						 * контейнера.
						 *
						 * Пусть загружен SampleAliveModule (keepAlive == true), потом активируем другой модуль
						 * AnotherModule (keepAlive == false). В результате у нас будет скрыт контейнер первого модуля,
						 * но сам модуль будет загружен и реагировать на события, а второй - загрузится и покажеться.
						 * Далее, активируем снова первый модуль. В результате контейнер первого модуля будет отображен,
						 * а контейнер второго - скрыт, но так как второй модуль keepAlive = false, то он будет
						 * выгружен. При последующей активации второго модуля будет производится повторная его загрузка
						 * в существующий для него контейнер.
						 */
						onCommunicationPanelItemSelected: function(itemConfig) {
							var moduleName = itemConfig.moduleName;
							var keepAlive = itemConfig.keepAlive;
							var previousItemConfig = itemConfig.previousItemConfig || {};
							var previousModuleName = previousItemConfig.moduleName;
							var wrapContainerNamePattern = this.get("wrapContainerNamePattern");
							var moduleContainer =
								Ext.getCmp(Ext.String.format(wrapContainerNamePattern, moduleName));
							var previousModuleContainer =
								Ext.getCmp(Ext.String.format(wrapContainerNamePattern, previousModuleName));
							if (!Ext.isEmpty(previousModuleName) && !Ext.isEmpty(previousModuleContainer)) {
								if (!previousItemConfig.keepAlive) {
									this.sandbox.unloadModule(this.sandbox.id + "_" + previousModuleName);
								}
								previousModuleContainer.wrapEl.addCls("hidden");
							}
							var reloadModule = !keepAlive;
							if (!Ext.isEmpty(moduleContainer)) {
								moduleContainer.wrapEl.removeCls("hidden");
							} else {
								moduleContainer = Ext.create("Terrasoft.Container", {
									id: Ext.String.format(wrapContainerNamePattern, moduleName)
								});
								var rightPanelModulesContainer = Ext.getCmp("rightPanelModulesContainer");
								rightPanelModulesContainer.add(moduleContainer);
								moduleContainer.wrapEl.addCls("communication-panel-item-container");
								if (itemConfig.loadHidden === true) {
									moduleContainer.wrapEl.addCls("hidden");
								}
								reloadModule = true;
							}
							if (reloadModule) {
								this.sandbox.loadModule(moduleName, {
									renderTo: Ext.String.format(wrapContainerNamePattern, moduleName)
								});
							}
						}
					}
				});
				viewModel.Ext = this.Ext;
				viewModel.sandbox = this.sandbox;
				viewModel.Terrasoft = this.Terrasoft;
				return viewModel;
			},

			/**
			 * Выполняет прорисовку модуля в контейнер.
			 * @private
			 * @param {Ext.Element} renderTo Указывает ссылку на {@link Ext.Element} в который будет рендериться
			 * элемент управления.
			 */
			render: function(renderTo) {
				var view = this.getView();
				var viewModel = this.getViewModel(this);
				view.bind(viewModel);
				view.render(renderTo);
				viewModel.init();
			}
		});
		return rightSideBarModule;
	});


				// Autogenerated Code for schema RightSideBarModule (End)
// Autogenerated Code for schema LeftPanelUtilitiesV2 (Start)
define('LeftPanelUtilitiesV2Resources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("LeftPanelUtilitiesV2", ["ext-base", "terrasoft", "ConfigurationConstants", "profile!LeftPanelCollapsed"],
	function(Ext, Terrasoft, ConfigurationConstants, profile) {
	/**
	 * @class Terrasoft.configuration.LeftPanelUtilities
	 * Вспомогательный класс работы с левой боковой панелью приложения
	 */
	Ext.define("Terrasoft.configuration.LeftPanelUtilitiesV2", {
		extend: "Terrasoft.BaseObject",
		alternateClassName: "Terrasoft.LeftPanelUtilitiesV2",

		/**
		 * Признак использования профиля.
		 * @private
		 * @type {Boolean}
		 */
		useProfile: true,

		/**
		 * Конструктор класса.
		 * @returns {Terrasoft.configuration.LeftPanelUtilities} Возвращает созданный экземпляр класса.
		 */
		constructor: function() {
			this.callParent(arguments);
			this.addEvents(
				/**
				 * @event
				 * Событие изменения свёрнутости левой панели.
				 */
				"collapsedChanged"
			);
			return this;
		},

		/**
		 * Устанавливает состояние свёрнутости в начальное положение.
		 * @public
		 */
		initCollapsedState: function() {
			var defaultCollapsed = this.getDefaultCollapsed();
			this.setCollapsed(defaultCollapsed);
		},

		/**
		 * Возвращает начальное значение свёрнутости левой панели.
		 * @protected
		 * @return {Boolean} Начальное значение свёрнутости левой панели.
		 */
		getDefaultCollapsed: function() {
			if (this.useProfile) {
				if (profile !== null) {
					return profile;
				} else {
					return true;
				}
			} else {
				return true;
			}
		},

		/**
		 * Возвращает текущее значение свёрнутости левой панели.
		 * @public
		 * @return {Boolean} Текущее значение свёрнутости левой панели.
		 */
		getCollapsed: function() {
			var body = Ext.getBody();
			return body.hasCls("left-panel-collapsed");
		},

		/**
		 * Изменяет значение свёрнутости левой панели на обратное.
		 * @public
		 */
		changeCollapsed: function() {
			var collapsed = this.getCollapsed();
			this.setCollapsed(!collapsed);
		},

		/**
		 * Изменяет значение свёрнутости левой панели.
		 * @param {Boolean} collapsed Признак свёрнутости.
		 * @public
		 */
		setCollapsed: function(collapsed) {
			var body = Ext.getBody();
			var internalCollapsed = this.getCollapsed();
			if (collapsed) {
				body.addCls("left-panel-collapsed");
			} else {
				body.removeCls("left-panel-collapsed");
			}
			if (internalCollapsed !== collapsed) {
				this.fireEvent("collapsedChanged", collapsed);
			}
			if (this.useProfile) {
				Terrasoft.utils.saveUserProfile("LeftPanelCollapsed", collapsed, false);
			}
		}

	});
	return Ext.create(Terrasoft.configuration.LeftPanelUtilitiesV2);
});

				// Autogenerated Code for schema LeftPanelUtilitiesV2 (End)
// Autogenerated Code for schema CtiConstants (Start)
define('CtiConstantsResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={
	LicenseNotFoundMessage: 'Отсутствуют лицензии телефонии. Требуемые операции: {0}',
	SysMsgLibSettingsEmptyMessage: 'Значение системной настройки \'Библиотека обмена сообщениями по умолчанию\' не установлено',
	ConnectionConfigIncorrectMessage: 'Ошибка получения параметров подключения к телефонии. Укажите параметры в меню \"Настройки параметров Call Centre\" в профиле пользователя',
	ConnectionConfigEmptyMessage: 'Отсутствуют параметры подключения к телефонии. Укажите параметры в меню \"Настройки параметров Call Centre\" в профиле пользователя'
};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("CtiConstants", ["ext-base", "terrasoft", "CtiConstantsResources"],
	function(Ext, Terrasoft, resources) {

		/**
		 * Типы коммуникаций.
		 * @type {String}
		 */
		var communicationCodes = {
			/**
			 * Телефон.
			 */
			Phone: "Phone"
		};

		var callDirection = {
			Incoming: "1d96a65f-2131-4916-8825-2d142b1000b2",
			Outgoing: "53f71b5f-7e17-4cf5-bf14-6a59212db422",
			NotDefined: "c072be2c-3d82-4468-9d4a-6db47d1f4cca"
		};

		/**
		 * Числовые характеристики времени.
		 * @type {Object}
		 */
		var timeScale = {
			/** Количество миллисекунд в секунде.*/
			MillisecondsInSecond: 1000,
			/** Количество секунд в минуте.*/
			SecondsInMinute: 60,
			/** Минимальное натуральное число с двумя цифрами.*/
			MinTwoDigitNumber: 10
		};

		/**
		 * Числовые характеристики длительности разговора.
		 * @type {Object}
		 */
		var talkDuration = {
			/** Частота обновления длительности разговора.*/
			RefreshRate: 500
		};

		/** @enum
		 * Типы идентифицированных абонентов телефонии.
		 */
		var subscriberTypes = {
			/** Контакт */
			Contact: "Contact",
			/** Контрагент */
			Account: "Account",
			/** Сотрудник */
			Employee: "Employee"
		};

		/**
		 * Количество записей, которые следует выбрать из таблиц средств связи при идентификации абонента.
		 * @type {Number}
		 */
		var identificationMaxRowCount = 20;

		/**
		 * Количество символов в поле ввода номера, начиная с которых нужно инициализировать идентификацию по буквам.
		 * @type {Number}
		 */
		var identificationMinSymbolCount = 3;

		/**
		 * Количество последних символов, введенных через DTMF набор, которые нужно отображать.
		 * @type {Number}
		 */
		var dtmfMaxDisplayedDigits = 20;

		/**
		 * Идентификатор контекста сообщения запроса записей разговоров.
		 * @type {String}
		 */
		var callRecordsContextMessageId = "CallSectionGridRowCallRecords";

		/**
		 * @enum
		 * Тип звонка.
		 */
		var callType = {
			/** По умолчанию. */
			DEFAULT: "default",
			/** Входящий. */
			INCOMING: "incoming",
			/** Исходящий. */
			OUTGOING: "outgoing",
			/** Пропущенный. */
			MISSED: "missed"
		};

		return {
			CallType: callType,
			TalkDuration: talkDuration,
			TimeScale: timeScale,
			CommunicationCodes: communicationCodes,
			CallDirection: callDirection,
			SubscriberTypes: subscriberTypes,
			LocalizableStrings: resources.localizableStrings,
			IdentificationMaxRowCount: identificationMaxRowCount,
			IdentificationMinSymbolCount: identificationMinSymbolCount,
			DtmfMaxDisplayedDigits: dtmfMaxDisplayedDigits,
			CallRecordsContextMessageId: callRecordsContextMessageId
		};
	});

				// Autogenerated Code for schema CtiConstants (End)
// Autogenerated Code for schema CtiBaseHelper (Start)
define('CtiBaseHelperResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={
	SysMsgLibSettingsEmptyMessage: 'Значение системной настройки \'Библиотека обмена сообщениями по умолчанию\' не установлено'
};
var localizableImages={
	'ReadyStatusIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CtiBaseHelper', resourceItemName: 'ReadyStatusIcon' }},
	'BusyStatusIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CtiBaseHelper', resourceItemName: 'BusyStatusIcon' }},
	'AwayStatusIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CtiBaseHelper', resourceItemName: 'AwayStatusIcon' }},
	'ReadyStatusProfileMenuItemIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CtiBaseHelper', resourceItemName: 'ReadyStatusProfileMenuItemIcon' }},
	'BusyStatusProfileMenuItemIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CtiBaseHelper', resourceItemName: 'BusyStatusProfileMenuItemIcon' }},
	'AwayStatusProfileMenuItemIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'CtiBaseHelper', resourceItemName: 'AwayStatusProfileMenuItemIcon' }}
};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("CtiBaseHelper", ["terrasoft", "CtiConstants", "CtiBaseHelperResources"],
	function(Terrasoft, CtiConstants, resources) {

		/**
		 * Выводит информационное сообщение в консоль.
		 * @private
		 * @param {String|Object} message Сообщение.
		 */
		function log(message) {
			var console = Ext.global.console;
			if (console && console.log) {
				console.log(message);
			}
		}

		/**
		 * Выводит предупреждающее сообщение в консоль.
		 * @private
		 * @param {String|Object} message Сообщение.
		 */
		function logWarning(message) {
			var console = Ext.global.console;
			if (console && console.warn) {
				console.warn(message);
			}
		}

		/**
		 * Выводит сообщение об ошибке в консоль.
		 * @private
		 * @param {String|Object} message Сообщение.
		 */
		function logError(message) {
			var console = Ext.global.console;
			if (console && console.error) {
				console.error(message);
			}
		}

		/**
		 * Проверяет установку в профиле пользователя разрешения на подключение к телефонии.
		 * @private
		 * @param {Function} callback Функция обратного вызова. В функцию передается признак того, что телефония разрешена.
		 */
		function getIsProfileTelephonyEnabled(callback) {
			queryCtiSettings(function(ctiSettings) {
				var isTelephonyDisabled = (ctiSettings && ctiSettings.connectionParams &&
				ctiSettings.connectionParams.disableCallCentre);
				callback(!isTelephonyDisabled);
			});
		}

		/**
		 * Инициализирует параметры телефонии.
		 * @private
		 * @param {Function} callback (optional) Функция обратного вызова. В качестве аргумента передаются параметры
		 * телефонии.
		 */
		function initCtiSettings(callback) {
			if (!Terrasoft.SysValue) {
				callback(null);
				return;
			}
			var ctiSettings = Terrasoft.SysValue.CTI;
			if (Ext.isObject(ctiSettings) && ctiSettings.isInitialized) {
				callback(ctiSettings);
				return;
			}
			ctiSettings = {
				isInitialized: false
			};
			Terrasoft.SysValue.CTI = ctiSettings;
			Terrasoft.SysSettings.querySysSettings(["SysMsgLib", "InternalNumberLength", "SearchNumberLength",
					"CommunicationHistoryRowCount"],
				function(settings) {
					var sysMsgLibItem = settings.SysMsgLib;
					if (!sysMsgLibItem || (sysMsgLibItem.value === Terrasoft.GUID_EMPTY)) {
						logWarning(CtiConstants.LocalizableStrings.SysMsgLibSettingsEmptyMessage);
						ctiSettings.isInitialized = true;
						callback(ctiSettings);
						return;
					}
					var sysMsgLibId = settings.SysMsgLib.value;
					ctiSettings.sysMsgLibId = sysMsgLibId;
					ctiSettings.internalNumberLength = settings.InternalNumberLength;
					ctiSettings.searchNumberLength = settings.SearchNumberLength;
					ctiSettings.communicationHistoryRowCount = settings.CommunicationHistoryRowCount;
					initializeMsgLibSettings(sysMsgLibId, ctiSettings, callback);
				}
			);
		}

		/**
		 * Инициализирует параметры коннектора телефонии.
		 * @private
		 * @param {String} sysMsgLibId Идентификатор библиотеки обмена сообщениями.
		 * @param {Object} ctiSettings Параметры телефонии.
		 * @param {Function} callback (optional) Функция обратного вызова. В качестве аргумента передаются параметры
		 * телефонии.
		 */
		function initializeMsgLibSettings(sysMsgLibId, ctiSettings, callback) {
			if (ctiSettings.isInitialized) {
				if (callback) {
					callback(ctiSettings);
				}
				return;
			}
			var batchQuery = Ext.create("Terrasoft.BatchQuery");
			batchQuery.add(getMsgLibSelect(sysMsgLibId));
			batchQuery.add(getMsgUserSettingsSelect(sysMsgLibId));
			batchQuery.execute(function(response) {
				if (!response.success || !response.queryResults || response.queryResults.length === 0) {
					ctiSettings.isInitialized = true;
					if (callback) {
						callback(ctiSettings);
					}
					return;
				}
				var queryResults = response.queryResults;
				var msgLibRows = queryResults[0].rows;
				setMsgLibSettings(msgLibRows, ctiSettings);
				if (queryResults.length > 1) {
					var msgUserSettingsRows = queryResults[1].rows;
					setMsgUserSettings(msgUserSettingsRows, ctiSettings);
				}
				ctiSettings.isInitialized = true;
				if (callback) {
					callback(ctiSettings);
				}
			});
		}

		/**
		 * Возвращает запрос на выборку настройки библиотеки телефонии.
		 * @private
		 * @param {String} sysMsgLibId Идентификатор библиотеки обмена сообщениями.
		 * @returns {Terrasoft.EntitySchemaQuery} Запрос на выборку настройки библиотеки телефонии.
		 */
		function getMsgLibSelect(sysMsgLibId) {
			var select = Ext.create("Terrasoft.EntitySchemaQuery", {
				rootSchemaName: "SysMsgLib"
			});
			select.addColumn("SetupPageSchemaName");
			select.addColumn("LicOperations");
			select.addColumn("CtiProviderName");
			select.filters.add("idFilter", Terrasoft.createColumnFilterWithParameter(
				Terrasoft.ComparisonType.EQUAL, "Id", sysMsgLibId));
			return select;
		}

		/**
		 * Записывает в настройки cti настройки библиотеки телефонии.
		 * @private
		 * @param {Object[]} msgLibRows Записи выборки настроек библиотеки телефонии.
		 * @param {Object} ctiSettings cti телефонии.
		 */
		function setMsgLibSettings(msgLibRows, ctiSettings) {
			if (!msgLibRows || (msgLibRows.length === 0)) {
				return;
			}
			var msgLib = msgLibRows[0];
			ctiSettings.setupPageSchemaName = msgLib.SetupPageSchemaName;
			var licOperations = msgLib.LicOperations;
			if (Ext.isString(licOperations)) {
				ctiSettings.licOperations = licOperations.split(";");
			}
			ctiSettings.ctiProviderName = msgLib.CtiProviderName;
		}

		/**
		 * Возвращает запрос на выборку параметров телефонии текущего пользователя.
		 * @private
		 * @param {String} sysMsgLibId Идентификатор библиотеки обмена сообщениями.
		 * @returns {Terrasoft.EntitySchemaQuery} Запрос на выборку параметров телефонии текущего пользователя.
		 */
		function getMsgUserSettingsSelect(sysMsgLibId) {
			var select = Ext.create("Terrasoft.EntitySchemaQuery", {
				rootSchemaName: "SysMsgUserSettings"
			});
			select.addColumn("ConnectionParams");
			select.filters.add("userFilter", Terrasoft.createColumnFilterWithParameter(
				Terrasoft.ComparisonType.EQUAL, "User", Terrasoft.SysValue.CURRENT_USER.value));
			select.filters.add("libFilter", Terrasoft.createColumnFilterWithParameter(
				Terrasoft.ComparisonType.EQUAL, "SysMsgLib", sysMsgLibId));
			return select;
		}

		/**
		 * Записывает в настройки cti параметры подключения пользователя к телефонии.
		 * @private
		 * @param {Object[]} msgUserSettingsRows Записи выборки параметров подключения пользователя к телефонии.
		 * @param {Object} ctiSettings Настройки телефонии.
		 */
		function setMsgUserSettings(msgUserSettingsRows, ctiSettings) {
			if (!msgUserSettingsRows || (msgUserSettingsRows.length === 0)) {
				log(CtiConstants.LocalizableStrings.ConnectionConfigEmptyMessage);
				return;
			}
			var msgUserSettings = msgUserSettingsRows[0];
			var connectionParams = msgUserSettings.ConnectionParams;
			if (connectionParams) {
				try {
					ctiSettings.connectionParams = Terrasoft.decode(connectionParams);
				} catch (e) {
					logError(e);
				}
			}
			if (!ctiSettings.connectionParams) {
				logError(CtiConstants.LocalizableStrings.ConnectionConfigIncorrectMessage);
			}
		}

		/**
		 * Запрашивает параметры телефонии.
		 * @param {Function} callback Функция обратного вызова. В качестве аргумента передаются параметры телефонии.
		 */
		function queryCtiSettings(callback) {
			var ctiSettings = Terrasoft.SysValue.CTI;
			if (ctiSettings && ctiSettings.isInitialized) {
				callback(ctiSettings);
				return;
			}
			initCtiSettings(callback);
		}

		/**
		 * Проверяет разрешенность подключения к телефонии.
		 * Условия:
		 * Есть действующая лицензия на коннектор.
		 * В профиле пользователя включена интеграция с телефонией
		 * @param {Function} callback Функция обратного вызова.
		 */
		var getIsTelephonyEnabled = function(callback) {
			queryCtiSettings(function(ctiSettings) {
				if (Ext.isEmpty(ctiSettings.sysMsgLibId) || Ext.isEmpty(ctiSettings.ctiProviderName)
						|| Ext.isEmpty(ctiSettings.connectionParams)) {
					callback(false);
					return;
				}
				var licOperations = ctiSettings.licOperations || [];
				getUserHasOperationLicense({
					operations: licOperations,
					isAnyOperation: false
				}, function(canUseCti) {
					if (canUseCti) {
						getIsProfileTelephonyEnabled(callback);
					} else {
						logWarning(Ext.String.format(CtiConstants.LocalizableStrings.LicenseNotFoundMessage,
							licOperations));
						callback(false);
					}
				});
			});
		};

		function getUserHasOperationLicense(data, callback, scope) {
			var storage = Terrasoft.configuration.Storage;
			var key = data.operations.join("-");
			var licStore = storage.UserOperationLicense = storage.UserOperationLicense || [];
			if (licStore[key]) {
				callback.call(scope || this, licStore[key]);
			} else {
				var handler = function(response) {
					licStore[key] = response;
					callback.call(scope || this, licStore[key]);
				};
				callServiceMethod("GetUserHasOperationLicense", handler, data);
			}
		}

		function callServiceMethod(methodName, callback, data) {
			Terrasoft.AjaxProvider.request({
				url: Terrasoft.workspaceBaseUrl + "/rest/CtiRightsService/" + methodName,
				headers: {
					"Accept": "application/json",
					"Content-Type": "application/json"
				},
				method: "POST",
				jsonData: data || {},
				callback: function(request, success, response) {
					var responseObject = {};
					if (success) {
						var obj = Terrasoft.decode(response.responseText);
						responseObject = obj[methodName + "Result"];
					}
					callback.call(this, responseObject);
				},
				scope: this
			});
		}

		/**
		 * Генерирует контейнер с двумя надписями - заголовок и данные для блока идентификации звонка.
		 * @param {Object} config Содержит свойства для генерации блока идентификации.
		 * @returns {Object} Конфигурация блока идентификации.
		 */
		function getIdentificationDataLabel(config) {
			var tag = Ext.isEmpty(config.tag) ? config.name : config.tag;
			var visibleBindTo = Ext.isEmpty(config.visible) ? {"bindTo": "getIsInfoLabelVisible"} : config.visible;
			var captionBindTo = Ext.isEmpty(config.caption)
				? {bindTo: "Resources.Strings." + tag + "LabelCaption"}
				: config.caption;
			var valueBindTo = Ext.isEmpty(config.value)
				? {"bindTo": "getSubscriberData"}
				: config.value;
			var controlConfig = {
				className: "Terrasoft.Container",
				id: config.name + "Info",
				selectors: {wrapEl: "#" + config.name + "Info"},
				markerValue: config.name + "Info",
				visible: visibleBindTo,
				tag: tag,
				items: [
					{
						id: config.name + "Label",
						className: "Terrasoft.Label",
						markerValue: captionBindTo,
						selectors: {wrapEl: "#" + config.name + "Label"},
						classes: {labelClass: "label-caption"},
						caption: captionBindTo
					},
					{
						id: config.name,
						className: "Terrasoft.Label",
						markerValue: valueBindTo,
						selectors: {wrapEl: "#" + config.name},
						classes: {labelClass: "subscriber-info"},
						caption: valueBindTo,
						tag: tag
					}
				]
			};
			return controlConfig;
		}

		/**
		 * Возвращает конфигурацию иконки состояния оператора.
		 * @param {String} stateCode Код cостояния оператора.
		 * @param {Boolean} isSmallIcon (optional) Взять уменьшенную иконку.
		 * @return {Object} Конфигурация изображения.
		 */
		function getOperatorStatusIcon(stateCode, isSmallIcon) {
			if (Ext.isEmpty(stateCode)) {
				return null;
			}
			stateCode = stateCode.toUpperCase();
			var imageCode;
			// TODO: #CC-131 Отображать иконку по ссылке из таблицы SysImage.
			switch (stateCode) {
				case "READY":
				case "ACTIVE":
				case "AVAILABLE":
				case "ONHOOK":
					imageCode = (isSmallIcon) ? "ReadyStatusIcon" : "ReadyStatusProfileMenuItemIcon";
					break;
				case "AWAY":
				case "ONBREAK":
				case "DND":
					imageCode = (isSmallIcon) ? "AwayStatusIcon" : "AwayStatusProfileMenuItemIcon";
					break;
				default:
					imageCode = (isSmallIcon) ? "BusyStatusIcon" : "BusyStatusProfileMenuItemIcon";
					break;
			}
			return resources.localizableImages[imageCode];
		}

		/**
		 * Генерирует контейнер с кнопками для DTMF набора и подписью с набранными символами.
		 * @param {Object} config Содержит свойства для генерации контейнера.
		 * @param {String} config.name Название контейнера.
		 * @param {Object|Boolean} config.visible Объект с конфигурацией для привязки свойства видимости контейнера
		 * или логическое значение видимости контейнера.
		 * @param {Object} config.onButtonClick Объект с конфигурацией для привязки обработчика нажатия на кнопку DTMF
		 * набора.
		 * @param {Object|String} config.dtmfDigitsLabel Объект с конфигурацией для привязки свойства подписи с
		 * набранными символами или строка с набранными символами.
		 * @returns {Object} config Конфигурация контейнера с кнопками для DTMF набора и подписью с набранными
		 * символами.
		 */
		function getDtmfButtonsContainer(config) {
			var buttonCaptions = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "*", "0", "#"];
			var buttonCaptionsAliases = {
				"*": "Star",
				"#": "Hashtag"
			};
			var containerConfig = {
				id: config.name,
				className: "Terrasoft.Container",
				selectors: {wrapEl: "#" + config.name},
				markerValue: config.name,
				classes: {wrapClassName: ["dtmf-buttons-container"]},
				visible: config.visible,
				items: []
			};
			buttonCaptions.forEach(function(caption) {
				var captionAlias = buttonCaptionsAliases[caption];
				var suffix = captionAlias ? captionAlias : caption;
				var buttonName = "DtmfButton" + suffix;
				var buttonConfig = {
					id: buttonName,
					className: "Terrasoft.Button",
					markerValue: buttonName,
					selectors: {wrapEl: "#" + buttonName},
					caption: caption,
					tag: caption,
					click: config.onButtonClick
				};
				containerConfig.items.push(buttonConfig);
			});
			var dtmfDigitsLabelConfig = {
				id: "DtmfDigitsLabel",
				className: "Terrasoft.Label",
				selectors: {wrapEl: "#DtmfDigitsLabel"},
				classes: {labelClass: "dtmf-digits-label"},
				caption: config.dtmfDigitsLabel,
				markerValue: config.dtmfDigitsLabel
			};
			containerConfig.items.push(dtmfDigitsLabelConfig);
			return containerConfig;
		}

		return {
			GetUserHasOperationLicense: getUserHasOperationLicense,
			GetIsTelephonyEnabled: getIsTelephonyEnabled,
			queryCtiSettings: queryCtiSettings,
			getIdentificationDataLabel: getIdentificationDataLabel,
			getOperatorStatusIcon: getOperatorStatusIcon,
			getDtmfButtonsContainer: getDtmfButtonsContainer
		};
	});

				// Autogenerated Code for schema CtiBaseHelper (End)
// Autogenerated Code for schema ViewModuleHelper (Start)
define('ViewModuleHelperResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("ViewModuleHelper", ["ext-base", "terrasoft", "ViewModuleHelperResources", "RightUtilities",
	"CtiBaseHelper", "CtiConstants", "CtiLinkColumnUtility"],
	function(Ext, Terrasoft, resources, RightUtilities, CtiBaseHelper, CtiConstants, CtiLinkColumnUtility) {

		/**
		 * Выводит сообщение в консоль.
		 * @private
		 * @param message Сообщение.
		 */
		function log(message) {
			var console = Ext.global.console;
			if (console && console.log) {
				console.log(message);
			}
		}

		/**
		 * Инициализирует утилиту работы с колонками типа "ссылка".
		 */
		function initLinkColumnUtilities() {
			var linkColumnUtilities = Terrasoft.LinkColumnUtilities || {};
			linkColumnUtilities.Telephony = Ext.create(CtiLinkColumnUtility);
			Terrasoft.LinkColumnUtilities = linkColumnUtilities;
		}

		/**
		 * Инициализирует глобальные настройки при загрузке модуля представления.
		 */
		function initSettings() {
			initLinkColumnUtilities();
		}

		/**
		 * Создает конфигурацию левой панели по умолчанию.
		 * @param {Function} callback Функция обратного вызова.
		 */
		function getSideBarDefaultConfig(callback) {
			var menuConfig = {
				items: [{
					name: "LeftPanelTopMenuModule",
					id: "leftPanelTopMenu",
					showInHeader: true
				}, {
					name: "LeftPanelClientWorkplaceMenu",
					id: "leftPanelClientWorkplaceMenu",
					showInHeader: true
				}, {
					name: "SectionMenuModule",
					id: "sectionMenuModule"
				}]
			};
			callback(menuConfig);
		}

		return {
			getSideBarDefaultConfig: getSideBarDefaultConfig,
			initSettings: initSettings
		};
	});

				// Autogenerated Code for schema ViewModuleHelper (End)
// Autogenerated Code for schema BaseViewModule (Start)
define('BaseViewModuleResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={
	SwfException: 'Для корректной работы системы следует установить Adobe Flash Player версии 10 или выше'
};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("BaseViewModule", ["ext-base", "terrasoft", "BaseViewModuleResources", "performancecountermanager",
	"ConfigurationConstants", "ViewGeneratorV2"],
	function(Ext, Terrasoft, resources, performanceCounterManager, ConfigurationConstants) {

		/**
		 * @class Terrasoft.configuration.BaseViewModule
		 * Базовый класс визуального модуля представления.
		 */
		Ext.define("Terrasoft.configuration.BaseViewModule", {
			extend: "Terrasoft.BaseObject",
			alternateClassName: "Terrasoft.BaseViewModule",

			Ext: null,
			sandbox: null,
			Terrasoft: null,

			/**
			 * Признак асинхронности модуля.
			 * @type {Boolean}
			 */
			isAsync: true,

			/**
			 * Последнее состояние хэша.
			 * @type {Object}
			 */
			currentHash: {
				historyState: ""
			},

			/**
			 * Код домашней страницы по умолчанию.
			 * @type {String}
			 */
			defaultHomeModule: ConfigurationConstants.DefaultHomeModule,

			/**
			 * Код домашней страницы.
			 * @type {String}
			 */
			homeModule: "",

			/**
			 * Имя основного контейнера модуля.
			 * @type {Object[]}
			 */
			containerName: "ViewModuleContainer",

			/**
			 * Конфигурация представления модуля.
			 * @type {Object[]}
			 */
			viewConfig: null,

			/**
			 * Имя класса - генератора представления.
			 * @type {String}
			 */
			viewGeneratorClass:  "Terrasoft.ViewGenerator",

			/**
			 * Разница схемы представления.
			 * @type {Object[]}
			 */
			diff: [{
				"operation": "insert",
				"name": "centerPanel",
				"values": {
					"id": "centerPanel",
					"selectors": { "wrapEl": "#centerPanel" },
					"itemType": Terrasoft.ViewItemType.CONTAINER,
					"wrapClass": ["default-center-panel-content"]

				}
			}],

			/**
			 * Инициализирует модуль.
			 * @virtual
			 * @param {Function} callback Функция, которая будет вызвана по завершению.
			 * @param {Object} scope Контекст, в котором будет вызвана функция callback.
			 */
			init: function(callback, scope) {
				Terrasoft.chain(
					this.initSysSettings,
					this.initViewConfig,
					this.initHomePage,
					function() {
						this.subscribeMessages();
						callback.call(scope);
					},
					this
				);
			},

			/**
			 * Отображение представление.
			 * @virtual
			 * @param {Ext.Element} renderTo Ссылка на контейнер, в котором будет отображаться представление.
			 */
			render: function(renderTo) {
				this.renderView(renderTo);
				this.loadNonVisibleModules();
				this.initHistoryState();
				this.checkWebSocketSupport();
			},

			/**
			 * Проверяет, является ли контекст выполнения экземпляром класса, или прототипом базовых.
			 * @protected
			 * @virtual
			 * @return {Boolean} Возвращает true если текущий контекст выполнения - экземпляр класса,
			 * false в обратном случае.
			 */
			isInstance: function() {
				return this.hasOwnProperty("instanceId") && this.instanceId;
			},

			/**
			 * Создеает схему представления на основе параметра разницы для всей иерархии классов.
			 * @protected
			 * @virtual
			 * @return {Object[]} Возвращает схему представления.
			 */
			getSchema: function() {
				var baseSchema = [];
				if (this.superclass.getSchema) {
					baseSchema = this.superclass.getSchema();
				}
				return this.hasDiff() ? Terrasoft.JsonApplier.applyDiff(baseSchema, this.diff) : baseSchema;
			},

			/**
			 * Проверяет, есть ли у контекста параметр разницы для схемы.
			 * @protected
			 * @virtual
			 * @return {Boolean} Возвращает true если есть, false в обратном случае.
			 */
			hasDiff: function() {
				var isInstance = this.isInstance();
				var diff = this.diff;
				return (isInstance && (diff !== this.superclass.diff)) ||
					(!isInstance && (this.hasOwnProperty("diff") && !Ext.isEmpty(diff)));
			},

			/**
			 * Создает конфигурацию представления модуля.
			 * @protected
			 * @virtual
			 * @param {Object} config Объект конфигурации.
			 * @param {Function} callback Функция, которая будет вызвана по завершению.
			 * @param {Object} scope Контекст, в котором будет вызвана функция callback.
			 */
			buildView: function(config, callback, scope) {
				var viewGenerator = this.createViewGenerator();
				var schema = {
					viewConfig: this.getSchema()
				};
				var viewConfig = Ext.apply({
					schema: schema
				}, config);
				viewGenerator.generate(viewConfig, callback, scope);
			},

			/**
			 * Инициализирует объект конфигурации представления модуля.
			 * @protected
			 * @virtual
			 * @param {Function} callback Функция, которая будет вызвана по завершению.
			 * @param {Object} scope Контекст, в котором будет вызвана функция callback.
			 */
			initViewConfig: function(callback, scope) {
				var generatorConfig = {};
				generatorConfig.viewModelClass = this.self;
				this.buildView(generatorConfig, function(view) {
					this.viewConfig = view;
					callback.call(scope);
				}, this);
			},

			/**
			 * Создает экземпляр класса Terrasoft.ViewGenerator.
			 * @protected
			 * @virtual
			 * @return {Terrasoft.ViewGenerator} Возвращает объект Terrasoft.ViewGenerator.
			 */
			createViewGenerator: function() {
				return this.Ext.create(this.viewGeneratorClass);
			},

			/**
			 * Инициализирует основные системные настройки.
			 * @protected
			 * @virtual
			 * @param {Function} callback Функция, которая будет вызвана по завершению.
			 * @param {Object} scope Контекст, в котором будет вызвана функция callback.
			 */
			initSysSettings: function(callback, scope) {
				Terrasoft.SysSettings.querySysSettings(this.getSysSettingsNames(), function(values) {
					this.onSysSettingsResponse(values);
					callback.call(scope);
				}, this);
			},

			/**
			 * Возвращает массив названий системных настроек, значения которых запрашиваются и кэшируются при входе в
			 * систему пользователем.
			 * @protected
			 * @virtual
			 * @return {String[]} Массив названий системных настроек, значения которых запрашиваются и кэшируются при
			 * входе в систему пользователем.
			 */
			getSysSettingsNames: function() {
				return ["BuildType", "ShowDemoLinks", "PrimaryCulture", "SchedulerTimingStart",
					"SchedulerTimingEnd", "SchedulerDisplayTimingStart", "PrimaryCurrency"];
			},

			/**
			 * Обрабатывает результаты загрузки системных настроек.
			 * @protected
			 * @virtual
			 */
			onSysSettingsResponse: Terrasoft.emptyFn,

			/**
			 * Создает и загружает основные панели сайта.
			 * @protected
			 * @virtual
			 * @param {Ext.Element} renderTo Ссылка на контейнер, в котором будет отображаться представление.
			 */
			renderView: function(renderTo) {
				var view = this.view = this.Ext.create("Terrasoft.Container", {
					id: this.containerName,
					selectors: {wrapEl: "#" +  this.containerName},
					items: Terrasoft.deepClone(this.viewConfig),
					markerValue: this.containerName
				});
				view.render(renderTo);
			},

			/**
			 * Инициализирует начальное состояние.
			 * @protected
			 * @virtual
			 */
			initHistoryState: function() {
				var token = this.sandbox.publish("GetHistoryState");
				if (token) {
					this.onHistoryStateChanged(token);
				}
			},

			/**
			 * Проверяет поддержку браузером WebSocket.
			 * @protected
			 * @virtual
			 */
			checkWebSocketSupport: function() {
				var isFlashError = window.WEB_SOCKET_SWF_EXCEPTION || false;
				if (isFlashError) {
					var buttonsConfig = {
						buttons: [Terrasoft.MessageBoxButtons.OK.returnCode],
						defaultButton: 0
					};
					Terrasoft.showInformation(resources.localizableStrings.SwfException,
						this.onFlashPlayerDownload, this, buttonsConfig);
				}
			},

			/**
			 * Открывает окно загрузки последнего flashplayer.
			 * @protected
			 * @virtual
			 * @param {Object} result Результат работы информационного окна.
			 */
			onFlashPlayerDownload: function(result) {
				if (result === Terrasoft.MessageBoxButtons.OK.returnCode) {
					window.open("http://get.adobe.com/ru/flashplayer/", "_blank");
				}
			},

			/**
			 * Загружает утилитные, невидимые модули.
			 * @protected
			 * @virtual
			 */
			loadNonVisibleModules: function() {
				var sandbox = this.sandbox;
				sandbox.loadModule("NavigationModule");
			},

			/**
			 * Подписывается на сообщения.
			 * @protected
			 * @virtual
			 */
			subscribeMessages: function() {
				var sandbox = this.sandbox;
				sandbox.subscribe("LoadModule", this.onLoadModule, this);
				sandbox.subscribe("HistoryStateChanged", this.onHistoryStateChanged, this);
				sandbox.subscribe("RefreshCacheHash", this.refreshCacheHash, this);
				sandbox.subscribe("NavigationModuleLoaded", this.loadMainPanelsModules, this);
			},

			/**
			 * Загружает модули в основные панели.
			 * @protected
			 * @virtual
			 */
			loadMainPanelsModules: function() {
				var schema = this.getSchema();
				Terrasoft.iterateChildItems(schema, function(iterationConfig) {
					var item = iterationConfig.item;
					if (item.itemType === Terrasoft.ViewItemType.MODULE) {
						this.onLoadModule({
							moduleName: item.moduleName,
							renderTo: item.name
						});
					}
				}, this);
				this.loadHomePage();
			},

			/**
			 * Инициализирует код домашней страницы для текущего пользователя.
			 * @protected
			 * @virtual
			 * @param {Function} callback Функция, которая будет вызвана по завершению.
			 * @param {Object} scope Контекст, в котором будет вызвана функция callback.
			 */
			initHomePage: function(callback, scope) {
				var esq = Ext.create("Terrasoft.EntitySchemaQuery", {
					rootSchemaName: "SysAdminUnit"
				});
				esq.addColumn("HomePage.Code", "Code");
				esq.getEntity(Terrasoft.SysValue.CURRENT_USER.value, function(result) {
					this.homeModule = this.defaultHomeModule;
					var entity = result.entity;
					if (result.success && entity) {
						this.homeModule = entity.get("Code") || this.homeModule;
					}
					callback.call(scope);
				}, this);
			},

			/**
			 * Загружает модуль.
			 * @protected
			 * @virtual
			 * @param {Object} config Конфигурация загрузки модуля.
			 * @param {String} config.renderTo Имя контейнера для модуля.
			 * @param {String} config.moduleId Уникальный идентификатор модуля.
			 * @param {String} config.moduleName Имя загружаемого модуля.
			 * @param {Boolean} config.keepAlive Признак того, будет ли уничтожен предыдущий модуль,
			 * загруженный в контейнер.
			 */
			onLoadModule: function(config) {
				var renderTo = config.renderTo;
				if (!Ext.isEmpty(renderTo)) {
					this.sandbox.loadModule(config.moduleName, {
						renderTo: renderTo,
						id: config.moduleId,
						keepAlive: config.keepAlive || false
					});
				}
			},

			/**
			 * Находит имя модуля в объекте состояния браузера.
			 * @protected
			 * @virtual
			 * @param {Object} token Объект состояния браузера.
			 * @return {String} Возвращает имя модуля.
			 */
			getModuleName: function(token) {
				return token.hash ? token.hash.moduleName : null;
			},

			/**
			 * Обрабатывае изменение состояния. Запускает таймер производительности.
			 * @protected
			 * @virtual
			 */
			onStateChanged: function() {
				performanceCounterManager.clearAllTimeStamps();
				performanceCounterManager.setTimeStamp("StateChanged");
			},

			/**
			 * Обрабатывает новое состояние, загружает модуль цепочки.
			 * @protected
			 * @virtual
			 * @param {Object} token Объект нового состояния браузера.
			 */
			loadChainModule: function(token) {
				var currentState = this.sandbox.publish("GetHistoryState");
				var moduleId = currentState.state && currentState.state.moduleId;
				var moduleName = this.getModuleName(token);
				if (!moduleId || !moduleName) {
					return;
				}
				this.onStateChanged();
				this.onLoadModule({
					moduleName: moduleName,
					moduleId: moduleId,
					renderTo: "centerPanel"
				});
			},

			/**
			 * Обрабатывает новое состояние, загружает модуль.
			 * @protected
			 * @virtual
			 * @param {Object} token Объект нового состояния браузера.
			 */
			loadModuleFromHistoryState: function(token) {
				var moduleName = this.getModuleName(token);
				if (!moduleName) {
					return;
				}
				var currentState = this.sandbox.publish("GetHistoryState");
				var id = this.generateModuleId(moduleName, currentState);
				this.onStateChanged();
				this.onLoadModule({
					moduleName: moduleName,
					moduleId: id,
					renderTo: "centerPanel"
				});
			},

			/**
			 * Генерирует уникальный идентификатор модуля на основе имени модуля и текущего состояния.
			 * @protected
			 * @virtual
			 * @param {String} moduleName Имя модуля.
			 * @param {Object} currentState Объект состояния браузера.
			 * @return {String} Возвращает уникальный идентификатор модуля.
			 */
			generateModuleId: function(moduleName, currentState) {
				var id = currentState.state && currentState.state.id;
				var result = moduleName;
				var hash = currentState.hash;
				var schemaName = (currentState.hash && currentState.hash.entityName) || "";
				if (!this.Ext.isEmpty(hash) && !this.Ext.isEmpty(hash.recordId)) {
					result += "_" + hash.recordId;
				}
				return id || result + "_" + schemaName;
			},

			/**
			 * Обрабатывает изменение состояния. Загружает необходимые модули.
			 * @protected
			 * @virtual
			 * @param {Object} token Объект нового состояния браузера.
			 */
			onHistoryStateChanged: function(token) {
				if (this.currentHash.historyState === token.hash.historyState) {
					this.loadChainModule(token);
				} else {
					this.refreshCacheHash();
					this.loadModuleFromHistoryState(token);
				}
			},

			/**
			 * Обновляет текущее состояние для модуля.
			 * @protected
			 * @virtual
			 */
			refreshCacheHash: function() {
				var currentHistoryState = this.sandbox.publish("GetHistoryState");
				this.currentHash.historyState = currentHistoryState.hash.historyState;
			},

			/**
			 * Открывает домашнюю страницу, если состояние не было установленно.
			 * @protected
			 * @virtual
			 */
			loadHomePage: function() {
				var state = this.sandbox.publish("GetHistoryState");
				var hash = state.hash;
				if (!hash.historyState) {
					this.openHomePage();
				} else if (hash.moduleName === "MainMenu") {
					this.replaceHomePage();
				}
			},

			/**
			 * Открывает домашнюю страницу.
			 * @protected
			 * @virtual
			 */
			openHomePage: function() {
				var hash = this.getHomePagePath();
				this.sandbox.publish("PushHistoryState", {hash: hash});
			},

			/**
			 * Заменяет текущую страницу домашней.
			 * @private
			 */
			replaceHomePage: function() {
				var hash = this.getHomePagePath();
				this.sandbox.publish("ReplaceHistoryState", {hash: hash});
			},

			/**
			 * Возвращает путь к домашней странице.
			 * @protected
			 * @virtual
			 * @return {String} Путь к домашней странице.
			 */
			getHomePagePath: function() {
				var module = this.Terrasoft.configuration.ModuleStructure[this.homeModule];
				return module ? this.Terrasoft.combinePath(module.sectionModule, module.sectionSchema) :
					this.getHomeModulePath();
			},

			/**
			 * Возвращает путь к стартовому модулю.
			 * @protected
			 * @virtual
			 * @return {String} Путь к стартовому модулю.
			 */
			getHomeModulePath: function() {
				return this.homeModule;
			}
		});

		return Terrasoft.BaseViewModule;

	});

				// Autogenerated Code for schema BaseViewModule (End)
// Autogenerated Code for schema ConfigurationViewModule (Start)
define('ConfigurationViewModuleResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={
	ProcessPageCaption: 'Запуск процесса',
	BuyNowUrl: 'http://www.terrasoft.ru/company/feedback/presentation',
	OnlineHelpUrl: 'vrsn=2.3&lang=ru&style=terra&group=13&agid=23&hash=8rGdFq9jCW7CGnVe3ZYXJnXMcTw='
};
var localizableImages={
	'OnlineHelpRU': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'ConfigurationViewModule', resourceItemName: 'OnlineHelpRU' }},
	'OnlineHelpEN': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'ConfigurationViewModule', resourceItemName: 'OnlineHelpEN' }},
	'BuyNowRU': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'ConfigurationViewModule', resourceItemName: 'BuyNowRU' }},
	'BuyNowEN': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'ConfigurationViewModule', resourceItemName: 'BuyNowEN' }},
	'TrialRU': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'ConfigurationViewModule', resourceItemName: 'TrialRU' }},
	'TrialEN': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'ConfigurationViewModule', resourceItemName: 'TrialEN' }}
};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("ConfigurationViewModule", ["ext-base", "sandbox", "terrasoft", "ConfigurationViewModuleResources",
			"LookupUtilities", "ViewModuleHelper", "ConfigurationConstants", "LeftPanelUtilitiesV2", "ModalBox",
			"IntroPageUtilities", "WelcomeScreenModule", "BaseViewModule"],
		function(Ext, sandbox, Terrasoft, resources, LookupUtilities,
				ViewModuleHelper, ConfigurationConstants, LeftPanelUtilities, ModalBox, IntroPageUtilities) {

			/**
			 * @class Terrasoft.configuration.DemoButtons
			 * Класс создающий демо кнопки.
			 */
			Ext.define("Terrasoft.configuration.DemoButtons", {
				extend: "Terrasoft.BaseViewModule",
				alternateClassName: "Terrasoft.DemoButtons",

				/**
				 * Конфигурация демо кнопок.
				 * @type {Object[]}
				 */
				buttonsConfig: null,

				/**
				 * Конфигурация демо-кнопок с системной настройкой.
				 * @type {Object[]}
				 */
				buttonsSysSettingConfig: null,

				/**
				 * Размер расстояния между кнопками.
				 * @type {Number}
				 */
				separatorSize: 5,

				/**
				 * Классы демо кнопок.
				 * @type {String[]}
				 */
				buttonClasses: ["demo-btn"],

				/**
				 * Открывает окно заказа презентации.
				 * @protected
				 * @virtual
				 */
				openBuyNowWindow: function() {
					window.open(resources.localizableStrings.BuyNowUrl);
				},

				/**
				 * Открывает вкладку браузера с триальной версией продукта.
				 * @protected
				 * @virtual
				 */
				openTrialWindow: function(value) {
					window.open(value);
				},

				/**
				 * Генерирует строку параметров для окна чата с менеджером.
				 * @protected
				 * @virtual
				 */
				createOnlineHelpButtonParameters: function() {
					var parameters = {
						ttl: document.title && encodeURI(document.title.substring(0, 255)),
						url: encodeURI(window.location.href),
						referrer: encodeURI(encodeURI(document.referrer)),
						cd: window.screen.colorDepth,
						rh: screen.height,
						rw: screen.width
					};
					var parametersArray = [resources.localizableStrings.OnlineHelpUrl];
					Terrasoft.each(parameters, function(parameter, name) {
						parametersArray.push(name + "=" + parameter);
					}, this);
					return parametersArray.join("&");
				},

				/**
				 * Открывает окно чата с менеджером.
				 * @protected
				 * @virtual
				 */
				openOnlineHelpWindow: function() {
					var protocol = (("https:" === document.location.protocol) ? "https://" : "http://");
					var srcOpen = protocol + "ok.kolobiz.com/client/?" + this.createOnlineHelpButtonParameters();
					if (navigator.userAgent.toLowerCase().indexOf("opera") !== -1 && window.event.preventDefault) {
						window.event.preventDefault();
					}
					var newWindow = window.open(srcOpen, "ok_kolobiz20122359",
							"toolbar=0,scrollbars=0,location=0,status=1,menubar=0,width=620,height=490,resizable=1");
					newWindow.focus();
					newWindow.opener = window;
				},

				/**
				 * Находит и возвращает текущую культуру.
				 * @protected
				 * @virtual
				 * @return {String} Возвращает текущую культуру.
				 */
				getCurrentCulture: function() {
					var cachedSettings = Terrasoft.SysSettings.cachedSettings;
					return cachedSettings.PrimaryCulture.displayValue;
				},

				/**
				 * Создает и отображет демо кнопку по переданной конфигурации.
				 * @protected
				 * @virtual
				 * @param {Object} config Конфигурация демо кнопки.
				 */
				createDemoButton: function(config) {
					var culture = this.getCurrentCulture();
					var cultureParts = culture.split("-");
					var currentLocalizationImageName = config.localizableImagesPrefix + cultureParts[0].toUpperCase();
					var imageConfig = resources.localizableImages[currentLocalizationImageName];
					var element = Ext.create("Terrasoft.Button", {
						renderTo: Ext.getBody(),
						id: config.id,
						imageConfig: imageConfig,
						classes: {
							wrapperClass: this.buttonClasses,
							imageClass: [config.imageClassPrefix + cultureParts[0]]
						},
						click: {bindTo: config.click}
					});
					element.bind(this);
				},

				/*
				 * Инициализирует начальные данные.
				 * @protected
				 */
				init: function() {
					this.initButtonsConfig();
					this.initButtons();
				},
				/**
				 * Создает конфигурацию демо кнопок.
				 */
				initButtonsConfig: function() {
					if (!this.buttonsConfig) {
						this.buttonsConfig = [];
					}
					this.buttonsConfig.push({
						localizableImagesPrefix: "BuyNow",
						id: "buy-now-btn",
						imageClassPrefix: "buy-now-btn-img-",
						click: "openBuyNowWindow"
					});
					this.buttonsConfig.push({
						localizableImagesPrefix: "OnlineHelp",
						id: "online-help-btn",
						imageClassPrefix: "online-help-btn-img-",
						click: "openOnlineHelpWindow"
					});
					if (!this.buttonsSysSettingConfig) {
						this.buttonsSysSettingConfig = [];
					}
					this.buttonsSysSettingConfig.push({
						localizableImagesPrefix: "Trial",
						id: "trial-btn",
						imageClassPrefix: "trial-btn-img-",
						position: "0",
						sysSetting: "TrialUrl",
						action: this.openTrialWindow
					});
				},

				/**
				 * Создает демо кнопки, актуализирует их позицию.
				 */
				initButtons: function() {
					Terrasoft.chain(
							this.prepareButtonsConfig,
							function(next) {
								Terrasoft.each(this.buttonsConfig, this.createDemoButton, this);
								next();
							},
							function(next) {
								Ext.EventManager.addListener(window, "resize", this.updateButtonsPosition, this);
								next();
							},
							this.updateButtonsPosition, this);
				},

				/**
				 * Подготавливает конфигурацию демо-кнопок.
				 * @param callback {Function} Функция обратного выбоза.
				 */
				prepareButtonsConfig: function(callback) {
					var iterator = this.buttonsSysSettingConfig.length;
					Terrasoft.each(this.buttonsSysSettingConfig, function(item) {
						Terrasoft.chain(
								function(next) {
									Terrasoft.SysSettings.querySysSettingsItem(item.sysSetting, function(value) {
										next(value);
									});
								},
								function(next, value) {
									if (value) {
										var prepareButton = {};
										var onClickName = item.localizableImagesPrefix + "Click";
										this[onClickName] = function() {
											item.action(value);
										};
										prepareButton.localizableImagesPrefix = item.localizableImagesPrefix;
										prepareButton.id = item.id;
										prepareButton.imageClassPrefix = item.imageClassPrefix;
										prepareButton.click = onClickName;
										this.buttonsConfig.splice(item.position, 0, prepareButton);
									}
									next();
								},
								function() {
									if (--iterator === 0) {
										callback();
									}
								}, this);
					}, this);
				},

				/**
				 * Актуализирует позицию кнопок.
				 * @protected
				 * @virtual
				 */
				updateButtonsPosition: function() {
					var buttons = this.buttonsConfig.map(function(buttonConfig) {
						var element = Ext.getCmp(buttonConfig.id);
						return element.getWrapEl();
					}, this);
					var buttonsWidthSum = 0;
					Terrasoft.each(buttons, function(button) {
						buttonsWidthSum += button.dom.offsetWidth;
					}, this);
					var buttonPosition =
							(window.innerWidth - buttonsWidthSum - (this.separatorSize * (buttons.length - 1))) / 2;
					Terrasoft.each(buttons, function(button) {
						button.setStyle("left", buttonPosition + "px");
						buttonPosition += (button.dom.offsetWidth + this.separatorSize);
					}, this);
				}
			})
			;

			/**
			 * @class Terrasoft.configuration.ViewModule
			 * Класс визуального модуля представления.
			 */
			var viewModule = Ext.define("Terrasoft.configuration.ConfigurationViewModule", {
				extend: "Terrasoft.BaseViewModule",
				alternateClassName: "Terrasoft.ConfigurationViewModule",

				Ext: null,
				sandbox: null,
				Terrasoft: null,

				/**
				 * Схема домашней страницы по умолчанию.
				 * @type {String}
				 */
				defaultIntroPage: "SimpleIntro",

				diff: [
					{
						"operation": "insert",
						"name": "leftPanel",
						"values": {
							"itemType": Terrasoft.ViewItemType.MODULE,
							"moduleName": "SideBarModule",
							"classes": {
								"wrapClassName": ["left-panel", "left-panel-scroll", "fixed"]
							}
						}
					}, {
						"operation": "insert",
						"name": "mainHeader",
						"values": {
							"itemType": Terrasoft.ViewItemType.MODULE,
							"moduleName": "MainHeaderModule",
							"classes": {
								"wrapClassName": ["main-header", "fixed"]
							}
						}
					}, {
						"operation": "insert",
						"name": "centerPanelContainer",
						"values": {
							"itemType": Terrasoft.ViewItemType.CONTAINER,
							"wrapClass": ["center-panel"],
							"id": "centerPanelContainer",
							"selectors": {"wrapEl": "#centerPanelContainer"},
							"items": []
						}
					}, {
						"operation": "insert",
						"name": "communicationPanel",
						"values": {
							"itemType": Terrasoft.ViewItemType.MODULE,
							"moduleName": "CommunicationPanelModule",
							"classes": {
								"wrapClassName": ["communication-panel", "communication-panel-scroll", "fixed"]
							}
						}
					}, {
						"operation": "move",
						"name": "centerPanel",
						"parentName": "centerPanelContainer",
						"propertyName": "items",
						"index": 0
					}, {
						"operation": "insert",
						"parentName": "centerPanelContainer",
						"propertyName": "items",
						"name": "rightPanel",
						"index": 1,
						"values": {
							"itemType": Terrasoft.ViewItemType.MODULE,
							"moduleName": "RightSideBarModule",
							"classes": {
								"wrapClassName": ["default-right-panel", "fixed"]
							}
						}
					}
				],

				/**
				 * @inheritDoc Terrasoft.configuration.BaseViewModule#getSysSettingsNames
				 * @overridden
				 */
				getSysSettingsNames: function() {
					var sysSettings = this.callParent(arguments) || [];
					sysSettings.push("DefaultIntroPage");
					return sysSettings;
				},

				/**
				 * Обрабатывает результаты загрузки системных настроек.
				 * @protected
				 * @overridden
				 * @param {Object[]} values Значения системных настроек.
				 */
				onSysSettingsResponse: function(values) {
					this.callParent(arguments);
					if (values.ShowDemoLinks) {
						this.prepareDemoLinkButtons();
					}
					var defaultIntroPage = values.DefaultIntroPage;
					if (defaultIntroPage) {
						IntroPageUtilities.getDefaultIntroPageName(defaultIntroPage.value, function(defaultIntroPageName) {
							this.defaultIntroPage = defaultIntroPageName;
						}, this);
					}
				},

				/**
				 * Создает и отображает кнопки "Заказать презентацию" и "On-line чат".
				 * @protected
				 * @virtual
				 */
				prepareDemoLinkButtons: function() {
					var buttons = this.Ext.create("Terrasoft.DemoButtons");
					buttons.init();
				},

				/**
				 * @inheritDoc Terrasoft.configuration.BaseViewModule#init
				 * @overridden
				 */
				init: function(callback, scope) {
					this.callParent([
						function() {
							if (Ext.isFunction(ViewModuleHelper.initSettings)) {
								ViewModuleHelper.initSettings();
							}
							LeftPanelUtilities.initCollapsedState();
							callback.call(scope);
						}, this
					]);
				},

				/**
				 * @inheritdoc Terrasoft.BaseSchemaModule#render
				 * @protected
				 * @overridden
				 */
				render: function() {
					this.callParent(arguments);
					this.loadWelcomeScreen();
				},

				/**
				 * @inheritDoc Terrasoft.configuration.BaseViewModule#loadNonVisibleModules
				 * @overridden
				 */
				loadNonVisibleModules: function() {
					this.callParent(arguments);
					var sandbox = this.sandbox;
					sandbox.loadModule("ProcessModuleV2");
					sandbox.loadModule("HotkeysModule");
					sandbox.loadModule("SyncModule");
				},

				/**
				 * @inheritDoc Terrasoft.configuration.BaseViewModule#subscribeMessages
				 * @overridden
				 */
				subscribeMessages: function() {
					this.callParent(arguments);
					var sandbox = this.sandbox;
					sandbox.subscribe("SideBarModuleDefInfo", this.onSideBarModuleDefInfo, this);
					sandbox.subscribe("ShowHideRightSidePanel", this.onShowHideRightPanel, this);
					sandbox.subscribe("SideBarVisibilityChanged", this.onSideBarVisibilityChanged, this);
				},

				/**
				 * Генерирует конфигурацию для модуля левой панели.
				 * @protected
				 * @virtual
				 */
				onSideBarModuleDefInfo: function() {
					var sideBarConfig = this.sandbox.publish("GetSideBarConfig");
					if (sideBarConfig) {
						this.sandbox.publish("PushSideBarModuleDefInfo", sideBarConfig.items);
					} else {
						var me = this;
						ViewModuleHelper.getSideBarDefaultConfig(function(config) {
							var menuItems = Ext.isObject(config) ? config.items : config;
							me.sandbox.publish("PushSideBarModuleDefInfo", menuItems);
						});
					}
				},

				/**
				 * Изменяет css класс для элемента.
				 * @protected
				 * @virtual
				 * @param {String} elementName Имя элемента.
				 * @param {String} oldCssClass Старый css класс элемента.
				 * @param {String} cssClass Новый css класс элемента.
				 */
				changeItemClass: function(elementName, oldCssClass, cssClass) {
					var element = Ext.get(elementName);
					if (element.hasCls(oldCssClass)) {
						element.removeCls(oldCssClass);
						element.addCls(cssClass);
					}
				},

				/**
				 * Показывает или скрывает правую панель.
				 * @protected
				 * @virtual
				 * @param {Object} config Конфигурация действия.
				 * @param {Boolean} config.forceShow Признак показа правой панели. Если установлен в true,
				 * панель будет показана, если в false, панель скроется.
				 *
				 */
				onShowHideRightPanel: function(config) {
					var forceShow = config && config.forceShow;
					var centerPanelClasses = ["center-panel-content", "default-center-panel-content"];
					var rightPanelClasses = ["right-panel", "default-right-panel"];
					if (forceShow) {
						rightPanelClasses.reverse();
						centerPanelClasses.reverse();
					}
					this.changeItemClass("rightPanel", rightPanelClasses[0], rightPanelClasses[1]);
					this.changeItemClass("centerPanel", centerPanelClasses[0], centerPanelClasses[1]);
				},

				/**
				 * Скрывает или загружает модуль в указанную панель.
				 * @pretected
				 * @virtual
				 * @param {Object} args Параметры изменения видимости.
				 * @param {String} args.panel Имя панели.
				 * @param {String} args.moduleName Имя модуля.
				 */
				onSideBarVisibilityChanged: function(args) {
					var panelName = args.panel || "centerPanel";
					if (args.moduleName) {
						this.sandbox.loadModule(args.moduleName, {
							renderTo: panelName
						});
					} else {
						var panel = Ext.getCmp(panelName);
						var panelEl = panel.getWrapEl().el;
						panelEl.setVisibilityMode(Ext.dom.AbstractElement.DISPLAY);
						panelEl.setVisible(false);
					}
				},

				/**
				 * @inheritDoc Terrasoft.configuration.BaseViewModule#onLoadModule
				 * @overridden
				 */
				onLoadModule: function(config) {
					if (config.moduleName === "ProcessExecute") {
						this.loadProcessModule();
					} else {
						this.callParent(arguments);
					}
				},

				/**
				 * Загружает модуль справочника с перечнем бызнесс процессов для запуска.
				 * @protected
				 * @virtual
				 */
				loadProcessModule: function() {
					var vwSysProcessFilters = Terrasoft.createFilterGroup();
					vwSysProcessFilters.name = "vwSysProcessFiler";
					vwSysProcessFilters.logicalComparisonTypes = Terrasoft.LogicalOperatorType.AND;
					var sysWorkspaceFilter = Terrasoft.createColumnFilterWithParameter(
							Terrasoft.ComparisonType.EQUAL, "SysWorkspace",
							Terrasoft.SysValue.CURRENT_WORKSPACE.value);
					vwSysProcessFilters.addItem(sysWorkspaceFilter);
					var isMaxVersionFilter = Terrasoft.createColumnFilterWithParameter(
							Terrasoft.ComparisonType.EQUAL, "IsMaxVersion", 1);
					vwSysProcessFilters.addItem(isMaxVersionFilter);
					var businessProcessTagFilter = Terrasoft.createColumnFilterWithParameter(
							Terrasoft.ComparisonType.EQUAL, "TagProperty",
							ConfigurationConstants.SysProcess.BusinessProcessTag);
					vwSysProcessFilters.addItem(businessProcessTagFilter);
					var config = {
						entitySchemaName: "VwSysProcess",
						mode: "processMode",
						captionLookup: resources.localizableStrings.ProcessPageCaption,
						multiSelect: false,
						columnName: "Caption",
						filters: vwSysProcessFilters,
						commandLineEnabled: true
					};
					var handler = Terrasoft.emptyFn;
					LookupUtilities.OpenLookupPage(this.sandbox, {config: config, handler: handler}, this, null, false);
				},

				/**
				 * Загружает приветственное окно при входе в систему.
				 * @private
				 */
				loadWelcomeScreen: function() {
					var isFirstLogin = this.Terrasoft.isFirstLogin;
					if (!isFirstLogin) {
						return;
					}
					this.Terrasoft.SysSettings.querySysSettings([
						"UseWelcomeScreen", "BuildType"
					], function(sysSettings) {
						var useWelcomeScreen = sysSettings.UseWelcomeScreen;
						if (!useWelcomeScreen) {
							return;
						}
						var buildType = sysSettings.BuildType;
						if (buildType.value === ConfigurationConstants.BuildType.Public) {
							this.loadWelcomeScreenModule();
						} else {
							this.Terrasoft.require(["profile!WelcomeScreenModule"], function(profile) {
								if (profile && profile.isShown) {
									return;
								}
								this.loadWelcomeScreenModule();
								this.Terrasoft.saveUserProfile("WelcomeScreenModule", {isShown: true});
							}, this);
						}
					}, this);
				},

				/**
				 * Загружает модуль приветственного окна.
				 * @private
				 */
				loadWelcomeScreenModule: function() {
					var config = {
						minWidth: 100,
						minHeight: 100,
						boxClasses: ["welcome-screen-modal-box"]
					};
					var moduleName = "WelcomeScreenModule";
					var moduleId = this.sandbox.id + "_" + moduleName;
					var renderTo = ModalBox.show(config, function() {
						this.sandbox.unloadModule(moduleId, renderTo);
					}.bind(this));
					this.sandbox.loadModule(moduleName, {
						id: moduleId,
						renderTo: renderTo
					});
				},

				/**
				 * @inheritDoc Terrasoft.configuration.BaseViewModule#getHomeModulePath
				 * @overridden
				 */
				getHomeModulePath: function() {
					return this.Terrasoft.combinePath(this.homeModule, this.defaultIntroPage);
				}
			});
			return viewModule;

		})
;

				// Autogenerated Code for schema ConfigurationViewModule (End)
// Autogenerated Code for schema MainHeaderExtensions (Start)
define('MainHeaderExtensionsResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
/**
 * Расширения модуля шапки приложения для телефонии. Перекрывает методы базового модуля.
 */
define("MainHeaderExtensions", ["ext-base", "terrasoft", "IconHelper", "CtiBaseHelper"],
	function(Ext, Terrasoft, IconHelper, CtiBaseHelper) {

		/**
		 * Возвращает конфигурацию иконки состояния оператора для кнопки профиля.
		 * @private
		 * @return {Object} Конфигурация изображения.
		 */
		function getOperatorStatusProfileIcon() {
			var stateCode = this.get("AgentState");
			return CtiBaseHelper.getOperatorStatusIcon(stateCode, true);
		}

		/**
		 * Возвращает конфигурацию иконки меню состояния оператора.
		 * @private
		 * @param {String} stateCode Код cостояния оператора.
		 * @return {Object} Конфигурация изображения.
		 */
		function getProfileMenuStatusIcon(stateCode) {
			return CtiBaseHelper.getOperatorStatusIcon(stateCode);
		}

		/**
		 * Дополнительно инициализирует модель представления шапки приложения.
		 * @param {Terrasoft.BaseViewModel} viewModel
		 * @overridden
		 */
		function customInitViewModel(viewModel) {
			var sandbox = viewModel.getSandbox();
			var ctiModel = Terrasoft.CtiModel;
			if (ctiModel && ctiModel.get("IsConnected")) {
				this.set("AgentState", ctiModel.get("AgentState"));
			}
			sandbox.subscribe("AgentStateChanged", function(stateCode) {
				viewModel.set("AgentState", stateCode);
			}, viewModel);
			sandbox.subscribe("CtiPanelConnected", viewModel.onCtiPanelConnected, viewModel);
		}

		/**
		 * Обрабатывает соединение с cti панелью.
		 * @private
		 */
		function onCtiPanelConnected() {
			this.executeAgentStateQuery(function(result) {
				var agentStates = this.getAgentStates(result);
				this.generateAgentStateMenuItems(agentStates, this.loadProfileButtonMenu);
			});
		}

		/**
		 * Расширяет свойства модели представления шапки приложения.
		 * @param {Object} values Существующие свойства модели.
		 * @overridden
		 */
		function extendViewModelValues(values) {
			Ext.apply(values, {

				/**
				 * Текущее состояние оператора.
				 * @private
				 * @type {String}
				 */
				AgentState: ""
			});
		}

		/**
		 * Расширяет контейнер изображения фотографии пользователя.
		 * @param {Terrasoft.Container} imageContainer Контейнер изображения фотографии пользователя.
		 * @overridden
		 */
		function extendImageContainer(imageContainer) {
			var operatorStatusIconConfig = IconHelper.createIconButtonConfig({
				name: "operatorStatusIcon",
				imageClass: "operator-status-icon",
				wrapperClass: "operator-status-icon-wrapper",
				hint: {bindTo: "AgentState"}
			});
			operatorStatusIconConfig.imageConfig = {bindTo: "getOperatorStatusProfileIcon"};
			imageContainer.add(operatorStatusIconConfig);
		}

		/**
		 * Выполняет запрос к БД на выборку состояний оператора.
		 * @param {Function} callback Функция обратного вызова.
		 * @private
		 */
		function executeAgentStateQuery(callback) {
			var esq = Ext.create("Terrasoft.EntitySchemaQuery", {
				rootSchemaName: "SysMsgUserState"
			});
			esq.addColumn("Id", "Id");
			esq.addColumn("Name", "Name");
			esq.addColumn("Code", "Code");
			esq.addColumn("IsDisplayOnly", "IsDisplayOnly");
			esq.addColumn("[SysMsgUserStateReason:SysMsgUserState].Code", "StateReasonCode");
			esq.addColumn("[SysMsgUserStateReason:SysMsgUserState].Name", "StateReasonName");
			var currentSysMsgLibId = Terrasoft.SysValue.CTI.sysMsgLibId;
			esq.filters.add("filterSysMsgUserState", Terrasoft.createColumnFilterWithParameter(
				Terrasoft.ComparisonType.EQUAL, "[SysMsgUserStateInLib:SysMsgUserState].SysMsgLib",
				currentSysMsgLibId));
			esq.getEntityCollection(callback, this);
		}

		/**
		 * Формирует коллекцию состояний оператора из результата запроса выборки к БД.
		 * @param {Object} agentStatesQueryResult Результат запроса к БД на выборку состояний оператора.
		 * @returns {Terrasoft.Collection} Коллекция состояний оператора.
		 * @private
		 */
		function getAgentStates(agentStatesQueryResult) {
			var agentStates = new Terrasoft.Collection();
			agentStatesQueryResult.collection.each(function(item) {
				var valueCode = item.get("Code");
				var agentState = agentStates.find(valueCode);
				if (Ext.isEmpty(agentState)) {
					agentState = {
						value: item.get("Id"),
						displayValue: item.get("Name"),
						code: valueCode,
						isDisplayOnly: item.get("IsDisplayOnly"),
						reasons: null
					};
					agentStates.add(valueCode, agentState);
				}
				var stateReasonCode = item.get("StateReasonCode");
				if (Ext.isEmpty(stateReasonCode)) {
					return;
				}
				var stateReasonName = item.get("StateReasonName");
				agentState.reasons = agentState.reasons || new Terrasoft.Collection();
				agentState.reasons.add(stateReasonCode, {
					code: stateReasonCode,
					displayValue: stateReasonName
				});
			});
			return agentStates;
		}

		/**
		 * Формирует пункты меню состояний оператора в меню кнопки профиля.
		 * @param {Terrasoft.Collection} agentStates Коллекция состояний оператора.
		 * @param {Function} callback Функция обратного вызова.
		 * @private
		 */
		function generateAgentStateMenuItems(agentStates, callback) {
			var profileMenuCollection = this.get("ProfileMenuCollection");
			profileMenuCollection.clear();
			agentStates.each(function(item) {
				if (item.isDisplayOnly) {
					return true;
				}
				var hasReasons = !Ext.isEmpty(item.reasons);
				var menuItem = Ext.create("Terrasoft.BaseViewModel", {
					values: {
						Caption: item.displayValue,
						MarkerValue: item.displayValue,
						Tag: item.code,
						ImageConfig: this.getProfileMenuStatusIcon(item.code),
						Click: hasReasons ? null : {bindTo: "onOperatorStatusChange"},
						Items: hasReasons ? this.getAgentStateReasons(item.code, item.reasons) : null
					}
				});
				profileMenuCollection.addItem(menuItem);
			}, this);
			profileMenuCollection.addItem(Ext.create("Terrasoft.BaseViewModel", {
				values: {
					Type: "Terrasoft.MenuSeparator",
					Caption: ""
				}
			}));
			callback.call(this);
		}

		/**
		 * Формирует коллекцию причин изменения состояния оператора.
		 * @param {String} stateCode Код состояния оператора.
		 * @param {Terrasoft.Collection} reasons Причины изменения состояния.
		 * @return {Terrasoft.BaseViewModelCollection} Коллекция причин изменения состояния.
		 * @private
		 */
		function getAgentStateReasons(stateCode, reasons) {
			var reasonCollection = Ext.create("Terrasoft.BaseViewModelCollection");
			reasons.each(function(reason) {
				reasonCollection.addItem(Ext.create("Terrasoft.BaseViewModel", {
					values: {
						Caption: reason.displayValue,
						Tag: stateCode + "/" + reason.code,
						Click: {bindTo: "onOperatorStatusReasonChange"}
					}
				}));
			});
			return reasonCollection;
		}

		/**
		 * Устанавливает состояние оператора.
		 * @param {Object} tag Конфигурациионный объект.
		 * @private
		 */
		function onOperatorStatusChange(tag) {
			var ctiModel = Terrasoft.CtiModel;
			ctiModel.setAgentState(tag);
		}

		/**
		 * Устанавливает состояние оператора и причину изменения состояния.
		 * @param {Object} tag Конфигурациионный объект.
		 * @private
		 */
		function onOperatorStatusReasonChange(tag) {
			var tagParams = tag.split("/");
			var agentState = tagParams[0];
			var agentStateReasonCode = tagParams[1];
			var ctiModel = Terrasoft.CtiModel;
			ctiModel.setAgentState(agentState, agentStateReasonCode);
		}

		/**
		 * Расширяет методы модели представления шапки приложения.
		 * @param {Object} methods Существующие методы модели.
		 * @overridden
		 */
		function extendViewModelMethods(methods) {
			Ext.apply(methods, {
				getOperatorStatusProfileIcon: getOperatorStatusProfileIcon,
				onCtiPanelConnected: onCtiPanelConnected,
				executeAgentStateQuery: executeAgentStateQuery,
				getAgentStates: getAgentStates,
				getAgentStateReasons: getAgentStateReasons,
				generateAgentStateMenuItems: generateAgentStateMenuItems,
				getProfileMenuStatusIcon: getProfileMenuStatusIcon,
				onOperatorStatusChange: onOperatorStatusChange,
				onOperatorStatusReasonChange: onOperatorStatusReasonChange
			});
		}

		return {
			customInitViewModel: customInitViewModel,
			extendViewModelValues: extendViewModelValues,
			extendViewModelMethods: extendViewModelMethods,
			extendImageContainer: extendImageContainer
		};
	});

				// Autogenerated Code for schema MainHeaderExtensions (End)
// Autogenerated Code for schema IconHelper (Start)
define('IconHelperResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
/**
 * Вспомогательный модуль для работы с иконками.
 */
define("IconHelper", ["ext-base", "terrasoft"], function(Ext, Terrasoft) {

		/**
		 * Создает конфигурацию кнопки с иконкой.
		 * @param config {Object} Конфигурация кнопки с иконкой.
		 * @return {Object} Возвращает конфигурацию кнопки с иконкой.
		 */
		var createIconButtonConfig = function(config) {
			var buttonConfig = {
				id: "view-button-" + config.name,
				selectors: {
					wrapEl: "#view-button-" + config.name
				},
				tag: config.name,
				hint: config.hint,
				markerValue: config.name,
				className: "Terrasoft.Button",
				style: Terrasoft.controls.ButtonEnums.style.TRANSPARENT,
				iconAlign: Terrasoft.controls.ButtonEnums.iconAlign.LEFT,
				pressed: {bindTo: config.name + "Active"},
				click: {bindTo: config.func ? config.func : "onViewButtonClick"},
				classes: {
					imageClass: ["view-images-class"],
					pressedClass: ["pressed-button-view"],
					wrapperClass: config.wrapperClass
				}
			};
			if (config.imageClass) {
				buttonConfig.classes.imageClass.push(config.imageClass);
			}
			return buttonConfig;
		};

		return {
			createIconButtonConfig: createIconButtonConfig
		};
	});

				// Autogenerated Code for schema IconHelper (End)
// Autogenerated Code for schema ImageView (Start)
define('ImageViewResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
Ext.ns("Terrasoft");

/**
 * @class Terrasoft.controls.ImageView
 * Класс элемента управления для отображения картинок.
 */
Ext.define("Terrasoft.controls.ImageView", {
	extend: "Terrasoft.Component",
	alternateClassName: "Terrasoft.ImageView",

	/**
	 * Всплывающее название изображения.
	 * @type {String}
	 */
	imageTitle: "",

	/**
	 * Url изображения по умолчанию.
	 * @type {String}
	 */
	defaultImageSrc: "",

	/**
	 * Url изображения.
	 * @private
	 * @type {String}
	 */
	imageSrc: "",

	/**
	 * CSS class для элемента управления.
	 * @private
	 */
	wrapClasses: "",

	/**
	 * @inheritdoc Terrasoft.Component#tpl
	 * @protected
	 * @overridden
	 */
	tpl: [
		/*jshint white:false */
		'<img id="{id}-image-view" class="{wrapClass}" src="{imageSrc}" title="{imageTitle}" />'
		/*jshint white:true */
	],

	/**
	 * Инициализация компонента меню
	 * @protected
	 * @override
	 */
	init: function() {
		this.callParent(arguments);
		this.addEvents(
				/**
				 * @event
				 * Событие нажатия на элемент отображения картинок.
				 * @param {Terrasoft.ImageView} this
				 */
				'click'
		);
	},

	/**
	 * Инициализация событий DOM.
	 * @protected
	 * @override
	 */
	initDomEvents: function() {
		this.callParent(arguments);
		var wrapEl = this.getWrapEl();
		if (wrapEl) {
			wrapEl.on({
				click: {
					fn: this.onClick,
					scope: this
				}
			});
		}
	},

	/**
	 * Обрабтчик клика кнопки.
	 * @protected
	 */
	onClick: function(e) {
		e.stopEvent();
		this.fireEvent("click", this, null);
	},

	/**
	 * Рассчитывает данные для шаблона и обновляет селекторы.
	 * @protected
	 * @overridden
	 * @return {Object} tplData Обновленный набор данных для шаблона.
	 */
	getTplData: function() {
		var tplData = this.callParent(arguments);
		Ext.apply(tplData, this.combineClasses());
		tplData.imageSrc = this.imageSrc;
		tplData.imageTitle = this.imageTitle;
		this.updateSelectors(tplData);
		return tplData;
	},

	/**
	 * Обновляет селекторы исходя из данных сформированных для создания разметки.
	 * @protected
	 * @param  {Object} tplData объект данных для шаблона, по которому будет строиться разметка.
	 * @return {Object} selectors Обновленные селекторы.
	 */
	updateSelectors: function(tplData) {
		var id = tplData.id;
		var selectors = this.selectors = {};
		selectors.wrapEl = "#" + id + "-image-view";
		return selectors;
	},

	/**
	 * Вычисляет стили для элемента управления на основании конфигурации.
	 * @protected
	 * @return {Object} Строка содержащая список CSS - классов.
	 */
	combineClasses: function() {
		return {
			wrapClass: [this.wrapClasses]
		};
	},

	/**
	 * Изменяет основной url картинки.
	 * @param {String} src URL Адрес картинки.
	 * @param {String} title всплывающая подсказка картинки.
	 */
	setImageSrc: function(src, title) {
		this.imageSrc = src || this.defaultImageSrc;
		this.imageTitle = Ext.isEmpty(title, true) ? this.imageTitle : title;
		if (this.allowRerender()) {
			this.reRender();
		}
	},

	/**
	 * Изменяет всплывающее название изображения.
	 * @param {String} title Всплывающее название изображения.
	 */
	setImageTitle: function(title) {
		this.imageTitle = Ext.isEmpty(title, true) ? this.imageTitle : title;
		if (this.allowRerender()) {
			this.reRender();
		}
	},

	/**
	 * Возвращает конфигурацию привязки к модели. Реализует интерфейс миксина {@link Terrasoft.Bindable}.
	 * @overridden
	 */
	getBindConfig: function() {
		var parentBindConfig = this.callParent(arguments);
		var bindConfig = {
			imageSrc: {changeMethod: "setImageSrc"},
			imageTitle: {changeMethod: "setImageTitle"}
		};
		Ext.apply(bindConfig, parentBindConfig);
		return bindConfig;
	}
});

				// Autogenerated Code for schema ImageView (End)
// Autogenerated Code for schema ProcessProgressSpinnerImage (Start)
define('ProcessProgressSpinnerImageResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("ProcessProgressSpinnerImage", ['ext-base', 'terrasoft'],
		function(Ext, Terrasoft) {

			var image = "background-image: url('data:image/gif;base64, R0lGODlhHgAeAOZcAP39/f7+/urq6tzc3NXV1c7OzuPj4" +
					"7i4uMbGxrGxsfv7+7+/v6mpqaKiovn5+fz8/Pf39/T09Pr6+u7u7vPz8+zs7PX19fb29vj4+NfX1+jo6Ovr6+bm5uTk5O3t" +
					"7fDw8O/v7/Hx8eLi4tPT0+Hh4d3d3cDAwOfn597e3tnZ2enp6eXl5dHR0d/f39ra2tvb28fHx8rKyuDg4Lq6urW1tcjIyMT" +
					"ExM/Pz8LCwrOzs9LS0ry8vMzMzM3Nzb6+vtjY2NTU1K+vr7KystDQ0MvLy8XFxdbW1snJycHBwa2traurq7m5ube3t7u7u7" +
					"29vaqqqsPDw7CwsLa2tqysrK6urqioqLS0tKOjo6enp6SkpKWlpfLy8v///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" +
					"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" +
					"AAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1" +
					"wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2" +
					"JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYge" +
					"G1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlv" +
					"biByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmV" +
					"mPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy" +
					"5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo0QTFCNEMzNDM3M0RFMjExO" +
					"DA2N0I4OTI1MTJENDA2QSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2MDFCMzM1NEYwNzgxMUUyQTY0MUE2QTU1NjEw" +
					"M0NENSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2MDFCMzM1M0YwNzgxMUUyQTY0MUE2QTU1NjEwM0NENSIgeG1wOkN" +
					"yZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1LjEgV2luZG93cyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbn" +
					"N0YW5jZUlEPSJ4bXAuaWlkOjBFNjIzMDc4NDg0NEUyMTE4MDY3Qjg5MjUxMkQ0MDZBIiBzdFJlZjpkb2N1bWVudElEPSJ4b" +
					"XAuZGlkOjRBMUI0QzM0MzczREUyMTE4MDY3Qjg5MjUxMkQ0MDZBIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+" +
					"IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nv" +
					"a2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJ" +
					"OSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NT" +
					"EtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYF" +
					"BAMCAQAAIfkEBQoAXAAsAAAAAB4AHgAAB/+AXIKDhIMHVVUWhYuMgg8bhDkNDRGDChgBjYUiOVQQg5KUgxFbFA+ag04MDEe" +
					"gk5VcDluzmahcE08MTxOCoZUBs1sOtoMxqzu9r1wQs7CNFACDEFSrJFy+AMEKgw8fn4IAMzsngxmrQg8vQEASzFsXggEUGw" +
					"IVtSkJ+TBbXABSNB0WOYC2rIKAgxuGcVlxIF8CITokbInW6MGEgwc/nLKUIYdDHLYCGBTgQeGiCzHykbMFoQI8WxtGEAPHS" +
					"IGEmzgpEougoqdPFTsOCB1aYiaXLQaSKjUQdKjQojORLk1aBInVqyKMAnDAtatJQrWIbfiGqkINXrYoDBigYhujCCymFiyI" +
					"EbYRibUDSkyoq+CFCbkLijhbBACDAg14B5CAFcIGYBwoHjzIEGLRhxQuMl0wgFeAIwRyR3wjgQABiQcaNGwA8IMAAUiCtrR" +
					"AoVMDERDSapQG4aBAAZkTXGdw249sPEI/SmeI5VsmlxKuA878ULrGp96/BUVwTeAlqgBDSssQhN05FwOuURC7QAQBkY3lB0" +
					"kwksHDTAUyPJNvTmjLRqOExEdMIAAh+QQFCgBcACwAAAAAHgAeAAAH/4BcgoOEg05BQReFi4yDHoQHDAwWgys3Co2FKzM0G" +
					"IORk4IACQ1KApmDOAkJBZ+SlFwEDQ0MnqhcIKsJIIKglBBVsxm3gzerOL2vXDCzCQCZEYQYNKsdXL4TV7McgwAWEoRIOKeC" +
					"LqtLXCgZw8wNPoMQW1sUgwMH9zz0XDs73IQAP6Zs4eKAgjx5mLicWHDvwBIjCvQxAgAgwsEtFp4NeuBiRsMaxAxuiZBwEYQ" +
					"b91QQk7DFATEPw4hxCdBIgc2bMgVBmMCz5wQoC4IKJZHTgoCjSAUAFRqUqEyjSY8SqUG16oqcXG5qxcoIhMtbE258IGbBgI" +
					"EJDxpdyIAAwRBiGpzMGugwsFALGG0R8FDUKICDBx7kGjgBQdAWInlriBD0oi4hCjJkCMIQ1ywvQT3a/rC1okCBDgA2bJjAp" +
					"cWAAaQFRVhxdZAAFiEGYbjhOYQEAgRScAlxukQhW41KeB7A5XZuQSJOq5S5xfMNT8Z1c4FwegBwVEY8WyuOWzoXDae3o4Kg" +
					"o4COQdEHKSiBYiyxBx0qoO9OKBpXQumJBQIAIfkECQoAXAAsAAAAAB4AHgAAB/+AXIKDhINQUlIQhYuMggAThD4JCReDJyO" +
					"NiycmO5GTlYJMDEIVmYM1BweYgpKUgikMDEEOpoIfqQcfrJ9cGEGxLrWDI6k1u648sQcBmRaFO6kcXK0XIE+xGoMfOy+EMD" +
					"WlgiipJgAkLi4KRLE2gg4xWQ1KEoIyC/csEYI4ONmEAS+EcAHwg0GDg1lECBJQ5N4CE930ZQoh5ODBHboIocDhsEctCUoOB" +
					"lHYaMS9DcJeYCEAoBaIbsICKBJGc5CECDhzRoiBoKfPDjUdbBlKdAtPnz2B0hRadCiLAlCj+ov5oKrVBzUbUVAgLASBLcIw" +
					"CBCwpSUjCC+gGhE2YayADc6SCD3ocCPqiJmNFAAI4VaAB1pcIuiIeoMDAHMSCVngcEKQhLZjKTgaAbUEYA0ECGSbMEEXBwM" +
					"GwAqCUCGcIA8ZRHNxYCTz1gEDZAQG3QGroAD0MonITIKLAtiyuWgADYkmhcwEaP2OLQgDaAOAaw3I7G95cC4VQKsI+4PAD7" +
					"PWB81dIZmmBhCDwg+CYDZreuA0AwEAIfkECQoAXAAsAAAAAB4AHgAAB/+AXIKDhIM1Tk4QhYuMggAfhDYHB4qCKhkKjYUCM" +
					"DgOg5KUjk4JBx6agwULCxmgk5UDCQlSn6hcWyYLJluCoYoONLIltoMZqz29r1xDsj4BmhfPgg5Qqxpcvh+yCQKDITjDjgU3" +
					"E4MkqwgAHSgoCswJNYISBUoMCRKCBgj7GRdcADVqbCgUAMWSCAFeRGHAUEkHQRV47EMAo4UCCwAaAdhygCFDHCEIPRBRY+I" +
					"IWxISMKTxkJGDH/vK2UJB5UdGVCFaEOMSoFKhB0CDPrhJbACNo0hpsCjAtOm1nSMaSJ3aYGlTpk+JRaUqNQOQr2AH7rxQoa" +
					"zZCoykEYPwgBiFFxSliEnYsgWC2kIYSBAgMOAuowh06dYa9ODE3r0pMGgKMPRC4C0RMnG58OOwERUAAHDwh9eDh2cPANOtB" +
					"CDFXhG1KgwYUGEj5AAVBAiwMEgChS1qQZSIULvEagsPDBjgwAWC7A1EGRMkdGI18eDDBU2QzWunhdUl8EEnzkWCbAGSbYlY" +
					"jZbLdm+yQRBz0GJAi5vnHW2o4BMVgArVzQvnPo3oTpH77RQIACH5BAkKAFwALAAAAAAeAB4AAAf/gFyCg4SDBTY2GIWLjII" +
					"AW4QxCwsQgxsuD42FFT1HEoOSlIIBUAcLIJqDIwgIL6CTlVwtBwdOn6lcFDAIMBSCoZUOO7QyuIMDrCO/sFxAtDYBmhDRgh" +
					"IxrBtcwFtLtBWDWzDFjkAEH4MrrD0AHCQkCs4HBdU6QgkHCoInBfwvlQA3bngoFECEiQgBUDBJwFAIB0ETRvArcMPAg2mNA" +
					"lDwwZAhDEiD2N2YmAKXggMMdzxk5KAEv3O4SNAYAADXFgPGuARQtOiBz58PqBlrMaOo0RkZCChdmi1nBgZQozJIulRpU2NP" +
					"pUId4KKr1wk5uUCYQLYs2LCMjggwZoGEhaENoa4UudDIAYcBA0TgChClgV8sOjKF3IAXbwsHqQBEwOHXbxC9YlsULuEBAIA" +
					"NPAlJoOCLiwYrjY84kjzgRD4uHwwY+BDAgoVpFLZsQazzBdTMN+kKUtBBNQQAAgQMlCB7i1AHKlJVUJ0NuHBBEWTHMgZBdY" +
					"d8zgdyeVBcMC4NqmFmH3RBdgRjCjgY4FCTy3hHsmnjAvDhvKPg2ncLRXv/ubFAACH5BAUKAFwALAAAAAAeAB4AAAf/gFyCg" +
					"4SDIzExDoWLjIIAEYQsCAiKgh4oD42FEyNDCoOSlIIBRwtFH5qDKQUFMqCTlSILCzYSqYIWrAUWgqGKElCzHbeDMqwpvbBc" +
					"KbMxAZoOz4IKLKwTXL4UJrPXghQ8BoMBLi9bgxqsIwAqKysPzAsj00ZLBz6fXAIE+yQYXAH7QBQK0AHBhQAifBxYuESDoBA" +
					"p9u078QCDtEUBIthYuJAHBULrjEhEcUvBgoU4HDKSIGKfuVsddrQAcCvCCWKCKhUCwLMngIu3RJgYStQEigFIk3Yj5iKB06" +
					"cJjiZFuvRWU6hORZDYyjUETi4YQIgdK/ArowIViEE4AYEYCQZPrY60ZaRggwEDKjUFkMKgbxIjmQYBANHhrgEO+Bg9+GABQ" +
					"d++NIZxcbDCcIcPAQJ8sFWoRRIqmQTMeNxjFIe7FfBFECAgQgAHsB08adBA3j8UUaLotKDBn6AHG1g7ALBly0cXtLFcGCRB" +
					"QKoQrFERN/4vB+0iXx2w3pBp+kcuGmhf2YBzAmtIXLwPQkKbCbEHFQRUkKZeUAQtVX4AbZRxbvri3wligG9mCQYgToEAACH" +
					"5BAkKAFwALAAAAAAeAB4AAAf/gFyCg4SDKSwsEoWLjIMWhBkFBYQgIo2LISkZkJKENwg8W5eDKAQEHYORk4IcCAgxCqOCEK" +
					"YEEIKqgzGuJ7KDK6YouJ1cJa5DvpCmH1y5ETCuzIIRLByEMiQRgxumKVwVGhrFrj+DLyYLRYMTA+0cDoIvL6KFGj23HTYL+" +
					"yYbghQt2rXbAADeJQsx9u1joY2QhxICUckqsq+GP0YKTrRrOIoDDkuyLlxMRrJkB1coXa0wwLIlPV8lDsiceWBlS5YvZcWk" +
					"KVPDiZ9AOfoKQbRoiJKMdEzw5cCDwVEdEiRYxejBBwEClspyIjWBFW+EAlDYgFVAhQejQlwg0jXBjl5cfxRUKLuhoQW0hUj" +
					"ksCJog4muLAbNFRACL4YtWzBIAAIkhYQoDBhsEkSCiRRCECYoEgQA8RYFERo0SFIsMmlCFUZdQHyBS+jRgmZEPkJSgWcArk" +
					"WfFhD5iYdkERBjmKZ7EILIO3wBoLCFwqDXp7lYmBLkBUnFz4sPsoaUEPRkgQAAIfkECQoAXAAsAAAAAB4AHgAAB/+AXIKDh" +
					"IMoGRkShYuMggEQhAMEBIqCIRwAjYUUMiUPg5KUjgQFIxGagx0DAyqgk5UqBQUsCqiCGKsDGIKhigossgK2gyqrHbyvXCKy" +
					"RgGaCs6CDyirW1y9F7IF1oIXGa2OJyeQghOrLQEgGxsAJLIlggotMAg8n1whBvobtQEkJKcIBRAwAkMADUQQKIThoRsHfQY" +
					"6gAAgIdqiR0MUKsxwQeCHDhDBaXrAQ+GNhoweVNBHDpWKIxwsNsIAYpigSoUC6Nyp0yaXEzyCCuVRQYDRoxZ8kljAtOmCok" +
					"eNJrW51CnTCR6yam1py8GWr2C5+VxkpKYtBRFq2eJw4EDBRgCjLHwNiApK2wNNSmQa9Cgshb0pt0AYcvcADnAPKIQ1KGGHh" +
					"kUdZjTJ5AHBXQKOFG+5sLdHgwY9JCAaoIBJggQuUvlwglNChHtctmj5vMICAwY5uMg4baWlggmoFnz2wcU2bi4BTJwu4JPD" +
					"5ywhit/OzaXC6QTAbQEQ8pmHIOPUuRA5jWPYhycNnjj4Pn3QhRxSUMhs5IDHgEHgCWlYP5ZQ/mGBAAAh+QQJCgBcACwAAAA" +
					"AHgAeAAAH/4BcgoOEgx0oKAqFi4yCAQ6EIgMDioIUKgCNhRccK5mCkpSOLwQpFpqDAgYGE4OhlRUEBBkPqIIOHQYdkFyvXA" +
					"oZsh62gxOrKqCTihyyLwGatYMAK6unrxCyBBSDEC8VgwEeHrxcW6scAVsTEwDMBCKCDwY3BTrRFgL5H7UBJycXhcKlcBBAg" +
					"I4CCG+AEIShQj4BGygEUPCMUQAIRhAifAGBUIAIGx4uRPXgYAECIxcBCJGPnKYKQ1RU1CRhG7FfFgPo3HlTkEEdQINuGUp0" +
					"i0tUHRAoXYqgKNGjmpIyVRqBgtWrEnpKiMC1awRGn4i5CEGsQxAOxFQsMJEBqqAPO6saNBASttGRBXhxyKjrgEgWuQ2UfNA" +
					"EIAI2vHhrbPDJALCWGwok4BCwiIMJJJlAEEHsQpCCKXJN2GTBgAELBS5ctFDg48CBEoM42LCRVVAJKxoGbZlS+l+CBDO4GH" +
					"DdBMMgBYMJ1bVRGgeXC7+DByjiekRPDaWVbHkeXdAE1weSowpwoPQQQdCBDxriugaxEAkYRKmdPrggCDOciJhJc0iLQfURI" +
					"oBbNwVITCAAIfkECQoAXAAsAAAAAB4AHgAAB/+AXIKDhIMCKysPhYuMggEShBoGBoqCFh4AjYUYHhWZgpKUjiIDLRCagyAC" +
					"AluDoZUgAwMon6gKqwIKoJOKDyiyH6iEW6sgu6ICsiKotVwAFasYXK8OsgMWgxgkE4QUEbqWqxUBEVtbAMkDJ4IPJwQEP58" +
					"O5lsWnx4eDosfLRIBHj/evWvFRQEFelsgBKjEKEA1gQRISBsUAAPCCMIApHj3guAiABfMgUMFIsM4YQ9OCRM0kpCDlzAdMB" +
					"RWIYPNmxmqNNjJc8RKUAWCCi2gk+dOnz81DBWaI4jTpyl+FrRAtSq2RQGkovCoiQMNDSs3IIDxQh+jEDgYMDiQFdUNBHCjj" +
					"3RoJuGGErUMhITQBMCCAxdw4RbgxqVCFLxTRihQAGPDIhUwYGQKwSIwCpZC1NrAyIVAggQEFKBAIUKBjQULSAxSQSTGyBYz" +
					"BAyKkOOzCggHDpjgwgE1DrMFuXJpK+jI5xpccOseTgR1BqkCPguhkDz3bi4fUJsQ3tDHZyCClF/vjLrHyi0HEjABJ34QBCQ" +
					"2OhDXJAHIsvDWCVWAJLVQ+5WBAAAh+QQJCgBcACwAAAAAHgAeAAAH/4BcgoOEgyAVFQCFi4yDD4QTAgKKghAfAY2FChRbmI" +
					"KRk4MaBhwOmYMWW1sQg6CUWwYGK5SnD6pbj1yuXAArsRSnhBCqEZ+SihOxGqcftAG3ErrHEh2xrIIOHCGOVEEGgw6qwBAWF" +
					"gHJBhWCABsDAy2ULA3zOx+CEREKixQc+h8t7twV4yJDybwGWWI4oMVIgoiAA0oRUnBDy0EmwQAAHEBi4KIIJuaJCMZlSwkQ" +
					"njJpiEFSUK5CEhzInPkyGIgSOHOWoMKgp88MLblsIEC0KAGePnsCbTnUKNElNKJKHRBUAYSrWK8VShnMgEeVOwSQnFCggIx" +
					"ojLbASJDAB1dGBKXKFhhygqGEEULYJjiwJROACw5ayC1AwJ4uJnpzZFCggIeHRRt6FFC0JYPckVwULGEbw4KgFAcOpFBAgs" +
					"SKB0QQIOgwqIIOFvoEiTCxYVCEGaE3QFiwAAYXFaqPmHIJjBDXAqF7cNndm0sAFqpfBK0Qekkx5r65hFANo/ipADZC/6jEO" +
					"zuXFKpHkKTg44CP2NjB1Yih4S0jBT9Yk2/eKnZQYeW1FAgAIfkEBQoAXAAsAAAAAB4AHgAAB/+AXIKDhIMWW1sAhYuMgg8C" +
					"hBGIioIOEQGNhTJJWBeDkomDEwIVEpmDTA0NRZ+TghcCpJSnFVcNVxWCoIoAFbGep4NFqky6rluxE6ehr1iqKFy7ChuxDoP" +
					"TEYMPVjQrg0CqUw8SDg4ByAIhggAgHQYclAQM8zjqAEFBIosQFQ9cFCsMCOwATISQeQyUFJAQYtYiBRoECtyggJCCEVMQ7g" +
					"gGgIPAE8AWWbAxr0OwaCu2YDol4MbJdYwkyJwpweEyiThpJNjJ08VLLhMGCB06QCfPnT5fBiUqdEGTp1Bb/HyAoapVDIxWn" +
					"uQQMpMAHLmCfSBAoENFRhR4HDhgQ2ujF2ShCWQQ4FBBhiVrDyygkAkABAkG4hJwsUUQCB95Z7h4oIAFiEUTRgBRFKFEXA6O" +
					"TKy9AazEggUlHqxYoeGBjgIFNAwC8eOHP0ErEHgYdAHJZw8OECDowaUC6iGmHFko5HbEZx1ccu8WlAG1jJ8TPpsYrpz3P9Q" +
					"FsgULEOPzgEq6rXNBgTrFyQhFFtg4W32QgxssIJ1UMOCE+/CEPpz9Saj9yUAAOw==')"

			return {
				image:image
			};

		});

				// Autogenerated Code for schema ProcessProgressSpinnerImage (End)
// Autogenerated Code for schema CommandLineModule (Start)
define('CommandLineModuleResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={
	WhatCanIDoForYou: 'Что я могу для вас сделать?',
	CommandDoesntSelect: 'Команда не выбрана.'
};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("CommandLineModule", ["CommandLineModuleResources", "StorageUtilities", "ProcessModuleUtilities",
		"performancecountermanager", "ProcessProgressSpinnerImage"], function(resources, storageUtilities,
			ProcessModuleUtilities, performanceCounterManager, ProcessProgressSpinnerImage) {
	function createConstructor(context) {
		var topCount = 10;
		var Ext = context.Ext;
		var sandbox = context.sandbox;
		var Terrasoft = context.Terrasoft;

		function getDefaultCList(commandList, currentSchemaName) {
			var list = new Terrasoft.Collection();
			var tempList = commandList.filter(function(item) {
					return (item.Code === "search" && item.HintType === 2 &&
							item.SubjectName === currentSchemaName);
				});
			if (tempList.getCount() !== 0) {
				list.add(tempList.getKeys()[0], tempList.getItems()[0]);
			}
			if (currentSchemaName !== "Contact") {
				tempList = commandList.filter(function(item) {
					return (item.Code === "search" && item.HintType === 2 &&
						item.SubjectName === "Contact");
				});
				list.add(tempList.getKeys()[0], tempList.getItems()[0]);
			}
			if (currentSchemaName !== "Account") {
				tempList = commandList.filter(function(item) {
					return (item.Code === "search" && item.HintType === 2 && item.SubjectName === "Account");
				});
				list.add(tempList.getKeys()[0], tempList.getItems()[0]);
			}
			return list;
		}

		function tryGetModule(schemaName) {
			var result = null;
			var key = schemaName === "SocialMessage" ? "ESNFeed" : schemaName;
			Terrasoft.each(Terrasoft.configuration.ModuleStructure, function(item) {
				if (item && item.entitySchemaName && item.entitySchemaName === key) {
					result = item;
				}
			});
			return result;
		}

		function tryGetUrl(schemaName, urlType, columnTypeCode, mode) {
			var module = tryGetModule(schemaName);
			var url = "";
			switch (urlType) {
				case "section":
					url = module.sectionModule + "/";
					if (module.sectionSchema) {
						url += module.sectionSchema + "/";
					}
					break;
				case "card":
					if (module.cardSchema) {
						url += module.cardModule + "/";
						var attribute = module.attribute;
						if (columnTypeCode && attribute) {
							var pages = module.pages;
							for (var i = 0; i < pages.length; i++) {
								var page = pages[i];
								if (page.name === columnTypeCode) {
									if (page.cardSchema) {
										url += page.cardSchema + "/add/" + attribute + "/" + page.UId;
									} else {
										url += module.cardSchema + "/add/" + attribute + "/" + page.UId;
									}
								}
							}
						} else {
							if (mode === "add") {
								url += module.cardSchema + "/add";
							} else {
								url += module.cardSchema + "/";
							}
						}
					} else {
						url = module.sectionModule + "/" + module.sectionSchema + "/";
					}
					break;
				default :
					break;
			}
			return url;
		}

		/**
		 * Возвращает конфигурацию для открытия страницы.
		 * @param {String} schemaName Имя схемы.
		 * @param {Object} config Информация об объекте, страница которого будет открыта.
		 * @return {Object} Конфигурация для открытия страницы.
		 */
		function getOpenCardConfig(schemaName, config) {
			var moduleStructure = Terrasoft.configuration.ModuleStructure[schemaName];
			var values = {
				TypeColumnName: "",
				TypeColumnValue: Terrasoft.GUID_EMPTY,
				EditPageName: moduleStructure.cardSchema
			};
			var attribute = moduleStructure.attribute;
			var columnTypeCode = config.columnTypeCode;
			if (columnTypeCode && attribute) {
				var pages = moduleStructure.pages;
				Terrasoft.each(pages, function(page) {
					if (page.name === columnTypeCode) {
						if (page.cardSchema) {
							values.EditPageName = page.cardSchema;
						}
						values.TypeColumnName = attribute;
						values.TypeColumnValue = page.UId;
						return false;
					}
				}, this);
			}
			var primaryDisplayColumnValue = config.value;
			var primaryDisplayColumnName = config.columnName;
			if (primaryDisplayColumnName && primaryDisplayColumnValue) {
				values.PrimaryDisplayColumnName = primaryDisplayColumnName;
				values.PrimaryDisplayColumnValue = primaryDisplayColumnValue;
			}
			return Ext.create("Terrasoft.BaseViewModel", {values: values});
		}

		function executeCommand(command, mainParam, addParam) {
			var newState, state, currentState, filterState;
			var url = "";
			switch (command) {
				case "goto":
					url = tryGetUrl(mainParam, "section");
					if (addParam.value && addParam.valueId) {
						var filtersStorage = Terrasoft.configuration.Storage.Filters =
							Terrasoft.configuration.Storage.Filters || {};
						var sessionStorageFilters = filtersStorage[mainParam + "SectionV2"] =
							filtersStorage[mainParam + "SectionV2"] || {};
						sessionStorageFilters.FolderFilters = [{
							folderId: addParam.valueId,
							folderInfo: addParam.value
						}];
						state = sandbox.publish("GetHistoryState");
						currentState = state.state || {};
						newState = Terrasoft.deepClone(currentState);
						newState.filterState = filterState;
						sandbox.publish("PushHistoryState", {
							hash: url,
							stateObj: newState
						});
					} else {
						sandbox.publish("PushHistoryState", {hash: url});
					}
					break;
				case "search":
					if (addParam.valueId) {
						url = tryGetUrl(mainParam, "card") + "edit/" + addParam.valueId;
						sandbox.publish("PushHistoryState", {hash: url});
					} else if (addParam.value) {
						url = tryGetUrl(mainParam, "section");
						filterState = {};
						filterState.ignoreFixedFilters = true;
						filterState.ignoreFolderFilters = true;
						filterState.customFilterState = {};
						filterState.customFilterState[addParam.columnName] = {
							value: addParam.value,
							displayValue: addParam.value
						};
						state = sandbox.publish("GetHistoryState");
						currentState = state.state || {};
						newState = Terrasoft.deepClone(currentState);
						newState.activeTab = "mainView";
						newState.filterState = filterState;
						newState.searchState = true;
						newState.moduleId = "ViewModule_SectionModule";
						var tryFilterCurrentSection = sandbox.publish("FilterCurrentSection", {
							value: addParam.value,
							displayValue: addParam.value,
							schemaName: addParam.noSchema ? "" : mainParam
						});
						if (!tryFilterCurrentSection) {
							var storage = Terrasoft.configuration.Storage.Filters =
								Terrasoft.configuration.Storage.Filters || {};
							var sessionFilters = storage[mainParam + "SectionV2"] = storage[mainParam + "SectionV2"] || {};
							sessionFilters.CustomFilters = {
								value: addParam.value,
								displayValue: addParam.value,
								primaryDisplayColumn: true
							};
							sandbox.publish("PushHistoryState", {
								hash: url,
								stateObj: newState
							});
						}
					} else {
						url = tryGetUrl(mainParam, "section");
						sandbox.publish("PushHistoryState", {hash: url});
					}
					break;
				case "create":
					if (mainParam === "Macros") {
						url = "MacrosPageModule";
						state = sandbox.publish("GetHistoryState");
						currentState = state.state || {};
						newState = Terrasoft.deepClone(currentState);
						var defaultValues = {};
						if (addParam.columnName) {
							defaultValues[addParam.columnName] = addParam.value;
						}
						newState.defaultValues = defaultValues;
						var obj = {
							hash: url,
							stateObj: newState
						};
						sandbox.publish("PushHistoryState", obj);
					} else {
						var addCardConfig = getOpenCardConfig(mainParam, addParam);
						addCardConfig.set("Tag", sandbox.id);
						require(["SysModuleEditManageModule"], function(module) {
							if (module) {
								module.Run({
									sandbox: sandbox,
									item: addCardConfig
								});
							}
						});
					}
					break;
				case "startbp":
					if (addParam.value && addParam.valueId) {
						executeProcess(addParam.valueId);
					}
					break;
				default:
					break;
			}
		}

		function createViewConfig() {
			return {
				className: "Terrasoft.Container",
				id: "commandLineContainer",
				selectors: {
					el: "#commandLineContainer",
					wrapEl: "#commandLineContainer"
				},
				items: [
					{
						className: "Terrasoft.CommandLine",
						bigSize: true,
						placeholder: resources.localizableStrings.WhatCanIDoForYou,
						value: {bindTo: "selectedValue"},
						list: {bindTo: "commandList"},
						typedValueChanged: {bindTo: "getCommandList"},
						changeTypedValue: {bindTo: "onChangeTypedValue"},
						typedValue: {bindTo: "commandInsertValue"},
						selectionText: {bindTo: "commandSelectionText"},
						commandLineExecute: {bindTo: "executeCommand"},
						change: {bindTo: "valueChanged"},
						markerValue: "command-line",
						minSearchCharsCount: 3,
						searchDelay: 350,
						width: "100%"
					}
				]
			};
		}

		function createViewModel() {
			var viewModel = Ext.create("Terrasoft.BaseViewModel", {
				values: {
					selectedValue: null,
					commandInsertValue: null,
					commandSelectionText: "",
					selectedItem: null,
					commandList: new Terrasoft.Collection(),
					hintList: new Terrasoft.Collection()
				},
				methods: {
					clearData: function() {
						this.set("selectedValue", "");
						this.set("selectedItem", null);
						this.set("commandInsertValue", null);
					},
					valueChanged: function(item) {
						if (item) {
							if (item.value.substr(0, 4) === "comm" && this.commandList.contains(item.value)) {
								this.set("selectedItem", this.commandList.get(item.value));
								this.set("commandSelectionText", "");
							}
							if (item.value.substr(0, 4) === "hint" && this.hintList.contains(item.value)) {
								this.set("commandSelectionText", "");
							}
						}
					},
					onChangeTypedValue: function(item) {
						this.set("commandSelectionText", "");
						var selectItem = this.get("selectedItem");
						this.set("selectedValue", null);
						if (item && selectItem) {
							if (item.toLowerCase().indexOf(selectItem.Caption.toLowerCase()) === -1) {
								this.set("selectedItem", null);
								selectItem = this.get("selectedItem");
							}
						}
						var filter = item;
						var commandList = this.commandList;
						if (!selectItem) {
							var filteredCommandList = commandList.filter(
								function(item) {
									if (item.Caption.toLowerCase().indexOf(filter.toLowerCase().trim()) === 0 &&
										item.Caption.length === filter.length
										) {
										return true;
									}
								}
							);
							if (filteredCommandList.getCount() === 1) {
								selectItem = filteredCommandList.getItems()[0];
								this.set("selectedItem", selectItem);
							}
						}
					}
				}
			});
			return viewModel;
		}

		function callServiceMethod(ajaxProvider, methodName, callback, dataSend) {
			var data = dataSend || {};
			var requestUrl = Terrasoft.workspaceBaseUrl + "/rest/CommandLineService/" + methodName;
			var request = ajaxProvider.request({
				url: requestUrl,
				headers: {
					"Accept": "application/json",
					"Content-Type": "application/json"
				},
				method: "POST",
				jsonData: data,
				callback: function(request, success, response) {
					var responseObject = {};
					if (success) {
						responseObject = Terrasoft.decode(response.responseText);
					}
					callback.call(this, responseObject);
				},
				scope: this
			});
			return request;
		}

		function createProcessSpinner() {
			var body = Ext.getBody();
			var bodySize = body.getViewSize();
			var spinnerWidth = 30;
			var spinnerPositionW = (bodySize.width - spinnerWidth) / 2;
			var spinnerPositionH = (bodySize.height - spinnerWidth) / 2;
			var dimension = "px";
			return Ext.create("Terrasoft.Container", {
				renderTo: body,
				id: "processSpinnerContainer",
				selectors: {
					wrapEl: "#processSpinnerContainer"
				},
				items: [{
					className: "Terrasoft.Container",
					id: "processSpinnerContainerInside",
					selectors: {
						wrapEl: "#processSpinnerContainerInside"
					},
					styles: {
						wrapStyles: {
							"margin-left": spinnerPositionW + dimension,
							"margin-top": spinnerPositionH + dimension
						}
					},
					items: [{
						className: "Terrasoft.ProgressSpinner",
						extraComponentClasses: "",
						width: spinnerWidth + dimension,
						extraStyle: ProcessProgressSpinnerImage.image
					}]
				}]
			});
		}

		function executeProcess(processName) {
			ProcessModuleUtilities.executeProcess({
				sysProcessName: processName
			});
		}

		function init(callbackList) {
			this.commandList = new Terrasoft.Collection();
			this.commandsCollection = new Terrasoft.Collection();
			this.mainParamCollection = new Terrasoft.Collection();
			this.hintList = new Terrasoft.Collection();
			this.selectedValue = null;
			var commandList = this.commandList;
			var commandsCollection = this.commandsCollection;
			var mainParamCollection = this.mainParamCollection;
			var ajaxProvider = this.ajaxProvider = Terrasoft.AjaxProvider;
			var serviceCallback = function(response) {
				if (instance.isDestroyed) { return; }
				var list = commandList;
				var listCommands = commandsCollection;
				var listMainParam = mainParamCollection;
				var responseArray = response.GetCommandListResult;
				if (responseArray) {
					for (var i = 0; i < responseArray.length; i++) {
						list.add("comm" + responseArray[i].Id, responseArray[i]);
						if (responseArray[i].HintType === 2 || responseArray[i].HintType === 3) {
							var command = responseArray[i].CommandCaption;
							var mainParam = responseArray[i].MainParamCaption;
							if (!listCommands.contains(command)) {
								listCommands.add(command, {
									Code: responseArray[i].Code,
									Synonym: responseArray[i].HintType === 3
								});
							}
							if (!listMainParam.contains(mainParam)) {
								listMainParam.add(mainParam,
									{
										SubjectName: responseArray[i].SubjectName,
										SubjectName: responseArray[i].SubjectName,
										ColumnName: responseArray[i].ColumnName,
										ColumnTypeCode: responseArray[i].ColumnTypeCode
									}
								);
							}
						}
					}
				}
				if (callbackList) {
					callbackList(this.commandList);
				}
			};
			var keyGenerator = function(ajaxProvider, methodName) {
				return {
					groupName: "CommandLineStorage",
					valueKey: methodName
				};
			};
			var requestFunction = function(callback, ajaxProvider, methodName, dataSend) {
				callServiceMethod(ajaxProvider, methodName, callback, dataSend);
			};
			storageUtilities.workRequestWithStorage(keyGenerator, requestFunction, serviceCallback, this, ajaxProvider,
				"GetCommandList", serviceCallback);
		}

		function render(renderTo) {
			var container = this.renderTo = renderTo;
			if (!container.dom) {
				return;
			}
			var ajaxProvider = this.ajaxProvider;
			var commandList = this.commandList;
			var commandsCollection = this.commandsCollection;
			var mainParamCollection = this.mainParamCollection;
			var hintList = this.hintList;
			var currentSchemaName = sandbox.publish("GetSectionSchemaName");
			if (!currentSchemaName) {
				currentSchemaName = sandbox.publish("GetCardSchemaName");
			}
			sandbox.subscribe("ChangeCommandList", function() {
				var callbackList = function(list) {
					commandList = list;
				};
				init(callbackList);
			});
			var viewConfig = createViewConfig();
			var view = Ext.create(viewConfig.className || "Terrasoft.Container", viewConfig);
			var viewModel = createViewModel();
			viewModel.schemaName = currentSchemaName;
			viewModel.commandList = commandList;
			viewModel.hintList = hintList;
			viewModel.getCommandList = function(filter) {
				var list = this.get("commandList");
				list.clear();
				var lastRequest, suggestString, newSuggestion;
				if (!filter) {
					return;
				}
				var obj = {};
				var selectItem = this.get("selectedItem");
				var schemaName = this.schemaName;
				if (!selectItem) {
					var canBeCommand = (commandsCollection.filter(function(item, key) {
						return (key.toLowerCase().indexOf(filter.toLowerCase()) === 0) && !item.Synonym;
					})).getCount() > 0;
					var canBeMainParam = (mainParamCollection.filter(function(item, key) {
						return key.toLowerCase().indexOf(filter.toLowerCase()) === 0;
					})).getCount() > 0;
					var needSynonyms = !(canBeCommand || canBeMainParam);
					var filteredList = commandList.filter(function(item) {
						if (item.Caption.toLowerCase().indexOf(filter.toLowerCase()) > -1) {
							if (item.HintType === 1 || item.HintType === 2) {
								return true;
							}
							if (item.HintType === 3 && needSynonyms) {
								return true;
							}
						}
						return false;
					});
					filteredList.sort("MainParamCaption", Terrasoft.OrderDirection.ASC);
					filteredList.sort(null, null, function(obj1) {
						if (obj1.SubjectName === schemaName) {
							return -1;
						} else {
							return 1;
						}
					});
					var newCaption = "";
					if (filteredList.getCount() === 0) {
						filteredList = getDefaultCList(commandList, currentSchemaName);
						newCaption = filter;
					}
					filteredList.each(function(item, index) {
						if (index > topCount) {
							return false;
						}
						obj["comm" + item.Id] = {
							value: "comm" + item.Id,
							displayValue: newCaption ? item.Caption + " " + newCaption : item.Caption
						};
					});
					suggestString = "";
					if (filteredList.getCount() > 0) {
						newSuggestion = filteredList.getItems()[0].Caption;
						if (newSuggestion.toLowerCase().indexOf(filter.toLowerCase()) === 0) {
							suggestString = newSuggestion.substring(filter.length, newSuggestion.length);
						}
					}
					this.set("commandSelectionText", suggestString);
					list.clear();
					list.loadAll(obj);
				} else {
					hintList.clear();
					var viewModel = this;
					var hintText = (filter.substr(selectItem.Caption.length, filter.length - 1)).trim();
					var subjectName = "";
					var hideHint = selectItem.Code === "create" || !Ext.isEmpty(selectItem.AdditionalParamValue);
					if (selectItem.Code === "goto") {
						subjectName = selectItem.SubjectName + "Folder";
					} else if (selectItem.Code === "run") {
						subjectName = "runnableHint";
					} else {
						subjectName = selectItem.SubjectName;
					}
					if (!hideHint) {
						if (lastRequest) {
							ajaxProvider.abort(lastRequest);
						}
						lastRequest = callServiceMethod(ajaxProvider, "GetHintList", function(response) {
							if (instance.isDestroyed) { return; }
							var boxList = list;
							var hints = hintList;
							var hintArray = response.GetHintListResult;
							if (Ext.isEmpty(hintArray)) {
								return;
							}
							for (var i = 0; i < hintArray.length && i <= topCount; i++) {
								var uniqueKey = Terrasoft.generateGUID();
								var displayValue = selectItem.Caption + " " + hintArray[i].Key;
								var value = Terrasoft.deepClone(selectItem);
								value.AdditionalParamValue = hintArray[i].Key;
								value.AdditionalParamValueId = hintArray[i].Value;
								hints.add("hint" + uniqueKey, value);
								obj["hint" + uniqueKey] = {
									value: "hint" + uniqueKey,
									displayValue: displayValue
								};
							}
							suggestString = "";
							if (hintArray.length > 0) {
								newSuggestion = selectItem.Caption + " " + hintArray[0].Key;
								if (newSuggestion.toLowerCase().indexOf(filter.toLowerCase()) === 0) {
									suggestString = newSuggestion.substring(filter.length, newSuggestion.length);
								}
							}
							viewModel.set("commandSelectionText", suggestString);
							boxList.clear();
							boxList.loadAll(obj);
						}, {"subjectName": subjectName, "hintText": hintText});
					} else {
						if (selectItem) {
							obj["comm" + selectItem.Id] = {
								value: "comm" + selectItem.Id,
								displayValue: selectItem.Caption
							};
							suggestString = "";
							newSuggestion = selectItem.Caption;
							if (newSuggestion.toLowerCase().indexOf(filter.toLowerCase()) === 0) {
								suggestString = newSuggestion.substring(filter.length, newSuggestion.length);
							}
							this.set("commandSelectionText", suggestString);
							list.clear();
							list.loadAll(obj);
						}
					}
				}
			};
			viewModel.executeCommand = function(input) {
				if (!input) {
					return;
				}
				var suggestion = this.get("commandSelectionText");
				if (suggestion) {
					input += suggestion;
				}
				var inputArray = input.split(" ");
				var command, mainParam, valueId, columnName, tempList, subjectName, columnTypeCode, macros;
				var i = 0;
				var additionValue = "";
				var macrosText = "";
				var predicateFilterEntry = function(item) {
					return item.Caption.toLowerCase().indexOf(macrosText.toLowerCase()) === 0;
				};
				var predicateFilterMatch = function(item) {
					return item.Caption.toLowerCase() === macrosText.toLowerCase();
				};
				while (i < inputArray.length) {
					while (!macros && inputArray.length > i) {
						macrosText += " " + inputArray[i++];
						macrosText = macrosText.trim();
						tempList = commandList.filter(predicateFilterEntry);
						if (tempList.getCount() === 1) {
							var selectedItem = tempList.getItems()[0];
							if (selectedItem.Caption.toLowerCase() === macrosText.toLowerCase()) {
								macros = tempList.getItems()[0];
							}
						}
					}
					while (inputArray.length > i) {
						additionValue += inputArray[i++] + " ";
					}
					additionValue = additionValue.trim();
					if (!macros && inputArray.length === i && tempList.getCount() > 0) {
						tempList = commandList.filter(predicateFilterMatch);
						if (tempList.getCount() === 1) {
							macros = tempList.getItems()[0];
						}
					}
				}
				if (macros) {
					columnName = macros.ColumnName;
					columnTypeCode = macros.ColumnTypeCode;
					command = macros.Code;
					mainParam = macros.SubjectName;
					var addValue;
					if (macros.HintType === 1 && macros.AdditionalParamValue) {
						switch (command) {
							case "search":
							case "goto":
								addValue = macros.AdditionalParamValue.split(";");
								valueId = addValue[0];
								additionValue = addValue[1];
								break;
							case "startbp":
								addValue = macros.AdditionalParamValue.split(";");
								valueId = addValue[0];
								additionValue = addValue[1];
								var esq = Ext.create("Terrasoft.EntitySchemaQuery", {
									rootSchemaName: "VwSysProcess"
								});
								esq.addColumn("Id", "Id");
								esq.addColumn("Name", "Name");
								esq.filters.add("recordId", Terrasoft.createColumnFilterWithParameter(
									Terrasoft.ComparisonType.EQUAL, "Id", valueId));
								esq.getEntityCollection(function(result) {
									if (instance.isDestroyed) {
										return;
									}
									if (result.collection.getCount() > 0) {
										var entities = result.collection.getItems();
										valueId = entities[0].values.Name;
										executeCommand(command, macros.SubjectName,
											{
												value: additionValue,
												valueId: valueId,
												columnName: columnName,
												columnTypeCode: columnTypeCode
											}
										);
									}
								}, this);
								return;
							default:
								additionValue = macros.AdditionalParamValue;
								break;
						}
					} else if (additionValue && command !== "create") {
						tempList = hintList.filter(function(item) {
							return additionValue === item.AdditionalParamValue;
						});
						if (tempList.getCount() === 1) {
							var item = tempList.getItems()[0];
							valueId = item.AdditionalParamValueId;
							executeCommand(command, mainParam,
								{
									value: additionValue,
									valueId: valueId,
									columnName: columnName,
									columnTypeCode: columnTypeCode
								}
							);
							this.clearData();
							return;
						} else {
							subjectName = macros.SubjectName;
							if (command === "goto") {
								subjectName = subjectName + "Folder";
							}
							var viewModel = this;
							callServiceMethod(ajaxProvider, "GetHintList", function(response) {
								if (instance.isDestroyed) { return; }
								var hintArray = response.GetHintListResult;
								if (hintArray.length === 1) {
									valueId = hintArray[0].Value;
								}
								executeCommand(command, mainParam,
									{
										value: additionValue,
										valueId: valueId,
										columnName: columnName,
										columnTypeCode: columnTypeCode
									}
								);
								viewModel.clearData();
							}, {
								"subjectName": subjectName,
								"hintText": additionValue
							});
							return;
						}
					}
					executeCommand(command, mainParam,
						{
							value: additionValue,
							valueId: valueId,
							columnName: columnName,
							columnTypeCode: columnTypeCode
						}
					);
				} else {
					var searchSchemaName = "Contact";
					var searchColumnName = "Name";
					if (currentSchemaName) {
						var tempCommandList = commandList.filter(function(item) {
							return (item.SubjectName === currentSchemaName);
						});
						if (tempCommandList.getCount() !== 0) {
							searchSchemaName = currentSchemaName;
							searchColumnName = tempCommandList.getItems()[0].ColumnName;
						}
					}
					executeCommand("search", searchSchemaName,
						{
							value: input.trim(),
							valueId: "",
							columnName: searchColumnName,
							columnTypeCode: "",
							noSchema: true
						}
					);
				}
				this.clearData();
			};
			view.render(container);
			view.bind(viewModel);
			performanceCounterManager.setTimeStamp("loadAdditionalModulesComplete");
		}
		var instance = Ext.define("CommandLineModule", {
			init: init,
			render: render
		});
		return instance;
	}

	return createConstructor;
});


				// Autogenerated Code for schema CommandLineModule (End)
// Autogenerated Code for schema GoogleTagManagerUtilities (Start)
define('GoogleTagManagerUtilitiesResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("GoogleTagManagerUtilities", ["ext-base", "terrasoft", "GoogleTagManagerUtilitiesResources",],
		function(Ext, Terrasoft, resources) {
			Ext.define("Terrasoft.configuration.GoogleTagManagerUtilities", {
				alternateClassName: "Terrasoft.GoogleTagManagerUtilities",
				singleton: true,

				/**
				 * Название продукта
				 * @protected
				 * @type {String}
				 */
				productName: Ext.emptyString,

				/**
				 * Редакция продукта
				 * @protected
				 * @type {String}
				 */
				productEdition: Ext.emptyString,

				/**
				 * Локализация
				 * @protected
				 * @type {String}
				 */
				primaryCulture: Ext.emptyString,

				constructor: function() {
					this.callParent();
					this.product = Terrasoft.SysSettings.querySysSettings([
						"ProductName", "ProductEdition", "PrimaryCulture"
					], function(values) {
						this.productName = Ext.util.Format.htmlDecode(values.ProductName);
						this.productEdition = values.ProductEdition;
						this.primaryCulture = values.PrimaryCulture.displayValue;
					}, this);
				},

				/**
				 * Выполняет отправку данных в Google Tag Manager
				 * @private
				 * @param {Object} data Значения параметров которые будут переданы в Google Tag Manager
				 */
				send: function(data) {
					if (window.dataLayer) {
						window.dataLayer.push({
							"event" : "bpmonlineInfo",
							"virtualUrl" : Ext.isEmpty(data.virtualUrl) ? undefined : data.virtualUrl,
							"productName" : this.productName,
							"productEdition" : this.productEdition,
							"primaryCulture" : this.primaryCulture,
							"moduleName" : Ext.isEmpty(data.moduleName) ? undefined : data.moduleName,
							"currentAction" : Ext.isEmpty(data.currentAction) ? undefined : data.currentAction,
							"primaryColumnValue" : Ext.isEmpty(data.primaryColumnValue)
									? undefined
									: data.primaryColumnValue,
							"typeModule" : Ext.isEmpty(data.typeModule) ? "UnknownModule" : data.typeModule
						});
					}
				},

				/**
				 * Выполняет отправку данных в Google Tag Manager
				 * @public
				 * @param {Object} data Значения параметров которые будут переданы в Google Tag Manager
				 */
				actionModule: function(data) {
					this.send({
						virtualUrl : data.virtualUrl,
						moduleName : data.moduleName,
						currentAction : data.currentAction,
						primaryColumnValue : data.primaryColumnValue,
						typeModule : data.typeModule
					});
				}
			});
			return Terrasoft.GoogleTagManagerUtilities;
		}
);

				// Autogenerated Code for schema GoogleTagManagerUtilities (End)
// Autogenerated Code for schema StorageUtilities (Start)
define('StorageUtilitiesResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("StorageUtilities", ["ext-base", "terrasoft", "sandbox", "StorageUtilitiesResources"], function(Ext, Terrasoft) {
	var clearStorageModes = {
		ALL: "all",
		GROUP: "group",
		ITEM: "item",
		GROUP_ITEM: "groupItem"
	};

	var getESQResultByKey = function(config) {
		var result = Terrasoft.configuration.Storage[config.key];
		if (result) {
			config.callback.call(config.scope, result);
		} else {
			var setESQResultByKey = function(result) {
				Terrasoft.configuration.Storage[config.key] = result;
				config.callback.call(config.scope, result);
			};
			if (config.extraQuery) {
				config.extraQuery.query.getEntityCollection(function(result) {
					Terrasoft.configuration.Storage[config.extraQuery.key] = result;
					config.esq.getEntityCollection(setESQResultByKey);
				});
			} else {
				config.esq.getEntityCollection(setESQResultByKey);
			}
		}
	};

	function isFunction(functionToCheck) {
		var getType = {};
		return functionToCheck && getType.toString.call(functionToCheck) === "[object Function]";
	}
	function cloneResult(result) {
		var returnedResult = [];
		for (var i = 0; i < result.length; i++) {
			returnedResult.push(Terrasoft.deepClone(result[i]));
		}
		return returnedResult;
	}
	function workRequestWithStorage(storageKeyGenerator, requestFunction, callbackFunction, scope) {
		scope = scope || this;
		var storageKey = null;
		var groupName = null;
		if (isFunction(storageKeyGenerator)) {
			storageKey = storageKeyGenerator.apply(scope, Array.prototype.slice.call(arguments, 4));
		} else {
			storageKey = storageKeyGenerator;
		}
		if (Ext.isEmpty(storageKey)) {
			callbackFunction.call(scope, {});
			return;
		}
		if (storageKey.constructor === Object &&
			storageKey.hasOwnProperty("groupName") &&
			storageKey.hasOwnProperty("valueKey")) {
			groupName = storageKey.groupName;
			storageKey = storageKey.valueKey;
		}
		var result = {};
		if (!Ext.isEmpty(groupName)) {
			result = Terrasoft.configuration.Storage[groupName];
			if (!Ext.isEmpty(result)) {
				result = result[storageKey];
			}
		} else {
			result = Terrasoft.configuration.Storage[storageKey];
		}
		if (!Ext.isEmpty(result)) {
			callbackFunction.apply(scope, cloneResult(result));
		} else {
			var saveResultFunction = function() {
				if (!Ext.isEmpty(groupName)) {
					var group = Terrasoft.configuration.Storage[groupName];
					if (Ext.isEmpty(group)) {
						group = Terrasoft.configuration.Storage[groupName] = {};
					}
					group[storageKey] = arguments;
				} else {
					Terrasoft.configuration.Storage[storageKey] = arguments;
				}

				callbackFunction.apply(scope, cloneResult(arguments));
			};
			var requestArguments = Array.prototype.slice.call(arguments, 4);
			requestArguments.unshift(saveResultFunction);
			requestFunction.apply(scope, requestArguments);
		}
		return storageKey;
	}
	function clearAllInStorage() {
		for (var storageValue in Terrasoft.configuration.Storage) {
			delete Terrasoft.configuration.Storage[storageValue];
		}
	}
	function clearItemInStorage(name) {
		if (Terrasoft.configuration.Storage.hasOwnProperty(name)) {
			delete Terrasoft.configuration.Storage[name];
		}
	}
	function clearGroupItemInStorage(groupName, itemName) {
		if (Terrasoft.configuration.Storage.hasOwnProperty(groupName) &&
			Terrasoft.configuration.Storage[groupName].hasOwnProperty(itemName)) {
			delete Terrasoft.configuration.Storage[groupName][itemName];
		}
	}
	function clearStorage(mod, groupName, itemName) {
		switch (mod) {
			case clearStorageModes.ALL:
				clearAllInStorage();
				return;
			case clearStorageModes.GROUP:
			case clearStorageModes.ITEM:
				clearItemInStorage(groupName);
				break;
			case clearStorageModes.GROUP_ITEM:
				clearGroupItemInStorage(groupName, itemName);
				break;
		}
	}

	function innerGetItem(groupName, itemName) {
		var group = (groupName && itemName)
			? Terrasoft.configuration.Storage[groupName] || {}
			: Terrasoft.configuration.Storage;
		var key = groupName || itemName;
		var item = group[key];
		return Terrasoft.deepClone(item);
	}

	function innerSetItem(item, groupName, itemName) {
		if (groupName && itemName) {
			var group = Terrasoft.configuration.Storage[groupName] || (Terrasoft.configuration.Storage[groupName] = {});
			group[itemName] = item;
		} else {
			var key = groupName || itemName;
			Terrasoft.configuration.Storage[key] = item;
		}
	}

	function innerDeleteItem(groupName, itemName) {
		if (groupName && itemName) {
			delete Terrasoft.configuration.Storage[groupName][itemName];
		} else {
			var key = groupName || itemName;
			delete Terrasoft.configuration.Storage[key];
		}
	}

	return {
		GetESQResultByKey: getESQResultByKey,
		workRequestWithStorage: workRequestWithStorage,
		ClearStorageModes: clearStorageModes,
		clearStorage: clearStorage,
		getItem: innerGetItem,
		setItem: innerSetItem,
		deleteItem: innerDeleteItem
	};
});


				// Autogenerated Code for schema StorageUtilities (End)
// Autogenerated Code for schema RightUtilities (Start)
define('RightUtilitiesResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("RightUtilities", ["ext-base", "terrasoft", "StorageUtilities"],
	function(Ext, Terrasoft, StorageUtilities) {

	/**
	 * Функция обратного вызова проверки права текущего пользователя на операции.
	 * @callback Terrasoft.RightUtilities~onCheckCanExecuteOperations
	 * @param {Object} requestResult Результат проверки доступа на операции. Ключ объекта - название операции,
	 * значение - доступна ли операция текущему пользователю.
	 */

	/** @enum
	 *  Уровни доступа на схему */
	var SchemaOperationRightLevels = {
		/** Нет доступа */
		None: 0,
		/** Доступен для чтение */
		CanRead: 1,
		/** Доступен для добавление */
		CanAppend: 2,
		/** Доступен для изменение */
		CanEdit: 4,
		/** Доступен для удаление */
		CanDelete: 8
	};

	/** @enum
	 *  Уровни дуступа на запись */
	var RecordOperationRightLevels = {
		/** Нет доступа */
		None: 0,
		/** Доступна для чтение */
		CanRead: 1,
		/** Доступна для чтение с правом делегирование */
		CanChangeReadRight: 1 + 2,
		/** Доступна для изменение */
		CanEdit: 4,
		/** Доступна для изменение с правом делегирование */
		CanChangeEditRight: 4 + 8,
		/** Доступна для удаление */
		CanDelete: 16,
		/** Доступна для удаление с правом делегирование */
		CanChangeDeleteRight: 16 + 32
	};

	var definedClass = Ext.ClassManager.get("Terrasoft.RightUtilities");
	if (definedClass) {
		return Ext.create(definedClass);
	}

	Ext.define("Terrasoft.configuration.mixins.RightUtilitiesMixin", {
		alternateClassName: "Terrasoft.RightUtilitiesMixin",

		/**
		 * Проверяет есть ли доступ на чтение из таблицы, для переданного уровня доступа.
		 * @param {Number} value Уровеню доступа.
		 * @returns {boolean} Возвращает true если есть доступ на операцию,
		 * false - в противном случае.
		 */
		isSchemaCanReadRightConverter: function(value) {
			return ((SchemaOperationRightLevels.CanRead & value) === SchemaOperationRightLevels.CanRead);
		},

		/**
		 * Проверяет есть ли доступ на добавление в таблицу, для переданного уровня доступа.
		 * @param {Number} value Уровеню доступа.
		 * @returns {boolean} Возвращает true если есть доступ на операцию,
		 * false - в противном случае.
		 */
		isSchemaCanAppendRightConverter: function(value) {
			return ((SchemaOperationRightLevels.CanAppend & value) === SchemaOperationRightLevels.CanAppend);
		},

		/**
		 * Проверяет есть ли доступ на зменение записи в таблице, для переданного уровня доступа.
		 * @param {Number} value Уровеню доступа.
		 * @returns {boolean} Возвращает true если есть доступ на операцию,
		 * false - в противном случае.
		 */
		isSchemaCanEditRightConverter: function(value) {
			return ((SchemaOperationRightLevels.CanEdit & value) === SchemaOperationRightLevels.CanEdit);
		},

		/**
		 * Проверяет есть ли доступ на удаление записи в таблице, для переданного уровня доступа.
		 * @param {Number} value Уровеню доступа.
		 * @returns {boolean} Возвращает true если есть доступ на операцию,
		 * false - в противном случае.
		 */
		isSchemaCanDeleteRightConverter: function(value) {
			return ((SchemaOperationRightLevels.CanDelete & value) === SchemaOperationRightLevels.CanDelete);
		},

		/**
		 * Проверяет есть ли доступ на чтение записи, для переданного уровня доступа.
		 * @param {Number} value Уровеню доступа.
		 * @returns {boolean} Возвращает true если есть доступ на операцию,
		 * false - в противном случае.
		 */
		isSchemaRecordCanReadRightConverter: function(value) {
			return ((RecordOperationRightLevels.CanRead & value) === RecordOperationRightLevels.CanRead);
		},

		/**
		 * Проверяет есть ли доступ на изменения прав на чтение записи, для переданного уровня доступа.
		 * @param {Number} value Уровеню доступа.
		 * @returns {boolean} Возвращает true если есть доступ на операцию,
		 * false - в противном случае.
		 */
		isSchemaRecordCanChangeReadRightConverter: function(value) {
			return ((RecordOperationRightLevels.CanChangeReadRight & value) ===
				RecordOperationRightLevels.CanChangeReadRight);
		},

		/**
		 * Проверяет есть ли доступ на изменение записи, для переданного уровня доступа.
		 * @param {Number} value Уровеню доступа.
		 * @returns {boolean} Возвращает true если есть доступ на операцию,
		 * false - в противном случае.
		 */
		isSchemaRecordCanEditRightConverter: function(value) {
			return ((RecordOperationRightLevels.CanEdit & value) === RecordOperationRightLevels.CanEdit);
		},

		/**
		 * Проверяет есть ли доступ на изменения прав на изменение записи, для переданного уровня доступа.
		 * @param {Number} value Уровеню доступа.
		 * @returns {boolean} Возвращает true если есть доступ на операцию,
		 * false - в противном случае.
		 */
		isSchemaRecordCanChangeEditRightConverter: function(value) {
			return ((RecordOperationRightLevels.CanChangeEditRight & value) ===
				RecordOperationRightLevels.CanChangeEditRight);
		},

		/**
		 * Проверяет есть ли доступ на удаление записи, для переданного уровня доступа.
		 * @param {Number} value Уровеню доступа.
		 * @returns {boolean} Возвращает true если есть доступ на операцию,
		 * false - в противном случае.
		 */
		isSchemaRecordCanDeleteRightConverter: function(value) {
			return ((RecordOperationRightLevels.CanDelete & value) === RecordOperationRightLevels.CanDelete);
		},

		/**
		 * Проверяет есть ли доступ на изменения прав на удаление записи, для переданного уровня доступа.
		 * @param {Number} value Уровеню доступа.
		 * @returns {boolean} Возвращает true если есть доступ на операцию,
		 * false - в противном случае.
		 */
		isSchemaRecordCanChangeDeleteRightConverter: function(value) {
			return ((RecordOperationRightLevels.CanChangeDeleteRight & value) ===
				RecordOperationRightLevels.CanChangeDeleteRight);
		}
	});

	/**
	 * @class Terrasoft.configuration.BaseSchemaViewModel
	 * Конфигурационный базовый класс модели представления
	 */
	var rightUtilitiesClass = Ext.define("Terrasoft.configuration.RightUtilities", {
		extend: "Terrasoft.BaseObject",
		alternateClassName: "Terrasoft.RightUtilities",

		mixins: {
			rightsUtilities: "Terrasoft.RightUtilitiesMixin"
		},

		/**
		 * Имя сервиса работы с правами.
		 * @protected
		 * @type {String}
		 */
		serviceName: "RightsService",

		/**
		 * Название операций.
		 * @type {Object}
		 */
		SysAdminOperationCode: {
			CAN_DESIGN_PAGE: "CanChangeApplicationTuningMode"
		},

		/**
		 * Метод вызывает метод веб сервиса с указанными параметрами.
		 * @param {String} methodName Имя метода веб сервиса.
		 * @param {Object} data Обьект данных для метода веб сервиса.
		 * @param {Function} callback Функция обратного вызова.
		 * @param {Object} scope Объект окружения фукнции обратного вызова.
		 */
		callServiceMethod: function(methodName, data, callback, scope) {
			var requestUrl = Terrasoft.workspaceBaseUrl + "/rest/" + this.serviceName + "/" + methodName;
			Terrasoft.AjaxProvider.request({
				url: requestUrl,
				headers: {
					"Accept": "application/json",
					"Content-Type": "application/json"
				},
				method: "POST",
				jsonData: data || {},
				callback: function(request, success, response) {
					var responseObject = success ? Terrasoft.decode(response.responseText) : {};
					callback.call(scope || this, responseObject);
				},
				scope: this
			});
		},

		/**
		 * Метод вызывает метод веб сервиса с указанными параметрами.
		 * Обрабатывает возвращающее значерние, подготавливая к использованию.
		 * @param {String} methodName Имя метода веб сервиса.
		 * @param {Object} data Обьект данных для метода веб сервиса.
		 * @param {Function} callback Функция обратного вызова.
		 * @param {Object} scope Объект окружения фукнции обратного вызова.
		 */
		callRightServiceMethod: function(methodName, data, callback, scope) {
			this.callServiceMethod(methodName, data, function(responseObject) {
				if (!this.isDestroyed) {
					callback.call(scope || this, responseObject[methodName + "Result"]);
				}
			}, this);
		},

		/**
		 * Проверяет права текущего пользователя на конкретную операцию.
		 * @param {Object} data Обьект данных для метода веб сервиса.
		 * @param {Function} callback Функция обратного вызова.
		 * @param {Object} scope Объект окружения фукнции обратного вызова.
		 */
		checkCanExecuteOperation: function(data, callback, scope) {
			var storageKey = "GetCanExecuteOperation!" + data.operation;
			var requestFunction = function(innerCallback) {
				this.callRightServiceMethod("GetCanExecuteOperation", data, innerCallback, this);
			};
			StorageUtilities.workRequestWithStorage(storageKey, requestFunction, function() {
				callback.apply(scope, arguments);
			}, this);
		},

		/**
		 * Проверяет права текущего пользователя на операции. Возвращает объект доступа на каждую операцию.
		 * @param {String[]} operations Список операций.
		 * @param {RightUtilities~onCheckCanExecuteOperations} callback Функция обратного вызова.
		 * @param {Object} scope Объект окружения фукнции обратного вызова.
		 */
		checkCanExecuteOperations: function(operations, callback, scope) {
			var operationsToRequest = [];
			var requestResult = {};
			Terrasoft.each(operations, function(operation) {
				var storageKey = "GetCanExecuteOperation!" + operation;
				var storageItem = StorageUtilities.getItem(storageKey);
				if (Ext.isEmpty(storageItem)) {
					operationsToRequest.push(operation);
				} else {
					requestResult[operation] = storageItem[0];
				}
			}, this);
			var data = Ext.encode({operations: operationsToRequest});
			this.callRightServiceMethod("GetCanExecuteOperations", data, function(result) {
				Terrasoft.each(result, function(operationPermition) {
					var operationPermitionKey = operationPermition.Key;
					var operationPermitionValue = operationPermition.Value;
					var storageKey = "GetCanExecuteOperation!" + operationPermitionKey;
					StorageUtilities.setItem([operationPermitionValue], storageKey);
					requestResult[operationPermitionKey] = operationPermitionValue;
				}, this);
				if (callback) {
					callback.call(scope, requestResult)
				}
			}, this);
		},

		/**
		 * Запрашивает информацию про права на операции для объета.
		 * @param {String} schemaName Имя объекта.
		 * @param {Function} callback Функция обратного вызова.
		 * @param {Object} scope Объект окружения фукнции обратного вызова.
		 */
		getSchemaOperationRightLevel: function(schemaName, callback, scope) {
			this.callRightServiceMethod("GetSchemaOperationRightLevel", {
				"schemaName": schemaName
			}, callback, scope);
		},

		/**
		 * Запрашивает информацию про права на операции для записи.
		 * @param {String} schemaName Имя объекта.
		 * @param {String} primaryColumnValue Уникальный идентификатор записи.
		 * @param {Function} callback Функция обратного вызова.
		 * @param {Object} scope Объект окружения фукнции обратного вызова.
		 */
		getSchemaRecordRightLevel: function(schemaName, primaryColumnValue, callback, scope) {
			this.callRightServiceMethod("GetSchemaRecordRightLevel", {
				"schemaName": schemaName,
				"primaryColumnValue": primaryColumnValue
			}, callback, scope);
		},

		/**
		 * Запрашивает информацию про права на операцию удаления в объекте.
		 * @param {Object} data Обьект данных для метода веб сервиса.
		 * @param {Function} callback Функция обратного вызова.
		 * @param {Object} scope Объект окружения фукнции обратного вызова.
		 */
		checkCanDelete: function(data, callback, scope) {
			this.callRightServiceMethod("GetCanDelete", data, callback, scope);
		},

		/**
		 * Запрашивает информацию про права на операцию изменения для записи.
		 * @param {Object} data Обьект данных для метода веб сервиса.
		 * @param {Function} callback Функция обратного вызова.
		 * @param {Object} scope Объект окружения фукнции обратного вызова.
		 */
		checkCanEditRecords: function(data, callback, scope) {
			this.callRightServiceMethod("GetCanEditRecords", data, callback, scope);
		},

		/**
		 * Запрашивает информацию про права на операцию чтения для записи.
		 * @param {Object} data Обьект данных для метода веб сервиса.
		 * @param {Function} callback Функция обратного вызова.
		 * @param {Object} scope Объект окружения фукнции обратного вызова.
		 */
		checkCanReadRecords: function(data, callback, scope) {
			this.callRightServiceMethod("GetCanReadRecords", data, callback, scope);
		},

		/**
		 * Запрашивает информацию про права на операцию удаления для записей.
		 * @param {Object} data Обьект данных для метода веб сервиса.
		 * @param {Function} callback Функция обратного вызова.
		 * @param {Object} scope Объект окружения фукнции обратного вызова.
		 */
		checkMultiCanDelete: function(data, callback, scope) {
			this.callRightServiceMethod("GetCanDeleteRecords", data, callback, scope);
		},

		/**
		 * Запрашивает информацию про права на операцию изменения в объекте.
		 * @param {Object} data Обьект данных для метода веб сервиса.
		 * @param {Function} callback Функция обратного вызова.
		 * @param {Object} scope Объект окружения фукнции обратного вызова.
		 */
		checkCanEdit: function(data, callback, scope) {
			this.callRightServiceMethod("GetCanEdit", data, callback, scope);
		},

		/**
		 * Запрашивает информацию про все права на запись.
		 * @param {Object} data Обьект данных для метода веб сервиса.
		 * @param {Function} callback Функция обратного вызова.
		 * @param {Object} scope Объект окружения фукнции обратного вызова.
		 */
		getRecordRights: function(data, callback, scope) {
			this.callRightServiceMethod("GetRecordRights", data, callback, scope);
		},

		/**
		 * Запрашивает информацию про все права на запись для конкретоного пользователя.
		 * @param {Object} data Обьект данных для метода веб сервиса.
		 * @param {Function} callback Функция обратного вызова.
		 * @param {Object} scope Объект окружения фукнции обратного вызова.
		 */
		getUserRecordRights: function(data, callback, scope) {
			this.callRightServiceMethod("GetUserRecordRights", data, callback, scope);
		},

		/**
		 * Запрашивает информацию про запрещающие права на запись для конкретоного пользователя.
		 * @param {Object} data Обьект данных для метода веб сервиса.
		 * @param {Function} callback Функция обратного вызова.
		 * @param {Object} scope Объект окружения фукнции обратного вызова.
		 */
		getUseDenyRecordRights: function(data, callback, scope) {
			this.callRightServiceMethod("GetUseDenyRecordRights", data, callback, scope);
		},

		/**
		 * Запрашивает информацию про права на операцию удаления в объекте.
		 * @param {Object} data Обьект данных для метода веб сервиса.
		 * @param {Function} callback Функция обратного вызова.
		 * @param {Object} scope Объект окружения фукнции обратного вызова.
		 */
		getSchemaDeleteRights: function(data, callback, scope) {
			this.callRightServiceMethod("GetSchemaDeleteRights", data, callback, scope);
		},

		/**
		 * Запрашивает информацию про права на операцию изменения в объекте.
		 * @param {Object} data Обьект данных для метода веб сервиса.
		 * @param {Function} callback Функция обратного вызова.
		 * @param {Object} scope Объект окружения фукнции обратного вызова.
		 */
		getSchemaEditRights: function(data, callback, scope) {
			this.callRightServiceMethod("GetSchemaEditRights", data, callback, scope);
		},

		/**
		 * Запрашивает информацию про права на операцию чтения в объекте.
		 * @param {Object} data Обьект данных для метода веб сервиса.
		 * @param {Function} callback Функция обратного вызова.
		 * @param {Object} scope Объект окружения фукнции обратного вызова.
		 */
		getSchemaReadRights: function(data, callback, scope) {
			this.callRightServiceMethod("GetSchemaReadRights", data, callback, scope);
		},

		/**
		 * Применяет объект изменения прав для конкретоной записи.
		 * @param {Object} data Обьект данных для метода веб сервиса.
		 * @param {Function} callback Функция обратного вызова.
		 * @param {Object} scope Объект окружения фукнции обратного вызова.
		 */
		applyChanges: function(data, callback, scope) {
			this.callRightServiceMethod("ApplyChanges", data, callback, scope);
		}
	});

	return Ext.create(rightUtilitiesClass);

});


				// Autogenerated Code for schema RightUtilities (End)
// Autogenerated Code for schema NetworkUtilities (Start)
define('NetworkUtilitiesResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("NetworkUtilities", ["ext-base", "terrasoft", "sandbox", "NetworkUtilitiesResources", "ConfigurationEnums",
		"MaskHelper"],
function(Ext, Terrasoft, sandbox, resources, ConfigurationEnums, MaskHelper) {

	/**
	 * Проверяет, является ли строка корректным URL'ом
	 * @param {String} value Строковое представление URL'а
	 * @return {Boolean} true - если строка корректного для URL формата
	 */
	var isUrl = function(value) {
		return Terrasoft.isUrl(value);
	};

	/**
	 * Открывает URL в новом окне
	 * @param {String} value Строковое представление URL'а
	 */
	var onUrlClick = function(value) {
		if (isUrl(value)) {
			window.open(value);
		}
	};

	/**
	 * Возвращает название схемы сущности по идентификатору схемы сущности.
	 * @param {String} entitySchemaUId Идентификатор схемы сущности.
	 * @return {String} Возвращает название схемы сущности.
	 */
	var getEntitySchemaName = function(entitySchemaUId) {
		if (Ext.isEmpty(entitySchemaUId)) {
			return;
		}
		var structure = Terrasoft.where(Terrasoft.configuration.ModuleStructure, {entitySchemaUId: entitySchemaUId})[0];
		if (!structure) {
			structure = Terrasoft.where(Terrasoft.configuration.EntityStructure, {entitySchemaUId: entitySchemaUId})[0];
		}
		return (structure && !Ext.isEmpty(structure.entitySchemaName)) ? structure.entitySchemaName : null;
	};

	/**
	 * Создает относительный URL для открытия карточки сущности.
	 * @throws {Terrasoft.ArgumentNullOrEmptyException} Бросает исключение если не указно название схемы или
	 * идентификатор сущности.
	 * @param {String} entitySchema Имя или идентификатор схемы сущности.
	 * @param {String} primaryColumnValue Идентификатор сущности.
	 * @param {String} [typeColumnValue] Значение колонки типа.
	 * @param {String} [operation] Операция.
	 * @return {String} Возвращает относительный URL для открытия карточки сущности.
	 */
	var getEntityUrl = function(entitySchema, primaryColumnValue, typeColumnValue, operation) {
		var config = getEntityConfigUrl(entitySchema, primaryColumnValue, typeColumnValue, operation);
		return Terrasoft.combinePath(config.cardModule, config.cardSchema, config.operation, config.primaryColumnValue);
	};

	/**
	 * Создает конфигурацию значений объекта для URL к карточке сущности.
	 * @throws {Terrasoft.ArgumentNullOrEmptyException} Бросает исключение если не указно название схемы или
	 * идентификатор сущности.
	 * @param {String} entitySchema Имя или идентификатор схемы сущности.
	 * @param {String} primaryColumnValue Идентификатор сущности.
	 * @param {String} [typeColumnValue] Значение колонки типа.
	 * @param {String} [operation] Операция.
	 * @return {Object} Возвращает конфигурацию значений объекта для URL к карточке сущности.
	 */
	var getEntityConfigUrl = function(entitySchema, primaryColumnValue, typeColumnValue, operation) {
		var entitySchemaName = entitySchema;
		if (!entitySchemaName) {
			throw Ext.create("Terrasoft.ArgumentNullOrEmptyException");
		}
		if (!primaryColumnValue) {
			throw Ext.create("Terrasoft.ArgumentNullOrEmptyException");
		}
		var configuration = Terrasoft.configuration;
		var moduleStructure = configuration.ModuleStructure[entitySchemaName];
		var entityStructure = configuration.EntityStructure[entitySchemaName];
		if (!moduleStructure && !entityStructure) {
			entitySchemaName = getEntitySchemaName(entitySchema);
			moduleStructure = configuration.ModuleStructure[entitySchemaName];
			entityStructure = configuration.EntityStructure[entitySchemaName];
		}
		var cardModule = moduleStructure && moduleStructure.cardModule ? moduleStructure.cardModule : "CardModuleV2";
		var pages = entityStructure.pages;
		var cardSchema = pages[0].cardSchema;
		if (typeColumnValue && moduleStructure.attribute && pages.length) {
			Terrasoft.each(pages, function(page) {
				if (page.UId === typeColumnValue) {
					cardSchema = page.cardSchema;
					return false;
				}
			}, this);
		}
		var configUrl = {
			cardModule: cardModule,
			cardSchema: cardSchema,
			entitySchemaName: entitySchemaName,
			operation: operation || ConfigurationEnums.CardStateV2.EDIT,
			primaryColumnValue: primaryColumnValue
		};
		return configUrl;
	};

	/**
	 * Открывает страницу карточки сущности.
	 * @param {Object} config
	 * @param {String} config.entityId Идентификатор сущности.
	 * @param {String} config.entitySchemaName Имя схемы сущности.
	 * Если отсутствует будет определено по идентификатор схемы сущности.
	 * @param {String} config.entitySchemaUId Идентификатор схемы сущности.
	 * Может отсутствовать если задано имя схемы сущности.
	 * @param {Object} config.sandbox Песочница модуля вызывающего открытие страницы карточки сущности.
	 * @param {Object} config.stateObj Объект состояния открываемой страницы карточки сущности.
	 */
	var openEntityPage = function(config) {
		if (!Ext.isObject(config)) {
			return;
		}
		var sandbox = config.sandbox;
		var entityId = config.entityId;
		var entitySchemaName = config.entitySchemaName;
		if (Ext.isEmpty(entitySchemaName)) {
			entitySchemaName = getEntitySchemaName(config.entitySchemaUId);
		}
		if (Ext.isEmpty(sandbox) || Ext.isEmpty(entityId) || Ext.isEmpty(entitySchemaName)) {
			return;
		}
		var moduleStructure = Terrasoft.configuration.ModuleStructure[entitySchemaName];
		var attribute = (moduleStructure && moduleStructure.attribute) ? moduleStructure.attribute : null;
		if (attribute) {
			var select = Ext.create("Terrasoft.EntitySchemaQuery", {
				rootSchemaName: entitySchemaName
			});
			select.addColumn("Id");
			select.addColumn(attribute);
			select.getEntity(entityId, function(result) {
				if (result && result.success) {
					var entity = result.entity;
					var typeId = entity.get(attribute).value;
					var hash = getEntityUrl(entitySchemaName, entityId, typeId);
					sandbox.publish("PushHistoryState", {
						hash: hash,
						stateObj: config.stateObj
					});
				}
			}, this);
		} else {
			var hash = getEntityUrl(entitySchemaName, entityId);
			sandbox.publish("PushHistoryState", {
				hash: hash,
				stateObj: config.stateObj
			});
		}
	};

	/**
	 * Открывает карточку в цепочке.
	 * @param {Object} config Конфигурация настроек для открытия карточки.
	 * @param {String} config.entityId Идентификатор сущности.
	 * @param {String} config.entitySchemaName Имя схемы сущности.
	 * Если отсутствует будет определено по идентификатор схемы сущности.
	 * @param {String} config.entitySchemaUId Идентификатор схемы сущности.
	 * Может отсутствовать если задано имя схемы сущности.
	 * @param {Object} config.sandbox Песочница модуля вызывающего открытие страницы карточки сущности.
	 * @param {String} config.typeId Если отсутствует будет определено по идентификатору схемы сущности.
	 */
	var openCardInChain = function(config) {
		if (!Ext.isObject(config)) {
			return;
		}
		MaskHelper.ShowBodyMask();
		var sandbox = config.sandbox;
		var entityId = config.primaryColumnValue;
		var entitySchemaName = config.entitySchemaName;
		if (Ext.isEmpty(entitySchemaName)) {
			entitySchemaName = config.entitySchemaName = getEntitySchemaName(config.entitySchemaUId);
		}
		if (Ext.isEmpty(sandbox) || Ext.isEmpty(entityId) || Ext.isEmpty(entitySchemaName)) {
			return;
		}
		var moduleStructure = Terrasoft.configuration.ModuleStructure[entitySchemaName];
		config.moduleName = moduleStructure.cardModule || moduleStructure.sectionModule;
		var attribute = (moduleStructure && moduleStructure.attribute) ? moduleStructure.attribute : null;
		if (attribute && !config.typeId) {
			var select = Ext.create("Terrasoft.EntitySchemaQuery", {
				rootSchemaName: entitySchemaName
			});
			select.addColumn("Id");
			select.addColumn(attribute);
			select.getEntity(entityId, function(result) {
				if (result && result.success) {
					var entity = result.entity;
					var typeId = entity.get(attribute).value;
					config.typeId = typeId;
					openCard(config);
				}
			}, this);
		} else {
			openCard(config);
		}
	};

	/**
	 * Открывает карточку
	 * @param {Object} config
	 * @param {Object} config Конфигурация настроек для открытия карточки.
	 * @param {String} config.entityId Идентификатор сущности.
	 * @param {String} config.entitySchemaName Имя схемы сущности.
	 * Если отсутствует будет определено по идентификатор схемы сущности.
	 * @param {String} config.entitySchemaUId Идентификатор схемы сущности.
	 * Может отсутствовать если задано имя схемы сущности.
	 * @param {Object} config.sandbox Песочница модуля вызывающего открытие страницы карточки сущности.
	 * @param {String} config.typeId Если отсутствует будет определено по идентификатору схемы сущности.
	 * @param {String} config.operation Операция, которая будет передана карточке.
	 * По умолчанию используется ConfigurationEnums.CardStateV2.EDIT.
	 */
	function openCard(config) {
		var entitySchemaConfig = getEntityConfigUrl(config.entitySchemaName, config.primaryColumnValue, config.typeId,
			config.operation);
		var historyState = config.historyState;
		var sandbox = config.sandbox;
		var entitySchemaName = entitySchemaConfig.entitySchemaName;
		var state = {
			isSeparateMode: true,
				schemaName: entitySchemaConfig.cardSchema,
				entitySchemaName: entitySchemaName,
				operation: entitySchemaConfig.operation,
				primaryColumnValue: entitySchemaConfig.primaryColumnValue,
				isInChain: true
		};
		var typeColumnName = getTypeColumn(entitySchemaName);
		if (!Ext.isEmpty(typeColumnName) && config.typeId) {
			state.typeColumnName = typeColumnName.path;
			state.typeUId = config.typeId;
		}
		sandbox.publish("PushHistoryState", {
			hash: historyState.hash.historyState,
			silent: true,
			stateObj: state
		});
		var moduleParams = {
			renderTo: "centerPanel",
			keepAlive: true
		};
		if (config.moduleId) {
			moduleParams.id = config.moduleId
		}
		sandbox.loadModule(config.moduleName, moduleParams);
	}

	/**
	 * Получает колонку Тип для текущей схемы
	 * @protected
	 * @return {Object}
	 */
	function getTypeColumn(schemaName) {
		var schemaConfig = Terrasoft.configuration.ModuleStructure[schemaName];
		var typeColumnName = schemaConfig && schemaConfig.attribute || null;
		return typeColumnName ? {path: typeColumnName} : null;
	}

	return {
		isUrl: isUrl,
		onUrlClick: onUrlClick,
		getEntityUrl: getEntityUrl,
		getEntityConfigUrl: getEntityConfigUrl,
		openEntityPage: openEntityPage,
		openCardInChain: openCardInChain,
		getTypeColumn: getTypeColumn
	};
});


				// Autogenerated Code for schema NetworkUtilities (End)
// Autogenerated Code for schema LookupUtilities (Start)
define('LookupUtilitiesResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("LookupUtilities", ["terrasoft", "MaskHelper", "ModalBox"],
		function(Terrasoft, MaskHelper, ModalBox) {

			/**
			 * Id LookupPage-а
			 * @private
			 * @type {String}
			 */
			var lookupPageId;

			/**
			 * Контейнер в который будет отрисован LookupPage
			 * @private
			 * @type {Object}
			 */
			var modalBoxContainer;

			/**
			 * имя модуля LookupPage-а
			 * @private
			 * @type {String}
			 */
			var lookupPageName = "LookupPage";
			/**
			 * Флаг, который устанавливается, в случае если обращается CardProcessModule
			 * @private
			 * @type {Boolean}
			 */
			var openProcess;
			var ModalBoxSize = {
				MinHeight : "1",
				MinWidth : "1",
				MaxHeight : "100",
				MaxWidth : "100"
			};

			/**
			 * Посылает сообщение о том, что нужно открыть справочник
			 * Используеться только в деталях
			 * @public
			 */
			function throwOpenLookupMessage(sandbox, config, callback, scope, tag) {
				window.console.warn(Ext.String.format(Terrasoft.Resources.ObsoleteMessages.ObsoleteMethodMessage,
						"throwOpenLookupMessage", "open"));
				var handler = function(args) {
					callback.call(scope, args);
				};
				sandbox.publish("OpenLookupPage", {
					config: config,
					handler: handler
				}, tag ? [tag] : []);
			}

			function openFolderPage(sandbox, config, callback, scope) {
				var handler;
				if (callback) {
					handler = function(args) {
						callback.call(scope, args);
					};
				}
				MaskHelper.ShowBodyMask();
				sandbox.publish("OpenFolderPage", {
					config: config,
					handler: handler
				}, [sandbox.id]);
			}
			/**
			 * Возвращает структуру базовой страницы справочника
			 * @public
			 * @return {Object}
			 */
			function getBaseLookupPageStructure() {
				return [
					{
						type: Terrasoft.ViewModelSchemaItem.GROUP,
						name: "baseElementsControlGroup",
						visible: true,
						collapsed: false,
						wrapContainerClass: "main-elements-control-group-container",
						items: [{
							type: Terrasoft.core.enums.ViewModelSchemaItem.ATTRIBUTE,
							name: "Id",
							columnPath: "Id",
							visible: false,
							viewVisible: false
						}, {
							type: Terrasoft.core.enums.ViewModelSchemaItem.ATTRIBUTE,
							name: "Name",
							columnPath: "Name",
							dataValueType: Terrasoft.DataValueType.TEXT
						}, {
							type: Terrasoft.core.enums.ViewModelSchemaItem.ATTRIBUTE,
							name: "Description",
							columnPath: "Description",
							dataValueType: Terrasoft.DataValueType.TEXT
						}]
					}
				];
			}
			/**
			 * Закрывает модальное окно Lookup-а и но не выгружает сам модуль
			 * все сообщения Lookup-а остаются
			 * @public
			 */
			function hide() {
				if (!openProcess) {
					ModalBox.close();
					modalBoxContainer = null;
				}
			}
			function getFixedHeaderContainer() {
				return ModalBox.getFixedBox();
			}
			/**
			 * Существует для сохранения совместимости, т.е. для тех случаев когда Lookup открывается на весь экран
			 * Используется ТОЛЬКО с процессами
			 * @public
			 */
			function openLookupPage(sandbox, openLookupPageArgs, scope, renderTo, keepAlive, useViewModule) {
				window.console.warn(Ext.String.format(Terrasoft.Resources.ObsoleteMessages.ObsoleteMethodMessage,
						"openLookupPage", "open"));
				openProcess = true;
				if (Ext.isEmpty(openLookupPageArgs.config)) { return; }
				if (!Ext.isEmpty(openLookupPageArgs.config.lookupPageName)) {
					lookupPageName = openLookupPageArgs.config.lookupPageName;
				}
				sandbox.subscribe("CardProccessModuleInfo", function() {
					return true;
				}, [sandbox.id + "_LookupPage"]);
				if (!scope.lookupPageParamsById) {
					scope.lookupPageParamsById = [];
				}
				keepAlive = (keepAlive === undefined) ? true : keepAlive;
				lookupPageId = sandbox.id + "_LookupPage";
				sandbox.subscribe("LookupInfo", function() {
					scope.lookupPageParamsById[lookupPageId] = openLookupPageArgs.config;
					return scope.lookupPageParamsById[lookupPageId];
				}, [lookupPageId]);
				var params = sandbox.publish("GetHistoryState");
				if (keepAlive) {
					sandbox.publish("PushHistoryState", {hash: params.hash.historyState});
				}
				var moduleName = "LookupPage";
				if (openLookupPageArgs.config.moduleName) {
					moduleName = openLookupPageArgs.config.moduleName;
				}
				MaskHelper.ShowBodyMask();
				if (useViewModule) {
					sandbox.publish("LoadModule", {
						renderTo: renderTo,
						moduleId: lookupPageId,
						moduleName: moduleName,
						keepAlive: keepAlive
					});
				} else {
					sandbox.loadModule(moduleName, {
						renderTo: renderTo,
						id: lookupPageId,
						keepAlive: keepAlive
					});
				}
				sandbox.subscribe("ResultSelectedRows", openLookupPageArgs.handler, [lookupPageId]);
			}
			/**
			 * Открывает Lookup в модальном окне
			 * @public
			 * @param {Object} sandbox
			 * @param {Object} config
			 * @param {Function} callback
			 * @param {Object} scope
			 * @param {Object} renderTo
			 * @param {Boolean} keepAlive
			 * @param {Boolean} useViewModule
			 *
			 * Пример конфигурации для lookup, для которого нужна отдельная настройка колонок:
			 * var config = {
			 *		entitySchemaName: "SysAdminUnit",
			 *		multiSelect: true,
			 *		columns: ["Contact", "Name"],
			 *		hideActions: true,
			 *		lookupPostfix: "_UsersDetail"
			 * };
			 */
			function open(sandbox, config, callback, scope, renderTo, keepAlive, useViewModule) {
				var openLookupConfig = {};
				if (Ext.isEmpty(config)) { return; }
				openLookupConfig.sandbox = sandbox;
				openLookupConfig.callback = callback;
				openLookupConfig.scope = scope;
				openLookupConfig.config = config;
				openLookupConfig.renderTo = renderTo;
				if (!Ext.isEmpty(config.lookupPageName)) {
					lookupPageName = config.lookupPageName;
				}
				if (keepAlive === undefined) {
					openLookupConfig.keepAlive = false;
				} else {
					openLookupConfig.keepAlive = keepAlive;
				}
				if (useViewModule === undefined) {
					openProcess = false;
				}
				openLookupConfig.useViewModule = useViewModule;
				lookupPageId = sandbox.id + "_LookupPage";
				modalBoxContainer = ModalBox.show({
					minWidth: ModalBoxSize.MinWidth,
					maxWidth: ModalBoxSize.MaxWidth,
					minHeight: ModalBoxSize.MinHeight,
					maxHeight: ModalBoxSize.MaxHeight,
					boxClasses: config.modalBoxClasses
				}, function(destroy) {
					if (destroy) {
						sandbox.unloadModule(sandbox.id + "_LookupPage");
					}
				}, this);
				ModalBox.setSize(820, 600);
				sandbox.subscribe("LookupInfo", function() {
					if (!scope.lookupPageParamsById) {
						scope.lookupPageParamsById = [];
					}
					scope.lookupPageParamsById[lookupPageId] = openLookupConfig.config;
					scope.lookupPageParamsById[lookupPageId].isQuickAdd = config.isQuickAdd;
					scope.lookupPageParamsById[lookupPageId].valuePairs = config.valuePairs;
					return scope.lookupPageParamsById[lookupPageId];
				}, [lookupPageId]);
				MaskHelper.ShowBodyMask();
				sandbox.loadModule(lookupPageName, {
					renderTo: modalBoxContainer,
					id: lookupPageId,
					keepAlive: keepAlive
				});
				sandbox.subscribe("ResultSelectedRows", function(args) {
					openLookupConfig.callback.call(openLookupConfig.scope, args);
					close(openLookupConfig.sandbox);
				}, [lookupPageId]);
			}
			function getGridContainer() {
				return modalBoxContainer;
			}


			/**
			 * Закрывает модальное окно Lookup-а и выгружает модуль (если запущен он открыт не из CardProcessModule)
			 * @public
			 */
			function close(sandbox) {
				if (!openProcess) {
					if (modalBoxContainer && modalBoxContainer.dom) {
						ModalBox.close();
					}
					sandbox.unloadModule(sandbox.id + "_LookupPage");
				}
			}
			function updateSize() {
				ModalBox.updateSizeByContent();
			}
			return {
				Open: open,
				UpdateSize: updateSize,
				ThrowOpenLookupMessage: throwOpenLookupMessage,
				OpenLookupPage: openLookupPage,
				Close: close,
				Hide: hide,
				OpenFolder: openFolderPage,
				GetBaseLookupPageStructure: getBaseLookupPageStructure,
				GetFixedHeaderContainer: getFixedHeaderContainer,
				GetGridContainer: getGridContainer
			};
		});

				// Autogenerated Code for schema LookupUtilities (End)
// Autogenerated Code for schema HistoryStateUtilities (Start)
define('HistoryStateUtilitiesResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("HistoryStateUtilities", ["ConfigurationEnums"], function(ConfigurationEnums) {
	/**
	 * @class Terrasoft.configuration.mixins.HistoryStateUtilities
	 * Миксин, реализующий работу с текущим состоянием истории браузера.
	 */
	Ext.define("Terrasoft.configuration.mixins.HistoryStateUtilities", {
		alternateClassName: "Terrasoft.HistoryStateUtilities",

		/**
		 * Разделитель значений в состоянии истории браузера.
		 * @protected
		 * @type {String}
		 */
		delimiter: "/",

		/**
		 * Возвращает информацию по умолчанию о текущем состоянии истории браузера.
		 * @protected
		 * @return {Object} Информация по умолчанию о текущем состоянии истории браузера.
		 */
		getDefaultHistoryStateInfo: function() {
			return {module: "", schemas: [], operation: "", primaryColumnValue: ""};
		},

		/**
		 * Возвращает информацию о текущем состоянии истории браузера.
		 * @protected
		 * @return {Object} Информация о текущем состоянии истории браузера.
		 */
		getHistoryStateInfo: function() {
			var historyState = this.sandbox.publish("GetHistoryState");
			return this.parseHistoryState(historyState.hash.historyState);
		},

		/**
		 * Обрабатывает текущее состояние истории браузера.
		 * @protected
		 * @param {String} historyState Состояние истории браузера.
		 * @return {Object} Возвращает информацию о текущем состоянии истории браузера.
		 */
		parseHistoryState: function(historyState) {
			var result = this.getDefaultHistoryStateInfo();
			this.parse(historyState, result);
			this.initWorkAreaMode(result);
			return result;
		},

		/**
		 * Дополняет переданное состояние истории браузера информацией о текущем режиме рабочей области.
		 * Если схем больше, чем одна - режим совмещенный (вертикальный реестр, карточка). Иначе, если есть операция -
		 * режим карточка. Иначе - режим реестр.
		 * @protected
		 * @param {Object} result Информация о текущем состоянии истории браузера.
		 */
		initWorkAreaMode: function(result) {
			var workAreaMode = {};
			if (result.schemas.length > 1) {
				workAreaMode = ConfigurationEnums.WorkAreaMode.COMBINED;
			} else if (result.operation) {
				workAreaMode = ConfigurationEnums.WorkAreaMode.CARD;
			} else {
				workAreaMode = ConfigurationEnums.WorkAreaMode.SECTION;
			}
			result.workAreaMode = workAreaMode;
		},

		/**
		 * Обрабатывает текущее состояние истории браузера.
		 * В зависимости от последнего элемента состояния истории браузера алгоритм имеет две ветви:
		 * 1. Если последний элемент состояния истории браузера - идентификатор записи, то обработка происходит, начиная
		 * с этого элемента (свойство результирующего объекта primaryColumnValue заполнится этим элементом). Итерируя
		 * по последующим элементам, вычисляются: module - если элемент последний, operation - если не была
		 * вычислена ранее, schemas - все остальные элементы. Например:
		 * "CardModule/ContactPage/edit/guid", "SectionModule/ContactSection/ContactPage/copy/guid".
		 * 2. Иначе первый элемент - module, последующие - schemas, последний - operation. Например:
		 * "SectionModule/ContactSection", "CardModule/ContactPage/add", "SectionModule/ContactSection/ContactPage/add".
		 * @private
		 * @param {String} historyState Состояние истории браузера.
		 * @param {Object} result Информация о текущем состоянии истории браузера.
		 * @return {Object} Возвращает информацию о текущем состоянии истории браузера.
		 */
		parse: function(historyState, result) {
			historyState = this.clean(historyState);
			var historyStateItems = historyState.split(this.delimiter);
			var historyStateItemsLength = historyStateItems.length;
			var reverse = this.Terrasoft.isGUID(historyStateItems[historyStateItemsLength - 1]);
			this.prepare(historyStateItems, reverse);
			var currentItemIndex = 0;
			var currentItem = historyStateItems[currentItemIndex];
			if (reverse) {
				result.primaryColumnValue = currentItem;
			} else {
				result.module = currentItem;
			}
			while (++currentItemIndex < historyStateItemsLength) {
				currentItem = historyStateItems[currentItemIndex];
				var isLast = (currentItemIndex === historyStateItemsLength - 1);
				var schemas = result.schemas;
				if (reverse) {
					if (isLast) {
						result.module = currentItem;
					} else if (!result.operation) {
						result.operation = currentItem;
					} else {
						schemas.unshift(currentItem);
					}
				} else {
					if (isLast && schemas.length) {
						result.operation = currentItem;
					} else {
						schemas.push(currentItem);
					}
				}
			}
			return result;
		},

		/**
		 * У заданного состояния истории браузера удаляет начальные и конечные пробелы,
		 * а также конечный символ-разделитель, если он есть.
		 * @param {String} historyState Состояние истории браузера.
		 * @return {String} Отформатированное состояние истории браузера.
		 */
		clean: function(historyState) {
			historyState = historyState.trim();
			if (historyState.substr(-1) === this.delimiter) {
				historyState = historyState.slice(0, -1);
			}
			return historyState;
		},

		/**
		 * Выполняет инвертирование порядка элементов состояния истории браузера в зависимости от значения флага
		 * {@link reverse}.
		 * @param {Array} items Элементы состояния истории браузера.
		 * @param {Boolean} reverse True, если необходимо выполнить инвертирование порядка элементов состояния истории
		 * браузера.
		 */
		prepare: function(items, reverse) {
			if (reverse) {
				items.reverse();
			}
		},

		/**
		 * Возвращает информацию о текущем разделе.
		 * @protected
		 * @return {Object} Информация о текущем разделе.
		 */
		getSectionInfo: function() {
			var historyState = this.getHistoryStateInfo();
			var sectionSchema = historyState.schemas[0];
			if (!sectionSchema) {
				var sectionModule = historyState.module;
			}
			var sectionInfo = null;
			Terrasoft.each(Terrasoft.configuration.ModuleStructure, function(moduleStructureItem) {
				if ((sectionSchema && moduleStructureItem.sectionSchema === sectionSchema) ||
						(sectionModule && moduleStructureItem.sectionModule === sectionModule)) {
					sectionInfo = moduleStructureItem;
					return false;
				}
			}, this);
			return sectionInfo;
		}

	});
	return Terrasoft.HistoryStateUtilities;
});


				// Autogenerated Code for schema HistoryStateUtilities (End)
// Autogenerated Code for schema BaseSchemaViewModel (Start)
define('BaseSchemaViewModelResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("BaseSchemaViewModel", ["MaskHelper", "NetworkUtilities", "LookupUtilities",
	"ConfigurationEnums", "ModuleUtils", "HistoryStateUtilities", "RightUtilities"],
	function(MaskHelper, NetworkUtilities, LookupUtilities, ConfigurationEnums, moduleUtils) {

		/**
		 * @class Terrasoft.configuration.BaseSchemaViewModel
		 * Конфигурационный базовый класс модели представления.
		 */
		Ext.define("Terrasoft.configuration.BaseSchemaViewModel", {
			alternateClassName: "Terrasoft.BaseSchemaViewModel",
			extend: "Terrasoft.BaseViewModel",

			Ext: null,

			sandbox: null,

			Terrasoft: null,

			/**
			 * Идентификатор маски.
			 * @type {String}
			 */
			bodyMaskId: "",

			/**
			 * Имя контейнера, в который отрендерена ViewModel.
			 */
			renderTo: "",

			/**
			 * Название метода модели представления, который будет вызван после нажатия на элмент меню кнопки "Действия".
			 */
			actionsClickMethodName: "onCardAction",

			/**
			 * Используемые сообщения.
			 * @protected
			 */
			messages: {
				/**
				 * @message LookupInfo
				 * Для работы LookupUtilities.
				 */
				"LookupInfo": {
					mode: Terrasoft.MessageMode.PTP,
					direction: Terrasoft.MessageDirectionType.SUBSCRIBE
				},

				/**
				 * @message ResultSelectedRows
				 * Для работы LookupUtilities.
				 */
				"ResultSelectedRows": {
					mode: Terrasoft.MessageMode.PTP,
					direction: Terrasoft.MessageDirectionType.SUBSCRIBE
				}
			},

			/**
			 *
			 */
			mixins: {
				/**
				 * Миксин, реализующий работу с HistoryState.
				 */
				HistoryStateUtilities: "Terrasoft.HistoryStateUtilities",

				/**
				 * @class RightUtilitiesMixin реализующий базовые с правами.
				 */
				RightUtilitiesMixin: "Terrasoft.RightUtilitiesMixin"
			},

			/**
			 * Создает экземпляр схемы.
			 */
			constructor: function() {
				this.callParent(arguments);
				this.registerMessages();
			},

			/**
			 * Инициализует модель представления.
			 * @protected
			 * @virtual
			 * @param {Function} callback Функция обратного вызова.
			 * @param {Object} scope Объект окружения фукнции обратного вызова.
			 */
			init: function(callback, scope) {
				this.initializeProfile(function() {
					this.initTypeColumnName();
					this.setValidationConfig();
					if (this.Ext.isFunction(callback)) {
						callback.call(scope);
					}
				}, this);
			},

			/**
			 * Инициализирует колонку профиля в модели представления значением.
			 * @protected
			 * @virtual
			 * @param {Function} callback Функция обратного вызова.
			 * @param {Object} scope Объект окружения фукнции обратного вызова.
			 */
			initializeProfile: function(callback, scope) {
				this.requireProfile(function(profile) {
					var profileColumnName = this.getProfileColumnName();
					this.set(profileColumnName, profile);
					if (this.Ext.isFunction(callback)) {
						callback.call(scope);
					}
				}, this);
			},

			/**
			 * Загружает профиль текущей схемы.
			 * @protected
			 * @virtual
			 * @param {Function} callback Функция обратного вызова.
			 * @param {Object} scope Объект окружения фукнции обратного вызова.
			 */
			requireProfile: function(callback, scope) {
				var profileKey = this.getProfileKey();
				this.Terrasoft.require(["profile!" + profileKey], function(profile) {
					if (this.Ext.isFunction(callback)) {
						callback.call(scope, profile);
					}
				}, this);
			},

			/**
			 * Добавляет валидатор для указанной колонки.
			 * @protected
			 * @virtual
			 * @param {String} columnName Имя колонки для валидации.
			 * @param {Function} validatorFn Функция валидации.
			 */
			addColumnValidator: function(columnName, validatorFn) {
				var columnValidationConfig = this.validationConfig[columnName] || (this.validationConfig[columnName] = []);
				columnValidationConfig.push(validatorFn);
			},

			/**
			 * Инициализирует пользовательские валидаторы.
			 * @protected
			 * @virtual
			 */
			setValidationConfig: Terrasoft.emptyFn,

			/**
			 * Возвращает ключ профиля.
			 * @virtual
			 * @return {string} Ключ профиля.
			 */
			getProfileKey: function() {
				return "";
			},

			/**
			 * Отображает маску.
			 * @protected
			 * @param {Object} config Параметры для отображения маски.
			 */
			showBodyMask: function(config) {
				MaskHelper.ShowBodyMask(config);
			},

			/**
			 * Удаляет маску по идентификатору.
			 * protected
			 */
			hideBodyMask: function() {
				MaskHelper.HideBodyMask();
			},

			/**
			 * Инициализирует коллекцию страниц редактирования сущности.
			 * @protected
			 */
			initEditPages: function() {
				var collection = Ext.create("Terrasoft.BaseViewModelCollection");
				var entityStructure = this.getEntityStructure(this.entitySchemaName);
				if (entityStructure) {
					Terrasoft.each(entityStructure.pages, function(editPage) {
						var typeUId = editPage.UId || Terrasoft.GUID_EMPTY;
						collection.add(typeUId, Ext.create("Terrasoft.BaseViewModel", {
							values: {
								Id: typeUId,
								Caption: editPage.caption,
								Click: {bindTo: "addRecord"},
								Tag: typeUId,
								SchemaName: editPage.cardSchema
							}
						}));
					}, this);
				}
				this.set("EditPages", collection);
			},

			/**
			 * Очищает значения колонок схемы, устанавливая null. Очищает параметр измененных значений.
			 * @protected
			 * @virtual
			 */
			clearEntity: function() {
				Terrasoft.each(this.columns, function(column, columnName) {
					if ((column.type === Terrasoft.ViewModelColumnType.ENTITY_COLUMN) && !column.isCollection) {
						this.setColumnValue(columnName, null, {preventValidation: true});
					}
				}, this);
				this.changedValues = {};
			},

			/**
			 * Инициализурует колонку схемы, отвечающую за хранение название колонки типа.
			 * @protected
			 * @virtual
			 */
			initTypeColumnName: function() {
				var typeColumnName = null;
				var entityStructure = this.getEntityStructure(this.entitySchemaName);
				if (entityStructure) {
					Terrasoft.each(entityStructure.pages, function(editPage) {
						if (editPage.typeColumnName) {
							typeColumnName = editPage.typeColumnName;
						}
						return false;
					}, this);
				}
				this.set("TypeColumnName", typeColumnName);
			},

			/**
			 * Получает название страницы редактирования сущности.
			 * @param {String} typeUId Значение колонки типа.
			 * @return {String} Возвращает название страницы редактирования сущности.
			 */
			getEditPageSchemaName: function(typeUId) {
				var editPages = this.get("EditPages");
				if (editPages.contains(typeUId)) {
					var editPage = editPages.get(typeUId);
					return editPage.get("SchemaName");
				}
			},

			/**
			 * Метод возвращает объект по его имени.
			 * @param {String} entitySchemaName Имя объекта.
			 * @param {Function} callback Функция обратного вызова.
			 * @param {Object} scope Контекст вызова функции обратного вызова.
			 */
			getEntitySchemaByName: function(entitySchemaName, callback, scope) {
				scope = scope || this;
				this.sandbox.requireModuleDescriptors(["force!" + entitySchemaName], function() {
					Terrasoft.require([entitySchemaName], callback, scope);
				}, scope);
			},

			/**
			 * Расширяет конфигурацию сообщений модуля, сообщениями описанными в схеме.
			 * @protected
			 */
			registerMessages: function() {
				this.sandbox.registerMessages(this.messages);
			},

			/**
			 * Открывает справочник в модальном окне.
			 * @protected
			 * @param {Object} config Конфигурация справочника.
			 * @param {Function} callback Функция обратного вызова.
			 * @param {Object} scope Контекст функции обратного вызова.
			 */
			openLookup: function(config, callback, scope) {
				LookupUtilities.Open(this.sandbox, config, callback, scope || this, null, false, false);
			},

			/**
			 * Возвращает значение типа.
			 */
			getTypeColumnValue: function(row) {
				var typeColumnValue = this.Terrasoft.GUID_EMPTY;
				var typeColumnName = this.get("TypeColumnName");
				if (typeColumnName) {
					typeColumnValue = (row.get(typeColumnName) && row.get(typeColumnName).value);
				}
				return typeColumnValue;
			},

			/**
			 * Метод вызывает метод веб сервиса с указанными параметрами.
			 * @param {Object} config обьект, который содержит название сервиса, название метода, данные.
			 * @param {Function} callback
			 * @param {Object} scope
			 * @returns {Object} обьект запроса.
			 */
			callService: function(config, callback, scope) {
				var dataSend = config.data || {};
				var jsonData = (config.encodeData === false) ? dataSend : Ext.encode(dataSend);
				var requestUrl = this.Terrasoft.combinePath(this.Terrasoft.workspaceBaseUrl, "rest", config.serviceName,
					config.methodName);
				return this.Terrasoft.AjaxProvider.request({
					url: requestUrl,
					headers: {
						"Accept": "application/json",
						"Content-Type": "application/json"
					},
					method: "POST",
					jsonData: jsonData,
					callback: function() {
						var success = arguments[1];
						var response = arguments[2];
						var responseObject = success ? Terrasoft.decode(response.responseText) : {};
						callback.call(this, responseObject);
					},
					scope: scope || this
				});
			},

			/**
			 * Получает конфигурацию иконки кнопки "Закрыть".
			 * @return {Object} Возвращает конфигурацию иконки кнопки "Закрыть".
			 */
			getCloseButtonImageConfig: function() {
				return this.getResourceImageConfig("Resources.Images.CloseButtonImage");
			},

			/**
			 * Получает конфигурацию иконки кнопки "Назад".
			 * @return {Object} Возвращает конфигурацию иконки кнопки "Назад".
			 */
			getBackButtonImageConfig: function() {
				return this.getResourceImageConfig("Resources.Images.BackButtonImage");
			},

			/**
			 * Получает конфигурацию иконки кнопки "Настройки" в выбранной строке реестра.
			 * @return {Object} Возвращает конфигурацию иконки кнопки "Настройки" в выбранной строке реестра.
			 */
			getActiveRowSettingsButtonImageConfig: function() {
				return this.getResourceImageConfig("Resources.Images.SettingsButtonImage");
			},

			/**
			 * Генерирует конфигурацию ссылки на изображение в ресурсах.
			 * @param {String} resourceName Имя ресурса.
			 * @return {Object} Возвращает конфигурацию ссылки на изображение в ресурсах.
			 */
			getResourceImageConfig: function(resourceName) {
				return {
					source: this.Terrasoft.ImageSources.URL,
					url: this.Terrasoft.ImageUrlBuilder.getUrl(this.get(resourceName))
				};
			},

			/**
			 * Добавляет подзапрос, который вычисляет количество активных точек входа по процессу.
			 * @param {Object} esq
			 */
			addProcessEntryPointColumn: function(esq) {
				var expressionConfig = {
					columnPath: "[EntryPoint:EntityId].Id",
					parentCollection: this,
					aggregationType: Terrasoft.AggregationType.COUNT
				};
				var column = Ext.create("Terrasoft.SubQueryExpression", expressionConfig);
				var filter = esq.createColumnFilterWithParameter(Terrasoft.ComparisonType.EQUAL, "IsActive", true);
				column.subFilters.addItem(filter);
				var esqColumn = esq.addColumn("EntryPointsCount");
				esqColumn.expression = column;
			},

			/**
			 * Метод запуска мастера раздела.
			 */
			startSectionDesigner: function() {
				var location = window.location;
				var origin = location.origin || location.protocol + "//" + location.host;
				var url = Ext.String.format("{0}{1}#SectionDesigner", origin, location.pathname);
				var schemaName = this.name;
				Terrasoft.each(Terrasoft.configuration.ModuleStructure, function(structure, sectionCode) {
					if (structure.sectionSchema === schemaName) {
						url += "/" + sectionCode;
						var historyStateInfo = this.getHistoryStateInfo();
						var schemas = historyStateInfo.schemas;
						var cardPage = (historyStateInfo.module === "CardModuleV2") ? schemas[0] : schemas[1];
						if (cardPage) {
							url += "/Page/" + cardPage;
						}
						return false;
					} else if (structure.pages) {
						var length = structure.pages.length;
						for (var i = 0; i < length; i++) {
							var page = structure.pages[i];
							if (page.cardSchema === schemaName) {
								url += "/" + sectionCode + "/Page/" + schemaName;
								return false;
							}
						}
					} else if (structure.cardSchema === schemaName) {
						url += "/" + sectionCode + "/Page/" + schemaName;
						return false;
					}
				}, this);
				require(["SectionDesignerUtils"], function(module) {
					module.start(url);
				});
			},

			/**
			 * @obsolete
			 */
			getActionsMenuItem: function(config) {
				var message = this.Ext.String.format(this.Terrasoft.Resources.ObsoleteMessages.ObsoleteMethodMessage,
					"getActionsMenuItem", "getButtonMenuItem");
				var schemaName = this.name;
				if (schemaName) {
					message = schemaName + ": " + message;
				}
				this.log(message, this.Terrasoft.LogMessageType.WARNING);
				return this.getButtonMenuItem(config);
			},

			/**
			 * Создает экземпляр элмента выпадающего меню кнопки.
			 * @param {Object} config Конфигурация.
			 * @return {Terrasoft.BaseViewModel} Возвращает экземпляр элмента выпадающего меню кнопки.
			 */
			getButtonMenuItem: function(config) {
				return this.Ext.create("Terrasoft.BaseViewModel", {
					values: this.Ext.apply({}, config, {
						Id: this.Terrasoft.generateGUID(),
						Caption: "",
						Click: (config.Type === "Terrasoft.MenuSeparator") ? null : {bindTo: this.actionsClickMethodName},
						MarkerValue: config.Caption
					})
				});
			},

			/**
			 * Создает экземпляр разделителя выпадающего меню кнопки.
			 * @param {Object} [config] Конфигурация.
			 * @return {Terrasoft.BaseViewModel} Возвращает экземпляр разделителя выпадающего меню кнопки.
			 */
			getButtonMenuSeparator: function(config) {
				return this.Ext.create("Terrasoft.BaseViewModel", {
					values: this.Ext.apply({}, config, {
						Id: this.Terrasoft.generateGUID(),
						Caption: "",
						Type: "Terrasoft.MenuSeparator"
					})
				});
			},

			/**
			 * Обрабатывает сворачивание или разворачивание детали.
			 * @protected
			 * @virtual
			 * @param {Boolean} isCollapsed Значение свернутости детали.
			 * @param {String} controlId Идентификатор элемента управления, в который загружена деталь.
			 */
			onCollapsedChanged: function(isCollapsed, controlId) {
				var profile = this.getProfile();
				var profileKey = this.getProfileKey();
				if (this.Terrasoft.isEmptyObject(profile)) {
					profile = {key: profileKey};
					this.set("Profile", profile);
				}
				var profileControlGroups = profile.controlGroups = profile.controlGroups || {};
				profileControlGroups[controlId] = {isCollapsed: isCollapsed};
				this.Terrasoft.utils.saveUserProfile(profileKey, profile, false);
			},

			/**
			 * Возвращает профиль текущей схемы.
			 * @return {Object} Профиль текущей схемы.
			 */
			getProfile: function() {
				var profileColumnName = this.getProfileColumnName();
				return this.get(profileColumnName);
			},

			/**
			 * Возвращает название колонки, в которой хранится профиль текущей схемы.
			 * @return {Object} Название колонки, в которой хранится профиль текущей схемы.
			 */
			getProfileColumnName: function() {
				return "Profile";
			},

			/**
			 * Возвращает обратное пришедшему значение. Используется для конвертера в привязках на значение.
			 * @param {boolean} value Значение.
			 * @return {boolean} Обратное значение.
			 */
			invertBooleanValue: function(value) {
				return !value;
			},

			/**
			 * Обработчик нажатия на заголовок логической колонки.
			 * @protected
			 * @virtual
			 */
			invertColumnValue: function(columnName) {
				if (columnName) {
					var currentValue = this.get(columnName);
					this.set(columnName, !currentValue);
				}
			},

			/**
			 * Событие фокусировки элемента редактирования.
			 * @protected
			 * @virtual
			 */
			onItemFocused: Terrasoft.emptyFn,

			/**
			 *
			 */
			onRender: Terrasoft.emptyFn,

			/**
			 * Очищает все подписки на сообщения.
			 * @inheritdoc Terrasoft.core.BaseObject#destroy
			 * @overridden
			 */
			destroy: function() {
				if (this.messages) {
					var messages = this.Terrasoft.keys(this.messages);
					this.sandbox.unRegisterMessages(messages);
				}
				this.callParent(arguments);
			},

			/**
			 * Возвращает структуру раздела.
			 * @protected
			 * @param {String} moduleName Название объекта.
			 * @return {Object} Структура раздела.
			 */
			getModuleStructure: function(moduleName) {
				return moduleUtils.getModuleStructureByName(moduleName || this.entitySchemaName);
			},

			/**
			 * Возвращает информации о схеме объекта данных для текущей сущности.
			 * @protected
			 * @param {String} entitySchemaName Название схемы объекта.
			 * @return {Object} Информация о схеме объета данных.
			 */
			getEntityStructure: function(entitySchemaName) {
				return moduleUtils.getEntityStructureByName(entitySchemaName || this.entitySchemaName);
			},

			/**
			 * Получает значение гиперссылки.
			 * @protected
			 * @param {String} columnName Название колонки.
			 */
			getLinkUrl: function(columnName) {
				var column = this.columns[columnName];
				var columnValue = this.get(columnName);
				if (!column) {
					return {};
				}
				var referenceSchemaName = column.referenceSchemaName;
				var entitySchemaConfig = this.getModuleStructure(referenceSchemaName);
				if (columnValue && entitySchemaConfig) {
					var typeAttr = NetworkUtilities.getTypeColumn(referenceSchemaName);
					var typeUId;
					if (typeAttr && columnValue[typeAttr.path]) {
						typeUId = columnValue[typeAttr.path].value;
					}
					var url = NetworkUtilities.getEntityUrl(referenceSchemaName, columnValue.value, typeUId);
					return {
						url: "ViewModule.aspx#" + url,
						caption: columnValue.displayValue
					};
				}
				return {};
			},

			/**
			 * Получает название карточки редактирования сущности.
			 * @param {String} entitySchemaName Название схемы сущности.
			 * @param {String} columnName Название колонки.
			 * @return {String} Название карточки редактирования сущности.
			 */
			getCardSchemaName: function(entitySchemaName, columnName) {
				var entitySchemaConfig = this.getModuleStructure(entitySchemaName);
				var cardSchema = entitySchemaConfig.cardSchema;
				if (entitySchemaConfig.attribute) {
					var typeId = this.get(columnName + "." + entitySchemaConfig.attribute) ||
						this.get(entitySchemaConfig.attribute);
					Terrasoft.each(entitySchemaConfig.pages, function(item) {
						if (typeId && item.UId === typeId.value && item.cardSchema) {
							cardSchema = item.cardSchema;
						}
					}, this);
				}
				return cardSchema;
			},

			/**
			 * Обрабатывает нажатие на ссылку в элементе управления.
			 * @param {String} url Гиперссылка.
			 * @param {String} columnName Название колонки.
			 * @return {Boolean} Признак, отменять или нет DOM обработчик нажатия на ссылку.
			 */
			onLinkClick: function(url, columnName) {
				var column = this.columns[columnName];
				var columnValue = this.get(columnName);
				if (!column) {
					return true;
				}
				var entitySchemaName = column.referenceSchemaName;
				var cardSchema = this.getCardSchemaName(entitySchemaName, columnName);
				var config = {
					schemaName: cardSchema,
					id: columnValue.value,
					operation: ConfigurationEnums.CardStateV2.EDIT,
					renderTo: "centerPanel",
					isLinkClick: true
				};
				this.openCardInChain(config);
				return false;
			},

			/**
			 * Обрабатывает изменение значение в LookupEdit.
			 * @protected
			 * @virtual
			 */
			onLookupChange: Terrasoft.emptyFn,

			/**
			 * Выполняет открытие карточки в цепочке.
			 * @protected
			 * @virtual
			 * @param {Object} config Конфигурация открываемой карточки.
			 */
			openCardInChain: function(config) {
				this.showBodyMask();
				var historyState = this.sandbox.publish("GetHistoryState");
				var stateObj = config.stateObj || {
					isSeparateMode: config.isSeparateMode || true,
					schemaName: config.schemaName,
					entitySchemaName: config.entitySchemaName,
					operation: config.action || config.operation,
					primaryColumnValue: config.id,
					valuePairs: config.defaultValues,
					isInChain: true
				};
				this.sandbox.publish("PushHistoryState", {
					hash: historyState.hash.historyState,
					silent: config.silent,
					stateObj: stateObj
				});
				var moduleName = config.moduleName || "CardModuleV2";
				var moduleParams = {
					renderTo: config.renderTo || this.renderTo,
					id: config.moduleId,
					keepAlive: (config.keepAlive !== false)
				};
				var instanceConfig = config.instanceConfig;
				if (instanceConfig) {
					this.Ext.apply(moduleParams, {
						instanceConfig: instanceConfig
					});
				}
				this.sandbox.loadModule(moduleName, moduleParams);
			},

			/**
			 * Загружает модуль.
			 * @param {Object} config Объект с свойствами для установки.
			 * @param {String} config.moduleName Имя загружаемого модуля.
			 * @param {String} config.containerId Контейнер, куда будет загружаться модуль.
			 */
			loadModule: function(config) {
				if (Ext.isEmpty(config.moduleName) || Ext.isEmpty(config.containerId)) {
					return;
				}
				var moduleId = this.getModuleId(config.moduleName);
				var moduleConfig = {
					renderTo: config.containerId
				};
				if (!Ext.isEmpty(moduleId)) {
					moduleConfig.id = moduleId;
				}
				this.sandbox.loadModule(config.moduleName, moduleConfig);
			},

			/**
			 * Возвращает Id модуля.
			 * @virtual
			 * @param {String} moduleName Имя модуля.
			 * @return {string} Id модуля.
			 */
			getModuleId: function() {
				return "";
			}
		});

		return Terrasoft.BaseSchemaViewModel;

	});


				// Autogenerated Code for schema BaseSchemaViewModel (End)
// Autogenerated Code for schema ViewModelGeneratorV2 (Start)
define('ViewModelGeneratorV2Resources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={
	EntitySchemaNotFountExceptionMessage: 'Объект {0} не найден'
};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("ViewModelGeneratorV2", ["ext-base", "terrasoft", "ViewModelGeneratorV2Resources",
	"BaseSchemaViewModel", "BaseGeneratorV2"],
	function(Ext, Terrasoft, resources, BaseSchemaViewModel) {
	/**
	 * @class Terrasoft.configuration.ViewModelGenerator
	 * Класс, генерирующий модель представления
	 */
	var viewModelGenerator = Ext.define("Terrasoft.configuration.ViewModelGenerator", {
		alternateClassName: "Terrasoft.ViewModelGenerator",
		extend: "Terrasoft.BaseGenerator",

		/**
		 * Название глобального пространства имен
		 * @private
		 * @type {String}
		 */
		globalNamespace: "Terrasoft",

		/**
		 * Название пространства имен моделей
		 * @private
		 * @type {String}
		 */
		modelNamespace: "Terrasoft.model",

		/**
		 * Суффикс имени класса моделей представления
		 * @private
		 * @type {String}
		 */
		viewModelClassSuffix: "ViewModel",

		/**
		 * Суффикс названия колонки ресурсов
		 * @private
		 * @type {String}
		 */
		resourcesSuffix: "Resources",

		/**
		 * Суффикс имени класса моделей представления
		 * @private
		 * @type {String}
		 */
		lookupColumnListSuffix: "List",

		/**
		 * Объект типов ресурсов
		 * @private
		 * @type {Object}
		 */
		resourceType: {
			STRING: "Strings",
			IMAGE: "Images"
		},

		/**
		 * Название колонки профиля
		 * @private
		 * @type {String}
		 */
		profileColumnName: "Profile",

		/**
		 * Суффикс названия коллекции
		 * @private
		 * @type {String}
		 */
		collectionSuffix: "Collection",

		/**
		 * Имя базового класса моделей представления
		 * @private
		 * @type {String}
		 */
		baseViewModelClass: BaseSchemaViewModel,

		/**
		 * Признак, отвечающий за кеширование класов при создании
		 * @protected
		 * @virtual
		 * @type {Boolean}
		 */
		useCache: true,

		/**
		 * Применяет пакет разницы на представление родительской схемы
		 * @protected
		 * @virtual
		 * @param {Object[]} parentView Конфигурация представления родительской схемы
		 * @param {Object[]} diff Пакет разницы. Представляет собой массив операций модификации родительской схемы
		 * @return {Object[]} Возвращает структуру представления с примененным пакетом разницы
		 */
		applyViewDiff: function(parentView, diff) {
			return Terrasoft.JsonApplier.applyDiff(parentView, diff);
		},

		/**
		 * Генерирует все классы представления заданной иерархии схем и возвращает класс последней схемы в иерархии
		 * @private
		 * @param {Object[]} hierarchy Иерархия схем
		 * @return {Object} Возвращает родительский класс
		 */
		generateSchemaClass: function(hierarchy) {
			var parentClass = this.baseViewModelClass;
			var viewConfig = [];
			Terrasoft.each(hierarchy, function(schema) {
				viewConfig = this.applyViewDiff(viewConfig, schema.diff);
				parentClass = this.generateClass(parentClass, schema, viewConfig);
			}, this);
			return parentClass;
		},

		/**
		 * Генерирует класс иерархии
		 * @private
		 * @param {Object} parentClass Родительский класс
		 * @param {Object} schema Схема генерации класса
		 * @param {Object} viewConfig Конфигурационный объект представления схемы
		 * @return {Object} Возвращает созданный класс
		 */
		generateClass: function(parentClass, schema, viewConfig) {
			var parentClassPrototype = parentClass.prototype;
			var entitySchemaName = schema.entitySchemaName || parentClassPrototype.entitySchemaName || "";
			var className = schema.schemaName + entitySchemaName + this.viewModelClassSuffix;
			var fullClassName = this.modelNamespace + "." + className;
			var definedClass = Ext.ClassManager.get(fullClassName);
			if (definedClass && this.useCache) {
				return definedClass;
			}
			var alternateClassName = this.globalNamespace + "." + className;
			var classConfig = {
				extend: parentClassPrototype.alternateClassName,
				alternateClassName: alternateClassName,
				mixins: schema.mixins,
				uId: schema.schemaUId,
				name: schema.schemaName,
				entitySchemaName: entitySchemaName,
				type: schema.type,
				Ext: null,
				Terrasoft: null,
				sandbox: null,
				columns: {},
				rules: {},
				details: {},
				messages: {},
				resources: {}
			};
			this.applyMethods(classConfig, schema.methods);
			this.initEntitySchema(classConfig, entitySchemaName);
			this.applyParentColumns(classConfig.columns, parentClassPrototype.columns);
			this.applyEntitySchemaColumns(classConfig.columns, schema.entitySchema);
			this.applySchemaAttributes(classConfig.columns, schema.attributes);
			this.applyProfile(classConfig, schema.profile);
			this.applyParentMessages(classConfig.messages, parentClassPrototype.messages);
			this.applyMessages(classConfig.messages, schema.messages);
			if (schema.type === Terrasoft.SchemaType.EDIT_VIEW_MODEL_SCHEMA) {
				this.applySchemaBusinessRules(classConfig.rules, parentClassPrototype.rules, schema.rules);
				this.applySchemaDetails(classConfig.details, parentClassPrototype.details, schema.details);
			}
			this.applyResources(classConfig.columns, schema.resources);
			this.addViewColumns(classConfig.columns, viewConfig);
			this.applyUserCode(classConfig, schema.userCode);
			return Ext.define(fullClassName, classConfig);
		},

		/**
		 * Добавляет колонку профиля в схему генерируемого класса
		 * @protected
		 * @virtual
		 * @param {Object} config Конфигурационный объект класса
		 * @param {Object} profile Профиль
		 */
		applyProfile: function(config, profile) {
			var  profileColumnName = this.profileColumnName;
			config.columns[profileColumnName] = {
				name: profileColumnName,
				value: profile,
				dataValueType: Terrasoft.DataValueType.CUSTOM_OBJECT,
				type: Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN
			};
		},

		/**
		 * Применяет сообщения родительского класса к сообщениям схемы генерируемого класса
		 * @protected
		 * @virtual
		 * @param {Object} messagesConfig Сообщения схемы генерируемого класса
		 * @param {Object} parentMessages Сообщения родительского класса
		 */
		applyParentMessages: function(messagesConfig, parentMessages) {
			this.applyMessages(messagesConfig, parentMessages);
		},

		/**
		 * Применяет сообщения схемы к сообщениям схемы генерируемого класса
		 * @protected
		 * @virtual
		 * @param {Object} messagesConfig Сообщения схемы генерируемого класса
		 * @param {Object} schemaMessages Сообщения схемы
		 */
		applyMessages: function(messagesConfig, schemaMessages) {
			Terrasoft.each(schemaMessages, function(schemaMessage, messageName) {
				var message = messagesConfig[messageName];
				if (message) {
					Ext.apply(message, schemaMessage);
				} else {
					messagesConfig[messageName] = Terrasoft.deepClone(schemaMessage);
				}
			}, this);
		},

		/**
		 * Применяет мотоды схемы к схеме генерируемого класса
		 * @param {Object} config Конфигурационный объект класса
		 * @param {Object} methods Методы схемы
		 */
		applyMethods: function(config, methods) {
			Ext.apply(config, Terrasoft.deepClone(methods));
		},

		/**
		 * Инициализирует схему сущности
		 * @protected
		 * @virtual
		 * @throws {Terrasoft.ItemNotFoundException}
		 * Если объект не найден генерируется исключение.
		 * @param {Object} classConfig Конфигурационный объект класса
		 * @param {String} entitySchemaName Название схемы сущности
		 */
		initEntitySchema: function(classConfig, entitySchemaName) {
			if (Ext.isEmpty(entitySchemaName)) {
				return;
			}
			var entitySchemaClassName = this.globalNamespace + "." + entitySchemaName;
			var entitySchema = Ext.ClassManager.get(entitySchemaClassName);
			if (!entitySchema) {
				throw new Terrasoft.ItemNotFoundException({
					message: Ext.String.format(resources.localizableStrings.EntitySchemaNotFountExceptionMessage,
						entitySchemaClassName)
				});
			}
			classConfig.entitySchema = entitySchema;
		},

		/**
		 * Выполняет пользовательский код на структуре схемы и тем самым модифицирует структуру схемы
		 * @protected
		 * @virtual
		 * @param {Object} config Конфигурационный объект схемы модели представления
		 * @param {Function} userCode Функция пользовательского кода
		 */
		applyUserCode: function(config, userCode) {
			if (!userCode || !Ext.isFunction(userCode.viewModel)) {
				return;
			}
			userCode.viewModel(config);
		},

		/**
		 * Применяет колонки схемы сущности к колонкам схемы генерируемого класса
		 * @protected
		 * @virtual
		 * @param {Object} columnsConfig Конфигурационный объект колонок схемы конфигурируемого класса
		 * @param {Object} entitySchema Схема сущности
		 */
		applyEntitySchemaColumns: function(columnsConfig, entitySchema) {
			if (Ext.isEmpty(entitySchema)) {
				return;
			}
			Terrasoft.each(entitySchema.columns, function(column, columnName) {
				column.columnPath = columnName;
			}, this);
			this.applyColumns(columnsConfig, entitySchema.columns);
		},

		/**
		 * Применяет атрибуты схемы к колонкам схемы генерируемого класса
		 * @protected
		 * @virtual
		 * @param {Object} columnsConfig Конфигурационный объект колонок схемы конфигурируемого класса
		 * @param {Object} attributes Атрибуты схемы
		 */
		applySchemaAttributes: function(columnsConfig, attributes) {
			Terrasoft.each(attributes, function(attribute, attributeName) {
				this.applyColumn(columnsConfig, attribute, attributeName);
			}, this);
		},

		/**
		 * Применяет колонки родительского класса к колонкам схемы генерируемого класса
		 * @protected
		 * @virtual
		 * @param {Object} columnsConfig Конфигурационный объект колонок схемы конфигурируемого класса
		 * @param {Object} parentColumns Конфигурационный объект колонок схемы родительского класса
		 */
		applyParentColumns: function(columnsConfig, parentColumns) {
			this.applyColumns(columnsConfig, parentColumns);
		},

		/**
		 * Применяет переданные колонки к колонкам генерируемого класса
		 * @private
		 * @param {Object} columnsConfig Конфигурационный объект колонок схемы конфигурируемого класса
		 * @param {Object} columns Колонки
		 */
		applyColumns: function(columnsConfig, columns) {
			Terrasoft.each(columns, function(column, columnName) {
				this.applyColumn(columnsConfig, column, columnName);
			}, this);
		},

		/**
		 * Применяет свойства переданной колонки к колонке генерируемого класса
		 * @param {Object} columnsConfig Конфигурационный конфиг колонок
		 * @param {Object} column Колонка
		 * @param {String} columnName Название колонки
		 */
		applyColumn: function(columnsConfig, column, columnName) {
			column.name = columnName;
			var parentColumn = columnsConfig[columnName];
			var columnValue = column.value;
			delete column.value;
			if (parentColumn) {
				var parentDependencies = parentColumn.dependencies;
				var columnDependencies = column.dependencies;
				Ext.apply(parentColumn, column);
				if (parentDependencies && columnDependencies) {
					parentColumn.dependencies = parentDependencies.concat(columnDependencies);
				}
				column.value = columnValue;
				if (columnValue !== undefined) {
					parentColumn.value = columnValue;
				}
			} else {
				var columnConfig = Terrasoft.deepClone(column);
				column.value = columnValue;
				if (columnValue !== undefined) {
					columnConfig.value = columnValue;
				}
				this.applyColumnDefaults(columnConfig);
				columnsConfig[columnName] = columnConfig;
				if (column.dataValueType === Terrasoft.DataValueType.LOOKUP) {
					this.addLookupListColumn(columnsConfig, columnName);
				}
			}
		},

		/**
		 * Создает конфигурационный объект колонки на основании имени переданной справочной колонки и добавляет его
		 * к колонкам схемы генерируемого класса
		 * @private
		 * @param {Object} columnsConfig Конфигурационный объект колонок
		 * @param {String} name Название справочной колонки
		 */
		addLookupListColumn: function(columnsConfig, name) {
			var lookupColumnName = name + this.lookupColumnListSuffix;
			columnsConfig[lookupColumnName] = {
				name: lookupColumnName,
				dataValueType: Terrasoft.DataValueType.COLLECTION,
				type: Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
				value: new Terrasoft.Collection()
			};
		},

		/**
		 * Применяет свойства колонки по умолчанию
		 * @private
		 * @param {Object} column Колонка
		 */
		applyColumnDefaults: function(column) {
			if (Ext.isNumber(column.type)) {
				return;
			}
			column.type = Ext.isEmpty(column.columnPath)
				? Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN
				: Terrasoft.ViewModelColumnType.ENTITY_COLUMN;
		},

		/**
		 * Применяет переданные бизнес-правила к бизнес-правилам схемы генерируемого класса
		 * @protected
		 * @virtual
		 * @param {Object} rulesConfig Конфиграция бизнес-правил класса
		 * @param {Object} parentRules Родительские бизнес-правила
		 * @param {Object} rules Бизнес-правила
		 */
		applySchemaBusinessRules: function(rulesConfig, parentRules, rules) {
			Terrasoft.each(parentRules, function(columnRules, columnName) {
				this.applyColumnBusinessRules(rulesConfig, columnRules, columnName);
			}, this);
			Terrasoft.each(rules, function(columnRules, columnName) {
				this.applyColumnBusinessRules(rulesConfig, columnRules, columnName);
			}, this);
		},

		/**
		 * Применяет переданные элементы к бизнес-правилам указанной колонки
		 * @private
		 * @param {Object} rulesConfig Конфиграция бизнес-правил класса
		 * @param {Object} columnRules Бизнес-правила колонки
		 * @param {String} columnName Название колонки
		 */
		applyColumnBusinessRules: function(rulesConfig, columnRules, columnName) {
			var columnRulesConfig = rulesConfig[columnName];
			if (columnRulesConfig) {
				Terrasoft.each(columnRules, function(columnRule, columnRuleName) {
					this.applyColumnBusinessRule(columnRulesConfig, columnRule, columnRuleName);
				}, this);
			} else {
				rulesConfig[columnName] = Terrasoft.deepClone(columnRules);
			}
		},

		/**
		 * Применяет переданный элемент к элементу бизнес-правила колонки
		 * @private
		 * @param {Object} columnRulesConfig Существующие бизнес-правила колонки
		 * @param {Object} columnRule Элемент для применения
		 * @param {String} columnRuleName Названия элемента для применения
		 */
		applyColumnBusinessRule: function(columnRulesConfig, columnRule, columnRuleName) {
			var columnRuleConfig = columnRulesConfig[columnRuleName];
			if (columnRuleConfig) {
				Ext.apply(columnRuleConfig, columnRule);
			} else {
				columnRulesConfig[columnRuleName] = Terrasoft.deepClone(columnRule);
			}
		},

		/**
		 * Применяет переданные детали к деталям схемы генерируемого класса
		 * @protected
		 * @virtual
		 * @param {Object} detailsConfig Конфигурационный объект деталей генерируемого класса
		 * @param {Object} parentDetails Конфигурационный объект деталей родительского класса
		 * @param {Object} details Детали
		 */
		applySchemaDetails: function(detailsConfig, parentDetails, details) {
			Terrasoft.each(parentDetails, function(detail, detailName) {
				this.applyDetail(detailsConfig, detail, detailName);
			}, this);
			Terrasoft.each(details, function(detail, detailName) {
				this.applyDetail(detailsConfig, detail, detailName);
			}, this);
		},

		/**
		 * Применяет свойства переданной детали к детали схемы генерируемого класса
		 * @param {Object} detailsConfig Конфигурационный объект деталей генерируемого класса
		 * @param {Object} detail Деталь
		 * @param {String} detailName Название детали
		 */
		applyDetail: function(detailsConfig, detail, detailName) {
			var parentDetail = detailsConfig[detailName];
			if (parentDetail) {
				Ext.apply(parentDetail, detail);
			} else {
				detailsConfig[detailName] = Terrasoft.deepClone(detail);
			}
		},

		/**
		 * Применяет переданные ресурсы к колонкам схемы генерируемого класса
		 * @protected
		 * @virtual
		 * @param {Object} columns Конфигурационный объект колонок схемы конфигурируемого класса
		 * @param {Object} resources Ресурсы
		 */
		applyResources: function(columns, resources) {
			Terrasoft.each(resources.localizableStrings, function(value, name) {
				this.applyResource(columns, name, value, this.resourceType.STRING);
			}, this);
			Terrasoft.each(resources.localizableImages, function(value, name) {
				this.applyResource(columns, name, value, this.resourceType.IMAGE);
			}, this);
		},

		/**
		 * Создает конфигурационный объект колонки на основании свойств переданного ресурса и добавляет его
		 * к колонкам схемы генерируемого класса
		 * @private
		 * @param {Object} columnsConfig Конфигурационный объект колонок
		 * @param {String} name Название ресурса
		 * @param {Object} value Значение ресурса
		 * @param {String} type Тип ресурса
		 */
		applyResource: function(columnsConfig, name, value, type) {
			var resourceColumn = {
				name: this.resourcesSuffix + "." + type + "." + name,
				dataValueType: (type === this.resourceType.STRING) ? Terrasoft.DataValueType.TEXT :
					Terrasoft.DataValueType.IMAGE,
				type: Terrasoft.ViewModelColumnType.RESOURCE_COLUMN,
				value: value
			};
			this.applyColumnDefaults(resourceColumn);
			columnsConfig[resourceColumn.name] = resourceColumn;
		},

		/**
		* Применяет конфигурационные объекты колонкок на основании свойств переданной конфигурации представления
		 * @protected
		 * @virtual
		* @param {Object[]} columnsConfig Конфигурационный объект колонок схемы конфигурируемого класса
		* @param {Object} config Конфигурация представления
		*/
		addViewColumns: function(columnsConfig, config) {
			Terrasoft.iterateChildItems(config, function(iterationConfig) {
				this.addViewItemColumns(columnsConfig, iterationConfig.item);
			}, this);
		},

		/**
		 * Применяет конфигурационные объекты колонкок на основании описания элемента представления
		 * @private
		 * @virtual
		 * @param {Object[]} columnsConfig Конфигурационный объект колонок схемы конфигурируемого класса
		 * @param {Object} config Конфигурация элемента представления
		 */
		addViewItemColumns: function(columnsConfig, config) {
			if ((config.itemType === Terrasoft.ViewItemType.TAB_PANEL) ||
					(config.itemType === Terrasoft.ViewItemType.IMAGE_TAB_PANEL)) {
				this.applyTabPanelColumns(columnsConfig, config);
			}
		},

		/**
		 * Расширяет колонки схемы виртуальными колонками, необходимыми для работы вкладок
		 * @protected
		 * @virtual
		 * @param {Object[]} columnsConfig Массив колонок схемы
		 * @param {Object} config Конфигурация вкладок
		 */
		applyTabPanelColumns: function(columnsConfig, config) {
			var tabsValues = [];
			Terrasoft.each(config.tabs, function(item) {
				var itemName = item.name;
				columnsConfig[itemName] = {
					dataValueType: Terrasoft.DataValueType.BOOLEAN,
					type: Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
					value: false
				};
				var caption = this.getTabCaption(columnsConfig, item);
				tabsValues.push({
					Caption: caption,
					Name: itemName
				});
			}, this);
			var tabsCollection = Ext.create("Terrasoft.BaseViewModelCollection", {
				entitySchema: Ext.create("Terrasoft.BaseEntitySchema", {
					columns: {},
					primaryColumnName: "Name"
				})
			});
			tabsCollection.loadFromColumnValues(tabsValues);
			var tabCollectionName = this.getTabsCollectionName(config);
			columnsConfig[tabCollectionName] = {
				dataValueType: Terrasoft.DataValueType.COLLECTION,
				type: Terrasoft.ViewModelColumnType.VIRTUAL_COLUMN,
				value: tabsCollection
			};
		},

		/**
		 * Возвращает значение заголовка для вкладки
		 * @protected
		 * @virtual
		 * @param {Object[]} columnsConfig Конфигурационный объект колонок схемы конфигурируемого класса
		 * @param {Object} config Конфигурация элемента представления схемы
		 * @return {String} Возвращает тестровое значение заголовка для вкладки
		 */
		getTabCaption: function(columnsConfig, config) {
			var caption = config.caption;
			if (caption && caption.bindTo) {
				if (columnsConfig[caption.bindTo]) {
					return columnsConfig[caption.bindTo].value;
				}
			} else {
				return caption;
			}
		},

		/**
		 * Получает все схемы по иерархии и генерирует классы ViewModel
		 * @overridden
		 * @param {Object} config
		 * @param {Function} callback Функция обратного вызова
		 * @param {Object} scope Контекст выполнения функции обратного вызова
		 */
		generate: function(config, callback, scope) {
			var hierarchy = config.hierarchy;
			this.useCache = Ext.isEmpty(config.useCache) ? this.useCache : config.useCache;
			this.callParent([config, function() {
				var viewModelClass = this.generateSchemaClass(hierarchy);
				callback.call(scope, viewModelClass);
			}], this);
		}
	});

	return Ext.create(viewModelGenerator);

});


				// Autogenerated Code for schema ViewModelGeneratorV2 (End)
// Autogenerated Code for schema ModuleUtils (Start)
define('ModuleUtilsResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("ModuleUtils", ["ext-base", "terrasoft", "ModuleUtilsResources"],
	function(Ext, Terrasoft) {
		var getModuleTag = function(module) {
			var tag = "";
			switch (module) {
				case "Process":
					tag = "ProcessExecute/";
					break;
				default:
					var moduleStructure = getModuleStructureByName(module);
					if (moduleStructure.sectionModule) {
						tag = moduleStructure.sectionModule + "/";
					}
					if (moduleStructure.sectionSchema) {
						tag += moduleStructure.sectionSchema + "/";
					}
					break;
			}
			return tag;
		};

		function getEntityStructureByName(name) {
			var entityStructure = Terrasoft.configuration.EntityStructure || {};
			return entityStructure[name];
		}

		function getModuleStructureByName(name) {
			var moduleStructure = Terrasoft.configuration.ModuleStructure || {};
			return moduleStructure[name];
		}

		return {
			getModuleTag: getModuleTag,

			/**
			 * Возвращает структуру раздела.
			 * @param {String} moduleName Название объекта.
			 * @return {Object} Структура раздела.
			 */
			getModuleStructureByName: getModuleStructureByName,

			/**
			 * Возвращает информации о схеме объекта данных для сущности.
			 * @param {String} entitySchemaName Название схемы объекта.
			 * @return {Object} Информация о схеме объета данных.
			 */
			getEntityStructureByName: getEntityStructureByName
		};
	});

				// Autogenerated Code for schema ModuleUtils (End)
// Autogenerated Code for schema LinkColumnHelper (Start)
define('LinkColumnHelperResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("LinkColumnHelper", [], function() {

		/**
		 * Проверяет является ли колонка ссылкой.
		 * @param {String} entitySchemaName Имя схемы.
		 * @param {String} columnName Имя колонки.
		 * @returns {boolean} Признак, является ли колонка ссылкой.
		 */
		var getIsLinkColumn = function(entitySchemaName, columnName) {
			for (var linkColumnUtility in Terrasoft.LinkColumnUtilities) {
				var columnUtility = Terrasoft.LinkColumnUtilities[linkColumnUtility];
				if (!Ext.isObject(columnUtility)) {
					continue;
				}
				if (!Ext.isFunction(columnUtility.getIsLinkColumn)) {
					continue;
				}
				if (columnUtility.getIsLinkColumn.call(columnUtility, entitySchemaName, columnName)) {
					return true;
				}
			}
			return false;
		};

		/**
		 * Создает URL ссылку.
		 * @param {String} entitySchemaName Имя схемы.
		 * @param {String} columnPath Имя колонки.
		 * @param {String} displayValue Отображаемое значение колонки.
		 * @param {String} recordId Id записи.
		 * @returns {Object} URL ссылку.
		 */
		var createLink = function(entitySchemaName, columnPath, displayValue, recordId) {
			for (var linkColumnUtility in Terrasoft.LinkColumnUtilities) {
				var columnUtility = Terrasoft.LinkColumnUtilities[linkColumnUtility];
				if (!Ext.isObject(columnUtility)) {
					continue;
				}
				if ((!Ext.isFunction(columnUtility.getIsLinkColumn)) || (!Ext.isFunction(columnUtility.createLink))) {
					continue;
				}
				if (!columnUtility.getIsLinkColumn.call(columnUtility, entitySchemaName, columnPath)) {
					continue;
				}
				return columnUtility.createLink.call(columnUtility, entitySchemaName,
					columnPath, displayValue, recordId);
			}
			return null;
		};

		return {
			getIsLinkColumn: getIsLinkColumn,
			createLink: createLink
		};
	}
);

				// Autogenerated Code for schema LinkColumnHelper (End)
// Autogenerated Code for schema BusinessRuleModule (Start)
define('BusinessRuleModuleResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("BusinessRuleModule", ['ext-base', 'terrasoft', "BusinessRuleModuleResources"],
	function(Ext, Terrasoft, resources) {
		var enums = {
			Property: {
				VISIBLE: 0,
				ENABLED: 1,
				REQUIRED: 2,
				READONLY: 3
			},
			RuleType: {
				DISABLED: -1,
				BINDPARAMETER: 0,
				FILTRATION: 1,
				AUTOCOMPLETE: 2
			},
			AutocompleteType: {
				ASIS: 0,
				VALUE: 1,
				DISPLAYVALUE: 2
			},
			ValueType: {
				CONSTANT: 0,
				ATTRIBUTE: 1,
				SYSSETTING: 2,
				SYSVALUE: 3,
				CARDSTATE: 4
			}
		};

		function getAttributeValueByPath(object, path) {
			var returnValue = object;
			Terrasoft.each(path.split('.'), function(valueName) {
				if (!Ext.isEmpty(returnValue)) {
					returnValue = returnValue[valueName];
				}
			}, this);
			return returnValue;
		}

		function getRuleValue(item, scope) {
			var returnValue;
			if (Ext.isEmpty(item)) {
				return null;
			}
			switch (item.type) {
				case enums.ValueType.CONSTANT:
					returnValue = item.value;
					break;
				case enums.ValueType.SYSSETTING:
					returnValue = Terrasoft.SysSettings.cachedSettings[item.value];
					break;
				case enums.ValueType.ATTRIBUTE:
					var itemAttribute = item.attribute;
					var itemAttributePath = item.attributePath;
					if (!Ext.isEmpty(itemAttribute)) {
						returnValue = scope.get(itemAttribute);
						var dataValueType = scope.getColumnDataType(itemAttribute);
						if (!Ext.isEmpty(returnValue) && dataValueType === Terrasoft.DataValueType.LOOKUP) {
							if (Ext.isEmpty(itemAttributePath)) {
								returnValue = returnValue.value;
							} else {
								returnValue = getAttributeValueByPath(returnValue, itemAttributePath);
							}
						}
					}
					break;
				case enums.ValueType.SYSVALUE:
					returnValue = scope.getSysDefaultValue(item.value);
					break;
				case enums.ValueType.CARDSTATE:
					returnValue = scope.action;
					break;
			}
			if (returnValue && returnValue.value) {
				return returnValue.value;
			}
			return returnValue;
		}

		function getModuleName(item) {
			var methodName;
			switch (item.type) {
				case enums.ValueType.CONSTANT:
					methodName = item.type;
					break;
				case enums.ValueType.SYSVALUE:
				case enums.ValueType.SYSSETTING:
					methodName = item.value;
					break;
				case enums.ValueType.ATTRIBUTE:
					methodName = item.attribute;
					var itemAttributePath = item.attributePath;
					if (!Ext.isEmpty(itemAttributePath)) {
						methodName += itemAttributePath;
					}
					break;
			}
			return methodName;
		}

		function comparisonRule(left, type, right) {
			var conditionResult = true;
			switch (type) {
				case Terrasoft.ComparisonType.IS_NULL:
					conditionResult = Ext.isEmpty(left);
					break;
				case Terrasoft.ComparisonType.IS_NOT_NULL:
					conditionResult = !Ext.isEmpty(left);
					break;
				case Terrasoft.ComparisonType.EQUAL:
					conditionResult = (left === right);
					break;
				case Terrasoft.ComparisonType.NOT_EQUAL:
					conditionResult = (left !== right);
					break;
				case Terrasoft.ComparisonType.GREATER:
					conditionResult = (left > right);
					break;
				case Terrasoft.ComparisonType.LESS:
					conditionResult = (left < right);
					break;
			}
			return conditionResult;
		}

		function prepareViewRule(view, rules) {
			Terrasoft.each(rules, function(rule) {
				var ruleAttribute = rule.baseAttribute;
				var ruleProperty = rule.property;
				var propertyMap = {};
				propertyMap[enums.Property.VISIBLE] = 'visible';
				propertyMap[enums.Property.ENABLED] = 'enabled';
				propertyMap[enums.Property.REQUIRED] = 'isRequired';
				propertyMap[enums.Property.READONLY] = 'readonly';
				if (!Ext.isEmpty(rule.conditions) && !Ext.isEmpty(ruleProperty)) {
					var methodName = ruleAttribute + 'GetIsPropertyEnum' + ruleProperty;
					var bindingConfig = view.bindings[ruleAttribute] || {};
					var attributeProperty = propertyMap[ruleProperty];
					bindingConfig[attributeProperty] = {bindTo: methodName};
					view.bindings[ruleAttribute] = bindingConfig;
				}
			}, this);
		}

		function prepareViewModelRule(viewModel) {
			Terrasoft.each(viewModel.entitySchemaInfo.rules, function(rule) {
				var ruleBaseAttribute = rule.baseAttribute;
				var ruleAttribute = rule.attribute;
				var ruleProperty = rule.property;
				if (rule.ruleType === enums.RuleType.BINDPARAMETER && !Ext.isEmpty(rule.conditions) &&
					!Ext.isEmpty(ruleProperty)) {
					var methodName = ruleBaseAttribute + 'GetIsPropertyEnum' + ruleProperty;
					viewModel.methods[methodName] = function(args) {
						var rule = this[arguments.callee.$name].rule;
						var bReturn = (rule.logical === Terrasoft.LogicalOperatorType.AND);
						Terrasoft.each(rule.conditions, function(condition) {
							var leftValue = getRuleValue(condition.leftExpression, this);
							var rightValue = getRuleValue(condition.rightExpression, this);
							var conditionResult = comparisonRule(leftValue, condition.comparisonType, rightValue);
							if (rule.logical === Terrasoft.LogicalOperatorType.AND) {
								bReturn = bReturn && conditionResult;
							} else {
								bReturn = bReturn || conditionResult;
							}
						}, this);
						var column = this.columns[rule.baseAttribute];
						if (column && ruleProperty === enums.Property.REQUIRED) {
							var labelControl = Ext.get(rule.baseAttribute + 'ControlLabel');
							if (labelControl) {
								if (bReturn) {
									labelControl.addCls('required-caption');
								} else {
									labelControl.removeCls('required-caption');
								}
							}
							column.isRequired = bReturn;
						}
						return bReturn;
					};
					viewModel.methods[methodName].rule = rule;
				}

				if (rule.ruleType === enums.RuleType.AUTOCOMPLETE || rule.ruleType === enums.RuleType.FILTRATION) {
					var info = viewModel.entitySchemaInfo;
					if (rule.ruleType === enums.RuleType.AUTOCOMPLETE || rule.autocomplete) {
						var autoCompleteMethodName = 'BusinessRuleAutoComplete' + ruleBaseAttribute + ruleAttribute;
						var autoCompleteDependencies = [];
						if (rule.ruleType === enums.RuleType.AUTOCOMPLETE) {
							autoCompleteDependencies.push(rule.attribute);
						} else {
							autoCompleteDependencies.push(ruleBaseAttribute);
						}
						info.dependencies.push({
							dependencies: autoCompleteDependencies,
							methodName: autoCompleteMethodName,
							argument: rule
						});
						var modifyRule = Terrasoft.deepClone(rule);
						if (rule.ruleType === enums.RuleType.AUTOCOMPLETE) {
							modifyRule.attribute = rule.baseAttribute;
							modifyRule.baseAttribute = rule.attribute;
						}
						viewModel.methods[autoCompleteMethodName] = function() {
							var currentRule = this[arguments.callee.$name].rule;
							var argAttribute = currentRule.attribute;
							var solo = this.get(currentRule.baseAttribute);
							var dependent = this.get(argAttribute);
							var setValue = function(argAttribute, value) {
								if (this.get(argAttribute) !== value) {
									this.set(argAttribute, value);
								}
							};
							if (!Ext.isEmpty(solo)) {
								var soloDependent = (!Ext.isEmpty(currentRule.baseAttributePatch)) ?
									solo[currentRule.baseAttributePatch] : solo;
								if (!Ext.isEmpty(soloDependent)) {
									switch (currentRule.autocompleteType) {
										case enums.AutocompleteType.DISPLAYVALUE:
											if (!Ext.isEmpty(soloDependent.displayValue)) {
												setValue.call(this, argAttribute, soloDependent.displayValue);
											}
											break;
										case enums.AutocompleteType.VALUE:
											if (!Ext.isEmpty(soloDependent.value)) {
												setValue.call(this, argAttribute, soloDependent.value);
											}
											break;
										default:
											setValue.call(this, argAttribute, soloDependent);
											break;

									}
								}
							}
						};
						viewModel.methods[autoCompleteMethodName].methodName = autoCompleteMethodName;
						viewModel.methods[autoCompleteMethodName].rule = modifyRule;
					}

					if (rule.autoClean) {
						var autoCleanMethodName = 'BusinessRuleAutoClean' + ruleAttribute + ruleBaseAttribute;
						info.dependencies.push({
							dependencies: [ruleAttribute],
							methodName: autoCleanMethodName,
							argument: rule
						});
						viewModel.methods[autoCleanMethodName] = function(arg) {
							var currentRule = this[arguments.callee.$name].rule;
							var argAttribute = currentRule.attribute;
							var argBaseAttribute = currentRule.baseAttribute;
							var solo = this.get(argAttribute);
							var dependent = this.get(argBaseAttribute);
							if (!Ext.isEmpty(solo) && !Ext.isEmpty(dependent)) {
								var dependentSolo = dependent[currentRule.baseAttributePatch];
								if ((!Ext.isEmpty(dependentSolo) && (solo.value !== dependentSolo.value)) ||
									Ext.isEmpty(dependentSolo)) {
									this.set(argBaseAttribute, null);
								}
							}
						};
						viewModel.methods[autoCleanMethodName].methodName = autoCleanMethodName;
						viewModel.methods[autoCleanMethodName].rule = rule;
					}
					if (rule.ruleType === enums.RuleType.FILTRATION && !Ext.isEmpty(rule.comparisonType)) {
						if (!info.filters[ruleBaseAttribute]) {
							info.filters[ruleBaseAttribute] = [];
						}
						info.filters[ruleBaseAttribute].push({
							argument: rule,
							method: function(arg) {
								var filter;
								var value = getRuleValue(arg, this);
								if (!Ext.isEmpty(value)) {
									filter = Terrasoft.createColumnFilterWithParameter(arg.comparisonType,
										arg.baseAttributePatch, value);
								}
								return filter;
							}
						});
					}
				}
			}, this);
		}

		return {
			enums: enums,
			getRuleValue: getRuleValue,
			prepareViewRule: prepareViewRule,
			prepareViewModelRule: prepareViewModelRule
		};
	});


				// Autogenerated Code for schema BusinessRuleModule (End)
// Autogenerated Code for schema ConfigurationEnums (Start)
define('ConfigurationEnumsResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={
	MinutesCaption: 'минут',
	HoursCaption: 'часов'
};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("ConfigurationEnums", ["ConfigurationEnumsResources", "BusinessRuleModule"],
	function(resources, BusinessRuleModule) {
	var entitySchemaColumnUsageType = {
		General: 0,
		Advanced: 1,
		None: 2
	};
	var cardStateV2 = {
		ADD: "add",
		EDIT: "edit",
		COPY: "copy"
	};
	var cardState = {
		View: "view",
		Edit: "edit",
		Add: "add",
		Copy: "copy",
		Delete: "delete",
		Send: "send",
		Reply: "reply",
		ReplyAll: "replyAll",
		Forward: "forward",
		EditStructure: "editStructure",
		Report: "report"
	};
	var mapsModuleMode = {
		Points: "points",
		Route: "route",
		RouteGeolocation: "routeGeolocation"
	};
	var gridType = {
		LISTED: "listed",
		TILED: "tiled"
	};
	var gridSettingsType = {
		NORMAL: "normal",
		VERTICAL: "vertical",
		MOBILE: "mobile"
	};
	var customViewModelSchemaItem = {
		ITEMS_GROUP: "ITEMS-CONTAINER",
		RADIO_GROUP: "RADIO-CONTAINER",
		BUTTON: "BUTTON",
		CUSTOM_ELEMENT: "CUSTOM-ELEMENT"
	};
	var customViewModelRemindingsMessage = {
		ChangeCountUnreadEmails: "changeCountUnreadEmails",
		ChangeCountRemindings: "changeCountRemindings",
		ChangeCountInfoMessages: "changeCountInfoMessages"
	};
	var aggregationFunctionItem = {
		COUNT: "count",
		EXISTS: "exists"
	};
	var periodicityTimeInterval = {
		hours: {
			value: "F9B62808-FE60-421F-9584-AAFEC1E21C4D",
			displayValue: resources.localizableStrings.HoursCaption,
			index: 0
		},
		minutes: {
			value: "12FE1488-46B1-4DFC-B131-187857F385AE",
			displayValue: resources.localizableStrings.MinutesCaption,
			index: 1
		}
	};

	var workAreaMode = {
		SECTION: 0,
		CARD: 1,
		COMBINED: 2
	};

	return {
		GridType: gridType,
		GridSettingsType: gridSettingsType,
		CardState: cardState,
		CardStateV2: cardStateV2,
		CustomViewModelSchemaItem: customViewModelSchemaItem,
		RemindingsMessage: customViewModelRemindingsMessage,
		AggregationFunction: aggregationFunctionItem,
		PeriodicityTimeInterval: periodicityTimeInterval,
		EntitySchemaColumnUsageType: entitySchemaColumnUsageType,
		MapsModuleMode: mapsModuleMode,
		BusinessRule: BusinessRuleModule.enums,
		WorkAreaMode: workAreaMode
	};
});

				// Autogenerated Code for schema ConfigurationEnums (End)
// Autogenerated Code for schema BusinessRulesApplierV2 (Start)
define('BusinessRulesApplierV2Resources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={
	InvalidRuleFormatExceptionException: 'Неверный формат правила {0}'
};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("BusinessRulesApplierV2", ["ext-base", "terrasoft", "BusinessRuleModule", "BusinessRulesApplierV2Resources"],
	function(Ext, Terrasoft, BusinessRuleModule, resources) {
		/**
		 * @class Terrasoft.configuration.BusinessRulesApplier
		 * Класс, который применяет бизнес-правила к представлению и модели представления схемы
		 */
		var businessRulesApplier = Ext.define("Terrasoft.configuration.BusinessRulesApplier", {
			alternateClassName: "Terrasoft.BusinessRulesApplier",
			extend: "Terrasoft.BaseObject",

			/**
			 * Класс модели представления схемы
			 * @private
			 * @type {Object}
			 */
			viewModelClass: null,

			/**
			 * Конфигурационный массив представления схемы
			 * @private
			 * @type {Object[]}
			 */
			viewConfig: null,

			/**
			 * Название свойства видимости
			 * @private
			 * @type {String}
			 */
			visiblePropertyName: "visible",

			/**
			 * Название свойства доступности
			 * @private
			 * @type {String}
			 */
			enabledPropertyName: "enabled",

			/**
			 * Название свойства обязательности заполнения
			 * @private
			 * @type {String}
			 */
			isRequiredPropertyName: "isRequired",

			/**
			 * Название свойства доступности в режиме чтения
			 * @private
			 * @type {String}
			 */
			readonlyPropertyName: "readonly",

			/**
			 * Суффикс подписи элемента управления
			 * @private
			 * @type {String}
			 */
			labelSuffix: "Label",

			/**
			 * Названия стиля подписи обязательного для заполнения элемента управления
			 * @private
			 * @type {String}
			 */
			requiredStyleName: "required-caption",

			/**
			 * Префикс метода представления модели
			 * @private
			 * @type {String}
			 */
			viewModelMethodPrefix: "Is",

			/**
			 * Префикс метода автоматической подстановки значения в поле
			 * @private
			 * @type {String}
			 */
			autoCompleteMethodPrefix: "AutoComplete",

			/**
			 * Префикс метода автоматичской очистки поля
			 * @private
			 * @type {String}
			 */
			autoCleanMethodPrefix: "AutoClean",

			/**
			 * Разделитель полного пути колонки
			 * @private
			 * @type {String}
			 */
			metaPathSeparator: ".",

			/**
			 * Суффикс названия фильтра
			 * @private
			 * @type {String}
			 */
			filterSuffix: "Filter",

			/**
			 * Применяет бизнес-правила к схеме.
			 * @param {Object} viewModelClass Класс модели представления схемы.
			 * @param {Object[]} viewConfig Конфигурационный массив представления схемы.
			 */
			applyRules: function(viewModelClass, viewConfig) {
				this.viewModelClass = viewModelClass;
				this.viewConfig = viewConfig;
				Terrasoft.each(viewModelClass.prototype.rules, function(columnRules, columnName) {
					this.applyColumnRules(columnRules, columnName);
				}, this);
			},

			/**
			 * Применяет бизнес-правила к колонке схемы.
			 * @protected
			 * @param {Object} columnRules Бизнес-правила колонки.
			 * @param {String} columnName Название колонки.
			 */
			applyColumnRules: function(columnRules, columnName) {
				Terrasoft.each(columnRules, function(rule, ruleName) {
					rule.columnName = columnName;
					this.applyRule(rule, ruleName);
				}, this);
			},

			/**
			 * Применяет бизнес-правило к колонке схемы.
			 * @protected
			 * @param {Object} rule Бизнес-правило.
			 * @param {String} ruleName Название бизнес-правила.
			 */
			applyRule: function(rule, ruleName) {
				var ruleType = rule.ruleType;
				if (Ext.isEmpty(ruleType) || Ext.isEmpty(ruleName)) {
					throw new Terrasoft.InvalidFormatException({
						message: Ext.String.format(resources.localizableStrings.InvalidRuleFormatExceptionException,
							ruleName)
					});
				}
				switch (ruleType) {
					case BusinessRuleModule.enums.RuleType.BINDPARAMETER:
						this.applyBindParameterRule(rule, ruleName);
						break;
					case BusinessRuleModule.enums.RuleType.FILTRATION:
						this.applyFiltrationRule(rule, ruleName);
						break;
					case BusinessRuleModule.enums.RuleType.AUTOCOMPLETE:
						this.applyAutoCompleteRule(rule, ruleName);
						break;
					case BusinessRuleModule.enums.RuleType.DISABLED:
						break;
					default:
						break;
				}
			},

			/**
			 * Применяет бизнес-правило по фильтрации значений в справочнике.
			 * @protected
			 * @param {Object} rule Бизнес-правило.
			 * @param {String} ruleName Название бизнес-правила.
			 */
			applyFiltrationRule: function(rule, ruleName) {
				if (Ext.isEmpty(rule.comparisonType)) {
					throw new Terrasoft.InvalidFormatException({
						message: Ext.String.format(resources.localizableStrings.InvalidRuleFormatExceptionException,
							ruleName)
					});
				}
				if (rule.autocomplete) {
					this.applyAutoCompleteRule(rule, ruleName);
				}
				var columnName = rule.columnName;
				var viewModel = this.viewModelClass.prototype;
				var columns = viewModel.columns;
				var column = columns[columnName];
				if (!column.lookupListConfig) {
					column.lookupListConfig = {};
				}
				var lookupListConfig = column.lookupListConfig;
				if (!lookupListConfig.filters) {
					lookupListConfig.filters = [];
				}
				var filters = lookupListConfig.filters;
				var scope = this;
				filters.push({
					argument: rule,
					method: function(arg) {
						var filtersCollection = Terrasoft.createFilterGroup();
						var value = scope.getRuleValue(arg, this);
						if (!Ext.isEmpty(value)) {
							filtersCollection.add(arg.baseAttributePatch + scope.filterSuffix,
								Terrasoft.createColumnFilterWithParameter(arg.comparisonType, arg.baseAttributePatch,
									value));
						}
						return filtersCollection;
					}
				});
			},

			/**
			 * Применяет бизнес-правило по автоподстановке значений в поле.
			 * @protected
			 * @param {Object} rule Бизнес-правило.
			 * @param {String} ruleName Название бизнес-правила.
			 */
			applyAutoCompleteRule: function(rule, ruleName) {
				if (!ruleName) {
					return;
				}
				var viewModel = this.viewModelClass.prototype;
				var columnName = rule.columnName;
				var ruleAttribute = rule.attribute;
				var baseAttributePatch = rule.baseAttributePatch;
				var autoCompleteMethodName = this.autoCompleteMethodPrefix + columnName + ruleAttribute;
				var autoCompleteDependencies = [];
				if (rule.ruleType === BusinessRuleModule.enums.RuleType.AUTOCOMPLETE) {
					autoCompleteDependencies.push(rule.attribute);
				} else {
					autoCompleteDependencies.push(columnName);
				}
				var columns = viewModel.columns;
				var column = columns[columnName];
				if (!column.lookupListConfig) {
					column.lookupListConfig = {};
				}
				var lookupListConfig = column.lookupListConfig;
				if (!lookupListConfig.columns) {
					lookupListConfig.columns = [];
				}
				var lookupColumns = lookupListConfig.columns;
				if (lookupColumns.indexOf(baseAttributePatch) < 0) {
					lookupColumns.push(baseAttributePatch);
				}
				var modifyRule = Terrasoft.deepClone(rule);
				if (rule.ruleType === BusinessRuleModule.enums.RuleType.AUTOCOMPLETE) {
					modifyRule.attribute = rule.columnName;
					modifyRule.columnName = rule.attribute;
					rule = modifyRule;
				}
				if (!column.dependencies) {
					column.dependencies = [];
				}
				var dependencies = column.dependencies;
				var dependency = {
					columns: [columnName],
					methodName: autoCompleteMethodName,
					argument: rule
				};
				if (dependencies.indexOf(dependency) < 0) {
					dependencies.push(dependency);
				}
				viewModel[autoCompleteMethodName] = function(currentRule) {
					var argAttribute = currentRule.attribute;
					var lookupValue = this.get(currentRule.columnName);
					var setValue = function(argAttribute, value) {
						if (this.get(argAttribute) !== value) {
							this.set(argAttribute, value);
						}
					};
					if (!Ext.isEmpty(lookupValue)) {
						var dependentValue = (!Ext.isEmpty(currentRule.baseAttributePatch)) ?
							lookupValue[currentRule.baseAttributePatch] : lookupValue;
						if (!Ext.isEmpty(dependentValue)) {
							switch (currentRule.autocompleteType) {
								case BusinessRuleModule.enums.AutocompleteType.DISPLAYVALUE:
									if (!Ext.isEmpty(dependentValue.displayValue)) {
										setValue.call(this, argAttribute, dependentValue.displayValue);
									}
									break;
								case BusinessRuleModule.enums.AutocompleteType.VALUE:
									if (!Ext.isEmpty(dependentValue.value)) {
										setValue.call(this, argAttribute, dependentValue.value);
									}
									break;
								default:
									setValue.call(this, argAttribute, dependentValue);
									break;
							}
						}
					}
				};
				if (rule.autoClean) {
					this.applyAutoCleanRule(rule);
				}
			},

			/**
			 * Применяет бизнес-правило по автоматической очистке значений в поле.
			 * @protected
			 * @param {Object} rule Бизнес-правило.
			 */
			applyAutoCleanRule: function(rule) {
				var columnName = rule.columnName;
				var ruleAttribute = rule.attribute;
				var autoCleanMethodName = this.autoCleanMethodPrefix + columnName + ruleAttribute;
				var viewModel = this.viewModelClass.prototype;
				var columns = viewModel.columns;
				var column = columns[columnName];
				var dependencies = column.dependencies = column.dependencies || [];
				var dependency = {
					columns: [ruleAttribute],
					methodName: autoCleanMethodName,
					argument: rule
				};
				if (dependencies.indexOf(dependency) === -1) {
					dependencies.push(dependency);
				}
				viewModel[autoCleanMethodName] = function() {
					var base = this.get(ruleAttribute);
					var dependent = this.get(columnName);
					if (!Ext.isEmpty(base) && !Ext.isEmpty(dependent)) {
						var dependentValue = dependent[rule.baseAttributePatch];
						var dependentValueIsEmpty = Ext.isEmpty(dependentValue);
						if ((!dependentValueIsEmpty && (base.value !== dependentValue.value)) ||
								(dependentValueIsEmpty && !this.isCopyMode())) {
							this.set(columnName, null);
						}
					}
				};
			},

			/**
			 * Применяет зависимости к модели представления.
			 * @param {Object} viewModel Модель представления.
			 */
			applyDependencies: function(viewModel) {
				var columns = viewModel.columns;
				Terrasoft.each(columns, function(column, columnName) {
					if (!Ext.isEmpty(column.multiLookupColumns)) {
						column.dependencies = column.dependencies || [];
						column.dependencies.push({
							columns: [columnName],
							methodName: "onSetMultiLookup"
						});
					}
					if (column.dependencies) {
						var dependencies = column.dependencies;
						Terrasoft.each(dependencies, function(dependency) {
							var dependentColumns = dependency.columns;
							Terrasoft.each(dependentColumns, function(dependentColumn) {
								viewModel.on("change:" + dependentColumn, function() {
									if (this.get("IsEntityInitialized") === false) {
										return;
									}
									this[dependency.methodName](dependency.argument, dependentColumn);
								}, viewModel);
							}, this);
						}, this);
					}
				}, this);
			},

			/**
			 * Применяет бизнес-правило по привязке свойств представления.
			 * @protected
			 * @param {Object} rule Бизнес-правило.
			 * @param {String} ruleName Название бизнес-правила.
			 */
			applyBindParameterRule: function(rule, ruleName) {
				if (Ext.isEmpty(rule.conditions) || Ext.isEmpty(rule.property)) {
					throw new Terrasoft.InvalidFormatException({
						message: Ext.String.format(resources.localizableStrings.InvalidRuleFormatExceptionException,
							ruleName)
					});
				}
				this.applyViewBindParameter(rule, this.viewConfig);
				this.applyViewModelBindParameter(rule);
			},

			/**
			 * Привязывает свойства представления к методам модели представления.
			 * @protected
			 * @param {Object} rule Бизнес-правило.
			 * @param {Array} viewConfig Конфигурационный массив представления схемы.
			 */
			applyViewBindParameter: function(rule, viewConfig) {
				Terrasoft.each(viewConfig, function(viewItem) {
					var viewItems = viewItem.items ? viewItem.items : viewItem.tabs;
					if (viewItems && Ext.isArray(viewItems)) {
						this.applyViewBindParameter(rule, viewItems);
					} else {
						var ruleColumnName = rule.columnName;
						var viewItemColumnName = viewItem.bindTo ? viewItem.bindTo : viewItem.name;
						var viewRuleConfig = viewItem.ruleConfig;
						var ruleConfig = viewRuleConfig ? viewRuleConfig[rule.columnName] : null;
						if ((ruleColumnName !== viewItemColumnName) && (!ruleConfig)) {
							return;
						}
						var propertyName;
						var methodName;
						if (ruleColumnName === viewItemColumnName) {
							propertyName = this.getBindPropertyName(rule.property);
						} else {
							propertyName = ruleConfig.propertyName;
						}
						methodName = this.getMethodName(rule.property, ruleColumnName);
						var controlConfig = viewItem.controlConfig;
						if (!controlConfig) {
							controlConfig = {};
							viewItem.controlConfig = controlConfig;
						}
						controlConfig[propertyName] = {
							bindTo: methodName
						};
						if (rule.property === BusinessRuleModule.enums.Property.VISIBLE ||
							rule.property === BusinessRuleModule.enums.Property.REQUIRED) {
							var labelConfig = viewItem.labelConfig;
							if (!labelConfig) {
								labelConfig = {};
								viewItem.labelConfig = controlConfig;
							}
							labelConfig[propertyName] = {
								bindTo: methodName
							};
						}
					}
				}, this);
			},

			/**
			 * Определяет результат сравнения бизнес-правила.
			 * @protected
			 * @param {Number} property Код свойства бизнес-правила.
			 * @return {String} Возвращает название свойства бизнес-правила.
			 */
			getBindPropertyName: function(property) {
				var propertyName = this.visiblePropertyName;
				switch (property) {
					case BusinessRuleModule.enums.Property.VISIBLE:
						propertyName = this.visiblePropertyName;
						break;
					case BusinessRuleModule.enums.Property.ENABLED:
						propertyName = this.enabledPropertyName;
						break;
					case BusinessRuleModule.enums.Property.REQUIRED:
						propertyName = this.isRequiredPropertyName;
						break;
					case BusinessRuleModule.enums.Property.READONLY:
						propertyName = this.readonlyPropertyName;
						break;
					default:
						break;
				}
				return propertyName;
			},

			/**
			 * Определяет название метода по применению бизнес-правила.
			 * @protected
			 * @param {Number} property Код свойства бизнес-правила.
			 * @param {Object} columnName Название колонки.
			 * @return {String} Возвращает название метода.
			 */
			getMethodName: function(property, columnName) {
				var rulePropertyName = this.getBindPropertyName(property);
				return this.viewModelMethodPrefix + columnName + rulePropertyName;
			},

			/**
			 * Создает методы модели представления, к которым будут привязываться свойства представления.
			 * @protected
			 * @param {Object} rule Бизнес-правило.
			 */
			applyViewModelBindParameter: function(rule) {
				var viewModel = this.viewModelClass.prototype;
				var scope = this;
				var columnName = rule.columnName;
				var columns = viewModel.columns;
				Terrasoft.each(rule.conditions, function(condition) {
					var leftExpression = condition.leftExpression;
					if (leftExpression && leftExpression.attribute && leftExpression.attributePath) {
						var conditionColumn = columns[leftExpression.attribute];
						if (!conditionColumn.lookupListConfig) {
							conditionColumn.lookupListConfig = {};
						}
						var lookupListConfig = conditionColumn.lookupListConfig;
						if (!lookupListConfig.columns) {
							lookupListConfig.columns = [];
						}
						var lookupColumns = lookupListConfig.columns;
						if (lookupColumns.indexOf(leftExpression.attributePath) < 0) {
							lookupColumns.push(leftExpression.attributePath);
						}
					}
				}, this);
				var methodName = this.getMethodName(rule.property, columnName);
				viewModel[methodName] = function() {
					var result = (rule.logical === Terrasoft.LogicalOperatorType.AND);
					Terrasoft.each(rule.conditions, function(condition) {
						var leftValue = scope.getRuleValue(condition.leftExpression, this);
						var rightValue = scope.getRuleValue(condition.rightExpression, this);
						var conditionResult = scope.getConditionResult(leftValue, condition.comparisonType, rightValue);
						if (rule.logical === Terrasoft.LogicalOperatorType.AND) {
							result = result && conditionResult;
						} else {
							result = result || conditionResult;
						}
						var column = this.columns[rule.columnName];
						if (column && rule.property === BusinessRuleModule.enums.Property.REQUIRED) {
							column.isRequired = result;
						}
					}, this);
					return result;
				};
			},

			/**
			 * Определяет вычисленное заначение бизнес-правила.
			 * @protected
			 * @param {Object} item Выражение бизнес-правила.
			 * @param {Object} scope Контекст выполнения функции получения значения.
			 * @return {Object} Вычисленное заначение бизнес-правила.
			 */
			getRuleValue: function(item, scope) {
				var returnValue;
				if (Ext.isEmpty(item)) {
					return null;
				}
				switch (item.type) {
					case BusinessRuleModule.enums.ValueType.CONSTANT:
						returnValue = item.value;
						break;
					case BusinessRuleModule.enums.ValueType.SYSSETTING:
						returnValue = Terrasoft.SysSettings.cachedSettings[item.value];
						break;
					case BusinessRuleModule.enums.ValueType.ATTRIBUTE:
						var itemAttribute = item.attribute;
						var itemAttributePath = item.attributePath;
						if (!Ext.isEmpty(itemAttribute)) {
							returnValue = scope.get(itemAttribute);
							var dataValueType = scope.getColumnDataType(itemAttribute);
							if (!Ext.isEmpty(returnValue) && dataValueType === Terrasoft.DataValueType.LOOKUP) {
								if (Ext.isEmpty(itemAttributePath)) {
									returnValue = returnValue.value;
								} else {
									returnValue = this.getAttributeValueByPath(returnValue, itemAttributePath);
								}
							}
						}
						break;
					case BusinessRuleModule.enums.ValueType.SYSVALUE:
						returnValue = scope.getSysDefaultValue(item.value);
						break;
					case BusinessRuleModule.enums.ValueType.CARDSTATE:
						returnValue = scope.action;
						break;
					default:
						break;
				}
				if (returnValue && returnValue.value) {
					return returnValue.value;
				}
				return returnValue;
			},

			/**
			 * Определяет результат сравнения бизнес-правила.
			 * @protected
			 * @param {Object} left Путь колонок правой части.
			 * @param {Object} type Тип сравнения.
			 * @param {Object} right Сравниваемое значение правой части.
			 * @return {Boolean} Возвращает результат сравнения бизнес-правила.
			 */
			getConditionResult: function(left, type, right) {
				var conditionResult = true;
				switch (type) {
					case Terrasoft.ComparisonType.IS_NULL:
						conditionResult = Ext.isEmpty(left);
						break;
					case Terrasoft.ComparisonType.IS_NOT_NULL:
						conditionResult = !Ext.isEmpty(left);
						break;
					case Terrasoft.ComparisonType.EQUAL:
						conditionResult = (left === right || (Ext.isEmpty(left) && Ext.isEmpty(right)));
						break;
					case Terrasoft.ComparisonType.NOT_EQUAL:
						conditionResult = (left !== right);
						break;
					case Terrasoft.ComparisonType.GREATER:
						conditionResult = (left > right);
						break;
					case Terrasoft.ComparisonType.LESS:
						conditionResult = (left < right);
						break;
					default:
						break;
				}
				return conditionResult;
			},

			/**
			 * Определяет результат сравнения бизнес-правила.
			 * @protected
			 * @param {Object} left Путь колонок правой части.
			 * @param {Object} type Тип сравнения.
			 * @param {Object} right Сравниваемое значение правой части.
			 * @return {Boolean} Возвращает результат сравнения бизнес-правила.
			 */
			getRuleComparingResult: function(left, type, right) {
				var rulePropertyCode = true;
				switch (type) {
					case Terrasoft.ComparisonType.IS_NULL:
						rulePropertyCode = Ext.isEmpty(left);
						break;
					case Terrasoft.ComparisonType.IS_NOT_NULL:
						rulePropertyCode = !Ext.isEmpty(left);
						break;
					case Terrasoft.ComparisonType.EQUAL:
						rulePropertyCode = (left === right);
						break;
					case Terrasoft.ComparisonType.NOT_EQUAL:
						rulePropertyCode = (left !== right);
						break;
					default:
						break;
				}
				return rulePropertyCode;
			},

			/**
			 * Определяет значение атрибута по пути колонок.
			 * @protected
			 * @param {Object} object Путь колонок правой части.
			 * @param {String} path Тип сравнения.
			 * @return {String} Возвращает значение атрибута по пути колонок.
			 */
			getAttributeValueByPath: function(object, path) {
				var returnValue = object;
				Terrasoft.each(path.split(this.metaPathSeparator), function(valueName) {
					if (!Ext.isEmpty(returnValue)) {
						returnValue = returnValue[valueName];
					}
				}, this);
				return returnValue;
			},

			/**
			 * Генерирует конфигурацию представления, на основе которой будут создаваться элементы управления.
			 * @protected
			 * @param {Object[]} viewConfig Конфигурация представления, объединенная по всей иерархии наследования
			 * схемы.
			 * @return {Object[]} Возвращает сгенерированное представление схемы.
			 */
			generateView: function(viewConfig) {
				var resultView = [];
				Terrasoft.each(viewConfig, function(item) {
					var itemView = this.generateItemView(item);
					resultView.push(itemView);
				}, this);
				return resultView;
			}
		});

		return Ext.create(businessRulesApplier);
	});

				// Autogenerated Code for schema BusinessRulesApplierV2 (End)
// Autogenerated Code for schema BaseGeneratorV2 (Start)
define('BaseGeneratorV2Resources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("BaseGeneratorV2", ["ext-base"], function(Ext) {
	var baseGenerator = Ext.define("Terrasoft.configuration.BaseGenerator", {
		extend: "Terrasoft.BaseObject",
		alternateClassName: "Terrasoft.BaseGenerator",

		/**
		 * Имя генерируемой схемы.
		 * @protected
		 * @type {String}
		 */
		schemaName: "",

		/**
		 * Тип генерируемой схемы.
		 * @protected
		 * @type {Terrasoft.SchemaType}
		 */
		schemaType: null,

		/**
		 * Конфигурация построения схемы.
		 * @protected
		 * @type {Object}
		 */
		generateConfig: null,

		/**
		 * Генерирует имя колонки модели c коллекцией вкладок.
		 * @protected
		 * @virtual
		 * @param {Object} config Конфигурация элемента представления схемы.
		 * @return {String} Возвращает сгенерированное имя колонки модели.
		 */
		getTabsCollectionName: function(config) {
			return config.collection && config.collection.bindTo;
		},

		/**
		 * Инициализирует внутренние параметры генератора.
		 * @protected
		 * @virtual
		 * @param {Object} config Конфигурация построения схемы.
		 */
		init: function(config) {
			var schema = config.schema;
			this.generateConfig = config;
			this.schemaName = config.schemaName || (schema && schema.schemaName) || "";
			this.schemaType = config.schemaType || (schema && schema.type);
		},

		/**
		 * Очищает внутренние параметры генератора.
		 * @protected
		 * @virtual
		 */
		clear: function() {
			this.generateConfig = null;
			this.schemaName = null;
			this.schemaType = null;
		},

		/**
		 * Базовый метод генерации.
		 * @protected
		 * @virtual
		 * @param {Object} config Конфигурация построения схемы.
		 * @param {Function} callback Функция-callback.
		 * @param {Object} scope Контекст выполнения функции callback.
		 */
		generate: function(config, callback, scope) {
			this.init(config);
			callback.call(scope || this);
		}

	});
	return baseGenerator;
});


				// Autogenerated Code for schema BaseGeneratorV2 (End)
// Autogenerated Code for schema ViewGeneratorV2 (Start)
define('ViewGeneratorV2Resources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={
	GeneratedItemIsEmptyMessage: 'Невозможно сгенерировать элемент по конфигурации: \"{0}\" .',
	CannotFindColumnMassage: 'Невозможно найти колонку по конфигурации: \"{0}\" .',
	LabelCaptionNullOrEmptyMessage: 'Заголовок для подписи \"{0}\" не был найден.',
	NotFiledPlaceholderCaption: 'Не заполнено',
	UnsupportedDataValueTypeMessage: 'Тип DataValueType.{0} не поддерживается'
};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("ViewGeneratorV2", ["BusinessRulesApplierV2", "ext-base", "terrasoft", "ViewGeneratorV2Resources",
		"LinkColumnHelper", "ModuleUtils", "BaseGeneratorV2"],
	function(BusinessRulesApplier, Ext, Terrasoft, resources, LinkColumnHelper, moduleUtils) {

		/**
		 * @class Terrasoft.configuration.ViewGenerator
		 * Класс-генератор представления
		 */
		var viewGenerator = Ext.define("Terrasoft.configuration.ViewGenerator", {
			extend: "Terrasoft.BaseGenerator",
			alternateClassName: "Terrasoft.ViewGenerator",

			/**
			 * Объект специфических генераторов для элементов
			 * @private
			 * @type {Object}
			 */
			customGenerators: null,

			/**
			 * Класс модели представления
			 * @private
			 * @type {Object}
			 */
			viewModelClass: null,

			/**
			 * Профиль cхемы
			 * @private
			 * @type {Object}
			 */
			schemaProfile: null,

			/**
			 * Css-класс контейнера-обертки над элементом модели с заголовком
			 * @private
			 * @type {String[]}
			 */
			defaultModelItemClass: "control-width-15",

			/**
			 * Css-класс контейнера-обертки над элементом модели без заголовка
			 * @private
			 * @type {String}
			 */
			defaultModelItemClassWithoutLabel: "control-no-label",

			/**
			 * Css-класс контейнера-обертки над элементом модели в сетке, если она находися в крайнем левом положении
			 * @private
			 * @type {String[]}
			 */
			defaultModelItemLeftClass: "control-left",

			/**
			 * Css-класс контейнера-обертки над элементом модели в сетке, если она находися в крайнем правом положении
			 * @private
			 * @type {String[]}
			 */
			defaultModelItemRightClass: "control-right",

			/**
			 * Css-класс контейнера-обертки элемента управления ControlGroup
			 * @private
			 * @type {String[]}
			 */
			defaultControlGroupClass: ["control-group-margin-bottom"],

			/**
			 * Css-класс контейнера-обертки элемента управления с заголовком колонки
			 * @private
			 * @type {String[]}
			 */
			defaultLabelWrapClass: ["label-wrap"],

			/**
			 * Css-класс контейнера-обертки элемента управления со значением колонки
			 * @private
			 * @type {String[]}
			 */
			defaultControlWrapClass: ["control-wrap"],

			/**
			 * Суффикс контейнера заголовка элемента управления
			 * @private
			 * @type {String}
			 */
			defaultLabelWrapSuffix: "_Label",

			/**
			 * Суффикс контейнера элемента управления
			 * @private
			 * @type {String}
			 */
			defaultControlWrapSuffix: "_Control",

			/**
			 * Css-класс подписи с размером по умолчанию
			 * @private
			 * @type {String}
			 */
			standardTextSizeClass: "",

			/**
			 * Css-класс подписи со стиль «Заголовок»
			 * @private
			 * @type {String}
			 */
			largeTextSizeClass: "text-size-caption",

			/**
			 * Css-класс контейнера переключателя
			 * @private
			 * @type {String}
			 */
			radioButtonContainerClass: ["radio-button-container"],

			/**
			 * Css-класс контейнера модуля
			 * @private
			 * @type {String}
			 */
			moduleClass: ["module-container"],

			/**
			 * Имя метода модели для вызова страницы справочника
			 * @private
			 * @type {String}
			 */
			loadVocabularyMethodName: "loadVocabulary",

			/**
			 * Суффикс имени колонки для полей со списком
			 * @private
			 * @type {String}
			 */
			defaultListColumnSuffix: "List",

			/**
			 * Суффикс идентификатора элемента ввода для подписи переключателя
			 * @private
			 * @type {String}
			 */
			radioButtonInputIdSuffix: "-el",

			/**
			 * Имя метода карточки для загрузки детали.
			 * @private
			 * @type {String}
			 */
			defaultLoadDetailMethodName: "loadDetail",

			/**
			 * Имя метода карточки для загрузки модуля
			 * @private
			 * @type {String}
			 */
			defaultLoadModuleMethodName: "loadModule",

			/**
			 * Имя события модели, вызиваемого при фокусировке элемента редактирования
			 * @private
			 * @type {String}
			 */
			defaultFocusMethodName: "onItemFocused",

			/**
			 * Максимальное количество столбцов в сетке
			 * @private
			 * @type {Number}
			 */
			maxGridLayoutColumnsCount: 24,

			/**
			 * Отступ снизу для элемента управления ScheduleEdit в px. Используется при установке дополнительных стилей
			 * страницы (отступ снизу). Элемент управления ScheduleEdit имеет преднастроенный отступ 5 px.
			 * @private
			 * @type {Number}
			 */
			defaultScheduleEditBottomPadding: Terrasoft.convertEmToPx("2em"),

			/**
			 * Объект развязки имени класса представления элемента и суффикса для уникального идентификатора.
			 * @private
			 * @type {Object}
			 */
			defaultControlSuffix: {
				"Terrasoft.GridLayout": "GridLayout",
				"Terrasoft.Grid": "Grid",
				"Terrasoft.TabPanel": "TabPanel",
				"Terrasoft.ImageTabPanel": "ImageTabPanel",
				"Terrasoft.Label": "Label",
				"Terrasoft.Button": "Button",
				"Terrasoft.MemoEdit": "MemoEdit",
				"Terrasoft.TextEdit": "TextEdit",
				"Terrasoft.HtmlEdit": "HtmlEdit",
				"Terrasoft.FloatEdit": "FloatEdit",
				"Terrasoft.IntegerEdit": "IntegerEdit",
				"Terrasoft.DateEdit": "DateEdit",
				"Terrasoft.TimeEdit": "TimeEdit",
				"Terrasoft.ComboBoxEdit": "ComboBoxEdit",
				"Terrasoft.LookupEdit": "LookupEdit",
				"Terrasoft.CheckBoxEdit": "CheckBoxEdit",
				"Terrasoft.ControlGroup": "ControlGroup",
				"Terrasoft.Container": "Container",
				"Terrasoft.RadioButton": "RadioButton",
				"Terrasoft.ScheduleEdit": "ScheduleEdit",
				"Terrasoft.BaseProgressBar": "BaseProgressBar"
			},

			/**
			 * Конфигурация заголовка ячейки реестра по умолчанию
			 * @private
			 * @type {Object}
			 */
			defaultGridCellCaptionConfig: {
				visible: true,
				position: Terrasoft.CaptionPositionType.ABOVE,
				align: Terrasoft.CaptionAlignType.LEFT
			},

			/**
			 * Значения позиции элементов в GridLayout по умолчанию
			 * @private
			 * @type {Object}
			 */
			defaultGridLayoutItemConfig: {
				colSpan: 12,
				rowSpan: 1
			},

			/**
			 * Шаблон названия свойства видимости для представления раздела
			 * @private
			 * @type {String}
			 */
			dataViewVisiblePropertyTemplate: "Is{0}Visible",

			/**
			 * Установить функции-генераторы для всех элементов, у которых указаны генераторы из этого модуля
			 * @private
			 * @param {String} moduleName Имя модуля
			 * @param {Object} module Экземпляр модуля
			 */
			setGeneratorsByModule: function(moduleName, module) {
				var generators = this.customGenerators;
				Terrasoft.each(generators, function(generator, itemName) {
					if (Ext.isString(generator) && generator.indexOf(moduleName) === 0) {
						var methodName = generator.split(".")[1];
						var generatorFn = module[methodName];
						generators[itemName] = {
							generatorFn: generatorFn,
							scope: module
						};
					}
				}, this);
			},

			/**
			 * Собирает коллекцию всех элементов, использующих пользовательские методы генерации. Вызывается рекурсивно
			 * @private
			 * @param {Object} config Конфигурация элемента представления схемы
			 * @param {Object} generators Элементы, использующих пользовательские генераторы. Используется для рекурсии
			 */
			fillCustomGenerators: function(config, generators) {
				Terrasoft.iterateChildItems(config, function(iterationConfig) {
					var itemConfig = iterationConfig.item;
					if (this.hasItemCustomGenerator(itemConfig)) {
						var itemName = itemConfig.name;
						generators[itemName] = itemConfig.generator;
					}
				}, this);
			},

			/**
			 * Запрашивает и получает все пользовательские функции-генераторы
			 * @private
			 * @param {Object[]} viewConfig Конфигурация представления, объединенная по всей иерархии наследования схемы
			 * @param {Function} callback Функция-callback, в нее передается сгенерированную конфигурацию представления
			 * @param {Object} scope Контекст выполнения функции callback
			 */
			requireCustomGenerators: function(viewConfig, callback, scope) {
				var generators = this.customGenerators = {};
				this.fillCustomGenerators(viewConfig, generators);
				var modulesToRequire = [];
				Terrasoft.each(generators, function(descriptor) {
					if (Ext.isString(descriptor)) {
						var generatorModule = descriptor.split(".")[0];
						modulesToRequire.push(generatorModule);
					}
				}, this);
				var me = this;
				require(modulesToRequire, function() {
					var modules = arguments;
					Terrasoft.each(modulesToRequire, function(moduleName, index) {
						me.setGeneratorsByModule(moduleName, modules[index]);
					});
					callback.call(scope);
				});
			},

			/**
			 * Генерирует конфигурацию представления, на основе которой будут создаваться элементы управления
			 * @protected
			 * @param {Object[]} viewConfig Конфигурация представления, объединенная по всей иерархии наследования схемы
			 * @return {Object[]} Возвращает сгенерированное представление схемы
			 */
			generateView: function(viewConfig) {
				var resultView = [];
				Terrasoft.each(viewConfig, function(item) {
					var itemView = this.generateItem(item);
					resultView = resultView.concat(itemView);
				}, this);
				return resultView;
			},

			/**
			 * Проверяет, должен ли элемент использовать пользовательскую функцию генерации
			 * @protected
			 * @param {Object} config Конфигурация элемента представления схемы
			 * @return {Boolean} Возвращает true, есть ли у элемента пользовательская функция генерации
			 * false в противном случае
			 */
			hasItemCustomGenerator: function(config) {
				var customGenerator = config.generator;
				return (Ext.isString(customGenerator) || Ext.isFunction(customGenerator));
			},

			/**
			 * Генерирует конфигурацию представления элемента схемы
			 * @protected
			 * @throws {Terrasoft.InvalidObjectState} Бросает исключение если элемент не был сгенерирован
			 * @param {Object} config Конфигурация элемента представления схемы
			 * @return {Object} Возвращает сгенерированное представление элемента
			 */
			generateItem: function(config) {
				var clonedConfig = Terrasoft.deepClone(config);
				var result = (this.hasItemCustomGenerator(clonedConfig))
					? this.generateCustomItem(clonedConfig)
					: this.generateStandardItem(clonedConfig);
				if (Ext.isEmpty(result)) {
					var errorMessage = Ext.String.format(
						resources.localizableStrings.GeneratedItemIsEmptyMessage,
						Terrasoft.encode(clonedConfig)
					);
					throw new Terrasoft.InvalidObjectState({
						message: errorMessage
					});
				}
				return result;
			},

			/**
			 * Генерирует представление элемента c помощью пользовательской функции
			 * @protected
			 * @param {Object} config Конфигурация элемента представления схемы
			 * @return {Object} Возвращает сгенерированное представление элемента
			 */
			generateCustomItem: function(config) {
				var name = config.name;
				var generator = this.customGenerators[name];
				var generatorFn = generator.generatorFn || generator;
				var generatorScope = generator.scope || config;
				return generatorFn.call(generatorScope, config, this.generateConfig);
			},

			/**
			 * Генерирует представление элемента
			 * @protected
			 * @virtual
			 * @param {Object} config Конфигурация элемента представления схемы
			 * @return {Object} Возвращает сгенерированное представление элемента
			 */
			generateStandardItem: function(config) {
				var itemType = config.itemType;
				var result = null;
				switch (itemType) {
					case Terrasoft.ViewItemType.GRID_LAYOUT:
						result = this.generateGridLayout(config);
						break;
					case Terrasoft.ViewItemType.TAB_PANEL:
						result = this.generateTabPanel(config);
						break;
					case Terrasoft.ViewItemType.IMAGE_TAB_PANEL:
						result = this.generateImageTabPanel(config);
						break;
					case Terrasoft.ViewItemType.DETAIL:
						result = this.generateDetail(config);
						break;
					case Terrasoft.ViewItemType.MODULE:
						result = this.generateModule(config);
						break;
					case Terrasoft.ViewItemType.BUTTON:
						result = this.generateButton(config);
						break;
					case Terrasoft.ViewItemType.LABEL:
						result = this.generateLabel(config);
						break;
					case Terrasoft.ViewItemType.CONTAINER:
						result = this.generateContainer(config);
						break;
					case Terrasoft.ViewItemType.MENU:
						result = this.generateMenu(config);
						break;
					case Terrasoft.ViewItemType.MENU_ITEM:
						result = this.generateMenuItem(config);
						break;
					case Terrasoft.ViewItemType.MENU_SEPARATOR:
						result = this.generateSeparatorMenuItem(config);
						break;
					case Terrasoft.ViewItemType.MODEL_ITEM:
						result = this.generateModelItem(config);
						break;
					case Terrasoft.ViewItemType.SECTION_VIEWS:
						result = this.generateSectionViews(config);
						break;
					case Terrasoft.ViewItemType.SECTION_VIEW:
						result = this.generateSectionView(config);
						break;
					case Terrasoft.ViewItemType.GRID:
						result = this.generateGrid(config);
						break;
					case Terrasoft.ViewItemType.CONTROL_GROUP:
						result = this.generateControlGroup(config);
						break;
					case Terrasoft.ViewItemType.RADIO_GROUP:
						result = this.generateRadioGroup(config);
						break;
					case Terrasoft.ViewItemType.DESIGN_VIEW:
						result = this.generateDesignedView(config);
						break;
					case Terrasoft.ViewItemType.SCHEDULE_EDIT:
						result = this.generateScheduleEdit(config);
						break;
					case Terrasoft.ViewItemType.COLOR_BUTTON:
						result = this.generateColorButton(config);
						break;
					case Terrasoft.ViewItemType.HYPERLINK:
						result = this.generateHyperlink(config);
						break;
					default:
						result = this.generateModelItem(config);
						break;
				}
				return result;
			},

			/**
			 * Генерирует уникальный идентификатор элемента управления
			 * на основе имени конфигурации элемента и имени класса.
			 * @protected
			 * @virtual
			 * @param {Object} config Конфигурация элемента представления схемы.
			 * @param {String} className Имя класса элемента управления.
			 * @return {String} Возвращает сгенерированные представления элементов сетки.
			 */
			getControlId: function(config, className) {
				return (this.schemaName + config.name + this.defaultControlSuffix[className]);
			},

			/**
			 * Добавляет идентификатор к конфигурации элемента управления.
			 * @protected
			 * @virtual
			 * @param {Object} control Конфигурация элемента управления.
			 * @param {Object} config Конфигурация элемента представления схемы.
			 */
			applyControlId: function(control, config, id) {
				if (config.generateId !== false) {
					Ext.apply(control, {id: id});
				}
			},

			/**
			 * Возвращает конфигурацию элемента без системных параметров
			 * @protected
			 * @virtual
			 * @param {Object} config Конфигурация элемента представления схемы
			 * @param {String[]} serviceProperties Перечень системных параметров
			 * @return {Object} Возвращает конфигурацию элемента без системных параметров
			 */
			getConfigWithoutServiceProperties: function(config, serviceProperties) {
				var result = Terrasoft.deepClone(config);
				serviceProperties = serviceProperties.concat(
					["name", "itemType", "controlConfig", "items", "layout", "contentType", "bindTo", "dataValueType",
						"generateId"]);
				Terrasoft.each(serviceProperties, function(propertyName) {
					delete result[propertyName];
				}, this);
				return result;
			},

			/**
			 * Возвращает конфигурацию элемента без указаных параметров
			 * @protected
			 * @virtual
			 * @param {Object} config Конфигурация элемента представления схемы
			 * @param {String[]} properties Перечень параметров
			 * @return {Object} Возвращает конфигурацию элемента без указаных параметров
			 */
			getConfigWithoutProperties: function(config, properties) {
				var result = Terrasoft.deepClone(config);
				Terrasoft.each(properties, function(propertyName) {
					delete result[propertyName];
				}, this);
				Terrasoft.each(result, function(obj) {
					if (Ext.isObject(obj) && !Ext.Object.isEmpty(obj)) {
						Terrasoft.each(properties, function(propertyName) {
							delete obj[propertyName];
						}, this);
					}
				}, this);
				return result;
			},

			/**
			 * Генерирует конфигурацию представления для сетки {Terrasoft.ViewItemType.GRID_LAYOUT}
			 * @protected
			 * @virtual
			 * @param {Object} config Конфигурация сетки
			 * @return {Object} Возвращает сгенерированное представление сетки
			 */
			generateGridLayout: function(config) {
				var controlId = this.getControlId(config, "Terrasoft.GridLayout");
				var result = {
					className: "Terrasoft.GridLayout",
					items: []
				};
				this.applyControlId(result, config, controlId);
				Terrasoft.each(config.items, function(childItem) {
					result.items = result.items.concat(this.generateGridLayoutItem(childItem));
				}, this);
				Ext.apply(result, this.getConfigWithoutServiceProperties(config, []));
				this.applyControlConfig(result, config);
				return result;
			},

			/**
			 * Расширяет описание положения объекта в сетке значениями по умолчанию
			 * @protected
			 * @param {Object} config Конфигурация элемента представления схемы
			 */
			applyLayoutItemDefaults: function(config) {
				config.layout = Ext.apply({}, config.layout, this.defaultGridLayoutItemConfig);
			},

			/**
			 * Генерирует конфигурацию представления для элементов сетки с учетом их положения
			 * @protected
			 * @param {Object} config Конфигурация элемента представления схемы
			 * @return {Object[]} Возвращает сгенерированные представления элементов сетки
			 */
			generateGridLayoutItem: function(config) {
				this.applyLayoutItemDefaults(config);
				var result = [];
				var items = this.generateItem(config);
				items = Ext.isArray(items) ? items : [items];
				Terrasoft.each(items, function(item) {
					result.push(Ext.apply({item: item}, config.layout));
				}, this);
				return result;
			},

			/**
			 * Генерирует конфигурацию представления для вкладок {Terrasoft.ViewItemType.TAB_PANEL}
			 * @protected
			 * @virtual
			 * @param {String} className Класс панели с вкладками.
			 * @param {Object} config Конфигурация вкладок
			 * @return {Object} Возвращает сгенерированное представление вкладок
			 */
			generateTabPanel: function(config, className) {
				var tabPanel = this.generateTabPanelControl(config, className);
				var result = [tabPanel];
				Terrasoft.each(config.tabs, function(tab) {
					result.push(this.generateTabContent(tab));
				}, this);
				return result;
			},

			/**
			 * Генерирует конфигурацию представления для вкладок {Terrasoft.ViewItemType.IMAGE_TAB_PANEL}
			 * @protected
			 * @virtual
			 * @param {Object} config Конфигурация вкладок
			 * @return {Object} Возвращает сгенерированное представление вкладок
			 */
			generateImageTabPanel: function(config) {
				return this.generateTabPanel(config, "Terrasoft.ImageTabPanel");
			},

			/**
			 * Генерирует конфигурацию представления для наследников элемента управления вкладок
			 * {Terrasoft.ViewItemType.IMAGE_TAB_PANEL}
			 * @protected
			 * @virtual
			 * @param {Object} config Конфигурация вкладок
			 * @return {Object} Возвращает сгенерированное представление вкладок
			 */
			generateTabPanelControl: function(config, className) {
				if (!className) {
					className = "Terrasoft.TabPanel";
				}
				var controlId = this.getControlId(config, className);
				var tabPanel = {
					className: className,
					tabs: {
						bindTo: this.getTabsCollectionName(config)
					}
				};
				this.applyControlId(tabPanel, config, controlId);
				Ext.apply(tabPanel, this.getConfigWithoutServiceProperties(config, ["tabs", "collection"]));
				this.applyControlConfig(tabPanel, config);
				return tabPanel;
			},

			/**
			 * Генерирует представление одной вкладки для {Terrasoft.ViewItemType.TAB_PANEL}
			 * @protected
			 * @virtual
			 * @param {Object} config Конфигурация вкладки
			 * @return {Object} Возвращает сгенерированное контейнера, содержащего описанные в конфигурации элементы
			 * с связкой на видимость
			 */
			generateTabContent: function(config) {
				var tabContainerName = config.name;
				var result = this.getDefaultContainerConfig(tabContainerName, config);
				result.visible = {bindTo: tabContainerName};
				Terrasoft.each(config.items, function(item) {
					result.items = result.items.concat(this.generateItem(item));
				}, this);
				return result;
			},

			/**
			 * Генерирует конфигурацию представления для детали {Terrasoft.ViewItemType.DETAIL}
			 * @protected
			 * @virtual
			 * @param {Object} config Конфигурация детали
			 * @return {Object} Возвращает сгенерированную конфигурацию представление детали
			 */
			generateDetail: function(config) {
				var detailContainerId = this.getControlId(config, "Terrasoft.Container");
				var result = this.getDefaultContainerConfig(detailContainerId, config);
				result.tag = {
					detailName: config.name,
					containerId: detailContainerId
				};
				result.markerValue = config.name + "DetailContainer";
				result.afterrender = { bindTo: this.defaultLoadDetailMethodName };
				result.afterrerender = { bindTo: this.defaultLoadDetailMethodName };
				Ext.apply(result, this.getConfigWithoutServiceProperties(config, []));
				this.applyControlConfig(result, config);
				return result;
			},

			/**
			 * Генерирует конфигурацию представления контейнера для модуля {Terrasoft.ViewItemType.MODULE}
			 * @protected
			 * @virtual
			 * @param {Object} config Конфигурация модуля
			 * @return {Object} Возвращает сгенерированное представление контейнера для модуля
			 */
			generateModule: function(config) {
				var moduleName = config.name;
				var controlConfig = {
					wrapClass: this.moduleClass,
					generateId: config.generateId
				};
				var containerId = moduleName;
				if (config.makeUniqueId === true) {
					containerId = this.getControlId(config, "Terrasoft.Container");
				}
				var result = this.getDefaultContainerConfig(containerId, controlConfig);
				result.tag = {
					containerId: result.id,
					moduleName: config.moduleName
				};
				result.markerValue = {"bindTo": moduleName + "ModuleContainer"};
				if (Ext.isEmpty(config.afterrender)) {
					result.afterrender = {bindTo: this.defaultLoadModuleMethodName};
				}
				if (Ext.isEmpty(config.afterrerender)) {
					result.afterrerender = {bindTo: this.defaultLoadModuleMethodName};
				}
				Ext.apply(result, this.getConfigWithoutServiceProperties(config, ["moduleName", "makeUniqueId"]));
				this.applyControlConfig(result, config);
				return result;
			},

			/**
			 * Генерирует конфигурацию представления для контейнера {Terrasoft.ViewItemType.CONTAINER}
			 * @protected
			 * @virtual
			 * @param {Object} config Конфигурация контейнера
			 * @return {Object} Возвращает сгенерированное представление контейнера
			 */
			generateContainer: function(config) {
				var id = this.getControlId(config, "Terrasoft.Container");
				var container = this.getDefaultContainerConfig(id, config);
				Terrasoft.each(config.items, function(childItem) {
					var childItemConfig = this.generateItem(childItem);
					container.items = container.items.concat(childItemConfig);
				}, this);
				Ext.apply(container, this.getConfigWithoutServiceProperties(config, ["wrapClass", "styles"]));
				this.applyControlConfig(container, config);
				return container;
			},

			/**
			 * Генерирует имя колонки модели со списком элементов для выпадающего списка
			 * @protected
			 * @virtual
			 * @param {Object} config Конфигурация элемента представления схемы
			 * @return {String} Возвращает сгенерированное имя колонки модели
			 */
			getExpandableListName: function(config) {
				return this.getItemBindTo(config) + this.defaultListColumnSuffix;
			},

			/**
			 * Формирует имя маркера
			 * @protected
			 * @virtual
			 * @param {Object} config Конфигурация элемента представления схемы
			 * @returns {String} Возращает сформированое имя маркера
			 */
			getMarkerValue: function(config) {
				if (config.markerValue) {
					return config.markerValue;
				}
				var caption = this.getLabelCaption(config);
				return !Ext.isString(caption)
					? config.name
					: Ext.String.format("{0} {1}", config.name, caption);
			},

			/**
			 * Генерирует конфигурацию представления для подписи {Terrasoft.ViewItemType.LABEL}
			 * @protected
			 * @virtual
			 * @throws {Terrasoft.NullOrEmptyException} Бросает исключение если не было найденно значение заголовка
			 * @param {Object} config Конфигурация подписи
			 * @return {Object} Возвращает сгенерированное представление подписи
			 */
			generateLabel: function(config) {
				var caption = this.getLabelCaption(config);
				if (Ext.isEmpty(caption)) {
					var errorMessage = Ext.String.format(
						resources.localizableStrings.LabelCaptionNullOrEmptyMessage,
						config.name
					);
					throw new Terrasoft.NullOrEmptyException({message: errorMessage});
				}
				var id = this.getControlId(config, "Terrasoft.Label");
				var label = {
					className: "Terrasoft.Label",
					caption: caption,
					markerValue: this.getMarkerValue(config)
				};
				this.applyControlId(label, config, id);
				this.addLabelSizeClass(label, config);
				Ext.apply(label, this.getConfigWithoutServiceProperties(config, ["labelConfig", "labelWrapConfig",
					"controlWrapConfig", "value", "textSize"]));
				if (config.labelConfig) {
					this.addClasses(label, "labelClass", config.labelConfig.classes);
					delete config.labelConfig.classes;
					Ext.merge(label, config.labelConfig);
				}
				return label;
			},

			/**
			 * Генерирует конфигурацию представления для гиперссылки {Terrasoft.ViewItemType.HYPERLINK}
			 * @protected
			 * @virtual
			 * @param {Object} config Конфигурация гиперссылки.
			 * @return {Object} Возвращает сгенерированное представление гиперссылки.
			 */
			generateHyperlink: function(config) {
				var id = this.getControlId(config, "Terrasoft.Hyperlink");
				var hyperlink = {
					className: "Terrasoft.Hyperlink",
					markerValue: this.getMarkerValue(config)
				};
				this.applyControlId(hyperlink, config, id);
				this.addLabelSizeClass(hyperlink, config);
				Ext.apply(hyperlink, this.getConfigWithoutServiceProperties(config, []));
				return hyperlink;
			},

			/**
			 * Добавляет css класс, отвечающий за установленный размер подписи
			 * @protected
			 * @virtual
			 * @param {Object} label Конфигурация представления подписи
			 * @param {Object} config Конфигурация подписи
			 */
			addLabelSizeClass: function(label, config) {
				var textSizeClasses = (config.textSize === Terrasoft.TextSize.LARGE)
					? [this.largeTextSizeClass]
					: [this.standardTextSizeClass];
				this.addClasses(label, "labelClass", textSizeClasses);
			},

			/**
			 * Генерирует конфигурацию представления для кнопки {Terrasoft.ViewItemType.BUTTON}
			 * @protected
			 * @virtual
			 * @param {Object} config Конфигурация кнопки
			 * @return {Object} Возвращает сгенерированное представление кнопки
			 */
			generateButton: function(config) {
				var id = this.getControlId(config, "Terrasoft.Button");
				var result = {
					className: "Terrasoft.Button",
					markerValue: config.name
				};
				this.applyControlId(result, config, id);
				var serviceProperties = [];
				if (Ext.isArray(config.menu)) {
					result.menu = this.generateItem({
						itemType: Terrasoft.ViewItemType.MENU,
						items: config.menu
					});
					serviceProperties.push("menu");
				}
				Ext.apply(result, this.getConfigWithoutServiceProperties(config, serviceProperties));
				this.applyControlConfig(result, config);
				return result;
			},

			/**
			 * Возвращает заголовок группы полей
			 * @protected
			 * @virtual
			 * @param {Object} config Конфигурация элемента представления схемы
			 * @return {String} Заголовок группы полей
			 */
			getControlGroupCaption: function(config) {
				var controlConfig = config.controlConfig;
				return config.caption || (controlConfig && controlConfig.caption);
			},


			/**
			 * Генерирует конфигурацию представления для группы элементов {Terrasoft.ViewItemType.CONTROL_GROUP}
			 * @protected
			 * @virtual
			 * @param {Object} config Конфигурация группы элементов
			 * @return {Object} Возвращает сгенерированное представление группы элементов
			 */
			generateControlGroup: function(config) {
				var controlId = this.getControlId(config, "Terrasoft.ControlGroup");
				var result = {
					className: "Terrasoft.ControlGroup",
					markerValue: this.getControlGroupCaption(config),
					classes: {wrapClass: this.defaultControlGroupClass},
					items: [],
					tools: [],
					collapsedchanged: {
						bindTo: "onCollapsedChanged"
					},
					collapsed: {
						bindTo: "is" + controlId + "Collapsed"
					},
					tag: controlId
				};
				this.applyControlId(result, config, controlId);
				Terrasoft.each(config.items, function(childItem) {
					result.items = result.items.concat(this.generateItem(childItem));
				}, this);
				Terrasoft.each(config.tools, function(childItem) {
					result.tools = result.tools.concat(this.generateItem(childItem));
				}, this);
				Ext.apply(result, this.getConfigWithoutServiceProperties(config, ["tools"]));
				this.applyControlConfig(result, config);
				return result;
			},

			/**
			 * Генерирует конфигурацию представления для группы переключателей {Terrasoft.ViewItemType.RADIO_GROUP}
			 * @protected
			 * @virtual
			 * @param {Object} config Конфигурация группы переключателей
			 * @return {Object} Возвращает сгенерированное представление группы переключателей
			 */
			generateRadioGroup: function(config) {
				var containerId = this.getControlId(config, "Terrasoft.Container");
				var result = this.getDefaultContainerConfig(containerId, config);
				Terrasoft.each(config.items, function(item) {
					item.bindTo = config.value;
					result.items.push(this.generateRadioButton(item));
				}, this);
				return result;
			},

			/**
			 * Генерирует конфигурацию представления для настраиваемой части представления.
			 * @protected
			 * @virtual
			 * @param {Object} config Конфигурация представления.
			 * @return {Object} Возвращает сгенерированное представление.
			 */
			generateDesignedView: function(config) {
				var id = config.name;
				var container = this.getDefaultContainerConfig(id, config);
				Ext.apply(container, this.getConfigWithoutServiceProperties(config, ["wrapClass", "styles"]));
				this.applyControlConfig(container, config);
				return container;
			},

			/**
			 * Генерирует конфигурацию представления для переключателя
			 * @protected
			 * @virtual
			 * @param {Object} config Конфигурация переключателя
			 * @return {Object} Возвращает сгенерированное представление переключателя
			 */
			generateRadioButton: function(config) {
				var containerId = this.getControlId(config, "Terrasoft.Container");
				var radioId = this.getControlId(config, "Terrasoft.RadioButton");
				var controlConfig = {
					wrapClass: this.radioButtonContainerClass,
					generateId: config.generateId
				};
				var result = this.getDefaultContainerConfig(containerId, controlConfig);
				var radioButton = {
					className: "Terrasoft.RadioButton",
					tag: config.value,
					checked: config.bindTo
				};
				this.applyControlId(radioButton, config, radioId);
				Ext.apply(radioButton, this.getConfigWithoutServiceProperties(config, ["caption"]));
				this.applyControlConfig(radioButton, config);
				var labelConfig = this.generateLabel(config);
				labelConfig.inputId = radioId + this.radioButtonInputIdSuffix;
				result.items.push(radioButton, labelConfig);
				return result;
			},

			/**
			 * Генерирует конфигурацию представления для меню {Terrasoft.ViewItemType.MENU}
			 * @protected
			 * @virtual
			 * @param {Object} config Конфигурация меню
			 * @return {Object} Возвращает сгенерированное представление меню
			 */
			generateMenu: function(config) {
				var result = {
					className: "Terrasoft.Menu",
					items: []
				};
				Terrasoft.each(config.items, function(menuItemConfig) {
					menuItemConfig.itemType = menuItemConfig.itemType || Terrasoft.ViewItemType.MENU_ITEM;
					var childItemConfig = this.generateItem(menuItemConfig);
					result.items.push(childItemConfig);
				}, this);
				return result;
			},

			/**
			 * Генерирует конфигурацию представления для элемента меню {Terrasoft.ViewItemType.MENU_ITEM}
			 * @protected
			 * @virtual
			 * @param {Object} config Конфигурация элемента меню
			 * @return {Object} Возвращает сгенерированное представление элемента меню
			 */
			generateMenuItem: function(config) {
				var result = {
					className: "Terrasoft.MenuItem",
					markerValue: config.name
				};
				if (config.menu) {
					result.menu = this.generateItem({
						itemType: Terrasoft.ViewItemType.MENU,
						items: config.menu
					});
				}
				Ext.apply(result, this.getConfigWithoutServiceProperties(config, ["menu"]));
				this.applyControlConfig(result, config);
				return result;
			},

			/**
			 * Генерирует конфигурацию представления разделителя в меню {Terrasoft.ViewItemType.MENU_SEPARATOR}
			 * @protected
			 * @virtual
			 * @param {Object} config Конфигурация разделителя в меню
			 * @return {Object} Возвращает сгенерированное представление разделителя в меню
			 */
			generateSeparatorMenuItem: function(config) {
				var result = {
					className: "Terrasoft.MenuSeparator"
				};
				Ext.apply(result, this.getConfigWithoutServiceProperties(config, []));
				this.applyControlConfig(result, config);
				return result;
			},

			/**
			 * Применяет controlConfig на схему элемента управления
			 * @protected
			 * @param {Object} control Схема элемента управления
			 * @param {Object} config Конфигурация элемента представления схемы
			 */
			applyControlConfig: function(control, config) {
				config.controlConfig = config.controlConfig || {};
				this.addClasses(control, "wrapClass", config.controlConfig.classes);
				delete config.controlConfig.classes;
				Ext.merge(control, config.controlConfig);
			},

			/**
			 * Генерирует конфигурацию представления для {Terrasoft.ViewItemType.MODEL_ITEM}
			 * @protected
			 * @param {Object} config Конфигурация элемента представления схемы
			 * @return {Object} Возвращает сгенерированное представление элемента
			 */
			generateModelItem: function(config) {
				var modelItemWrapId = this.getControlId(config, "Terrasoft.Container");
				var modelItemWrap = this.getDefaultContainerConfig(modelItemWrapId, config);
				if (!Ext.isEmpty(config.visible)) {
					modelItemWrap.visible = config.visible;
				}
				if (this.isItemLabelVisible(config)) {
					var labelWrap = this.generateControlLabelWrap(config);
					var label = this.generateControlLabel(config);
					labelWrap.items.push(label);
					modelItemWrap.items.push(labelWrap);
				}
				var defaultClasses = this.getModelItemContainerClasses(config);
				this.addClasses(modelItemWrap, "wrapClassName", defaultClasses);
				var controlWrap = this.generateEditControlWrap(config);
				var control = this.generateEditControl(config);
				controlWrap.items.push(control);
				modelItemWrap.items.push(controlWrap);
				return modelItemWrap;
			},

			/**
			 * Возвращает информацию об необходимости генерировать подпись для элемента
			 * @protected
			 * @param {Object} config Конфигурация элемента представления схемы
			 * @return {Boolean} Возвращает true если нужно генерировать подпись,
			 * false в противном случае
			 */
			isItemLabelVisible: function(config) {
				return (!config.labelConfig || config.labelConfig.visible !== false);
			},

			/**
			 * Генерирует коллекцию классов для обертки над элементом модели
			 * @protected
			 * @param {Object} config Конфигурация элемента представления схемы
			 * @return {Array[]} Возвращает коллекцию классов для обертки над элементом модели
			 */
			getModelItemContainerClasses: function(config) {
				var result = this.isItemLabelVisible(config)
					? [this.defaultModelItemClass]
					: [this.defaultModelItemClassWithoutLabel];
				if (!config.layout) {
					return result;
				}
				if (config.layout.column === 0) {
					result.push(this.defaultModelItemLeftClass);
				}
				if ((config.layout.column + config.layout.colSpan) === this.maxGridLayoutColumnsCount) {
					result.push(this.defaultModelItemRightClass);
				}
				return result;
			},

			/**
			 * Возвращает текстовое значение заголовка элемента представления схемы
			 * @protected
			 * @virtual
			 * @param {Object} config Конфигурация элемента представления схемы
			 * @return {String}
			 */
			getLabelCaption: function(config) {
				var labelConfig = config.labelConfig;
				var caption;
				if (config.caption) {
					caption = config.caption;
				} else if (labelConfig && labelConfig.caption) {
					caption = labelConfig.caption;
				} else {
					var column = this.findViewModelColumn(config);
					if (column && column.caption) {
						caption = column.caption;
					}
				}
				return caption;
			},

			/**
			 * Генерирует конфигурацию контейнера заголовка элемента управления
			 * @protected
			 * @virtual
			 * @param {Object} config Конфигурация элемента представления схемы
			 * @return {Object} Возвращает конфигурацию контейнера заголовка элемента управления
			 */
			generateControlLabelWrap: function(config) {
				var labelWrapId = this.getControlId(config, "Terrasoft.Container");
				if (labelWrapId) {
					labelWrapId = labelWrapId + this.defaultLabelWrapSuffix;
				}
				var controlConfig = {
					wrapClass: this.defaultLabelWrapClass,
					generateId: config.generateId
				};
				var labelWrap = this.getDefaultContainerConfig(labelWrapId, controlConfig);
				var labelWrapConfig = config.labelWrapConfig;
				if (labelWrapConfig) {
					var configClasses = labelWrapConfig.classes;
					if (configClasses) {
						var wrapClasses = configClasses.wrapClassName;
						this.addClasses(labelWrap, "wrapClassName", wrapClasses);
						delete labelWrapConfig.classes;
					}
					Ext.merge(labelWrap, labelWrapConfig);
					delete config.labelWrapConfig;
				}
				return labelWrap;
			},

			/**
			 * Генерирует конфигурацию представления заголовка элемента схемы
			 * @protected
			 * @virtual
			 * @param {Object} config Конфигурация элемента представления схемы
			 * @return {Object} Возвращает сгенерированное представление заголовка элемента схемы
			 */
			generateControlLabel: function(config) {
				var label = this.generateLabel(config);
				label.isRequired = Ext.isEmpty(label.isRequired) ? this.isItemRequired(config) : label.isRequired;
				var columnConfig = this.findViewModelColumn(config);
				label.tag = (columnConfig) ? columnConfig.name : "";
				if (columnConfig && columnConfig.dataValueType === Terrasoft.DataValueType.BOOLEAN) {
					label.click = {
						bindTo: "invertColumnValue"
					};
				}
				delete label.href;
				delete label.showValueAsLink;
				delete label.hasClearIcon;
				delete label.timeFormat;
				return label;
			},

			/**
			 * Добавляет переданные css классы в схему элемента управления
			 * @protected
			 * @param {Object} control Схема элемента управления
			 * @param {String} classType Имя свойства схемы классов элемента управления для вставки классов
			 * @param {String[]} classes Массив css классов
			 */
			addClasses: function(control, classType, classes) {
				if (Ext.isEmpty(classes)) {
					return;
				}
				var classesObject = control.classes = control.classes || {};
				var controlClasses = classesObject[classType] || [];
				classesObject[classType] = Ext.Array.merge(controlClasses, classes);
			},

			/**
			 * Возвращает имя параметра модели представления, с которым нужно связать текущий элемент
			 * @protected
			 * @virtual
			 * @param {Object} config Конфигурация элемента представления схемы
			 * @return {String} Возвращает имя параметра модели представления, с которым нужно связать текущий элемент
			 */
			getItemBindTo: function(config) {
				return (config.bindTo || config.name);
			},

			/**
			 * Возвращает тип данных элемента
			 * @protected
			 * @virtual
			 * @throws {Terrasoft.ItemNotFoundException} Бросает исключение если колонка не была найденна
			 * @param {Object} config Конфигурация элемента представления схемы
			 * @return {Terrasoft.DataValueType} Возвращает тип данных элемент
			 */
			getItemDataValueType: function(config) {
				if (!Ext.isEmpty(config.dataValueType)) {
					return config.dataValueType;
				}
				var entitySchemaColumn = this.findViewModelColumn(config);
				if (Ext.isEmpty(entitySchemaColumn)) {
					var errorMessage = Ext.String.format(
						resources.localizableStrings.CannotFindColumnMassage,
						Terrasoft.encode(config)
					);
					throw new Terrasoft.ItemNotFoundException({
						message: errorMessage
					});
				}
				return entitySchemaColumn.dataValueType;
			},

			/**
			 * Возвращает колонку схемы, к которой была сделана привязка
			 * @protected
			 * @param {Object} config Конфигурация элемента представления схемы
			 * @return {Object} Объект колонки
			 */
			findViewModelColumn: function(config) {
				var bindToProperty = this.getItemBindTo(config);
				return this.viewModelClass.prototype.getColumnByName(bindToProperty);
			},

			/**
			 * Возвращает объект с информацией для связывания элемента управления по умолчанию
			 * @protected
			 * @virtual
			 * @param {Object} config Конфигурация элемента представления схемы
			 * @return {object} Возвращает объект с связками по умолчанию
			 */
			getAutoBindings: function(config) {
				var result = {
					value: {bindTo: this.getItemBindTo(config)},
					isRequired: this.isItemRequired(config),
					markerValue: this.getMarkerValue(config),
					placeholder: resources.localizableStrings.NotFiledPlaceholderCaption
				};
				if (this.schemaType === Terrasoft.SchemaType.EDIT_VIEW_MODEL_SCHEMA) {
					result.focus = {bindTo: this.defaultFocusMethodName};
				}
				return result;
			},

			/**
			 * Возвращает является ли элемент обязательным для заполнения
			 * @protected
			 * @virtual
			 * @param {Object} config Конфигурация элемента представления схемы
			 * @return {Boolean} Возвращает является ли элемент обязательным для заполнения
			 */
			isItemRequired: function(config) {
				var column = this.findViewModelColumn(config);
				return Ext.isEmpty(column) ? false : column.isRequired;
			},

			/**
			 * Генерирует конфигурацию представления для текстового поля
			 * @protected
			 * @virtual
			 * @param {Object} config Конфигурация элемента представления схемы
			 * @return {object} Возвращает представление текстового поля
			 */
			generateTextEdit: function(config) {
				var className = "";
				switch (config.contentType) {
					case Terrasoft.ContentType.LONG_TEXT:
						className = "Terrasoft.MemoEdit";
						break;
					case Terrasoft.ContentType.RICH_TEXT:
						className = "Terrasoft.HtmlEdit";
						break;
					default:
						className = "Terrasoft.TextEdit";
						break;
				}
				var id = this.getControlId(config, className);
				var textEdit = {
					className: className
				};
				this.applyControlId(textEdit, config, id);
				var defaultBindings = this.getAutoBindings(config);
				if (config.contentType === Terrasoft.ContentType.RICH_TEXT) {
					delete defaultBindings.placeholder;// todo: remove after htmlEdit will use "placeholder"
					//#277633 HtmlEdit: Реализовать работу HtmlEdit с placeholder
				}
				Ext.apply(textEdit, defaultBindings);
				Ext.apply(textEdit, this.getConfigWithoutServiceProperties(config,
					["labelConfig", "labelWrapConfig", "caption", "textSize"]));
				this.applyControlConfig(textEdit, config);
				return textEdit;
			},

			/**
			 * Генерирует конфигурацию представления для целочисленного поля
			 * @protected
			 * @virtual
			 * @param {Object} config Конфигурация элемента представления схемы
			 * @return {object} Возвращает представление целочисленного поля
			 */
			generateIntegerEdit: function(config) {
				var id = this.getControlId(config, "Terrasoft.IntegerEdit");
				var integerEdit = {
					className: "Terrasoft.IntegerEdit"
				};
				this.applyControlId(integerEdit, config, id);
				var defaultBindings = this.getAutoBindings(config);
				Ext.apply(integerEdit, defaultBindings);
				Ext.apply(integerEdit, this.getConfigWithoutServiceProperties(config,
					["labelConfig", "labelWrapConfig", "caption", "textSize"]));
				this.applyControlConfig(integerEdit, config);
				return integerEdit;
			},

			/**
			 * Генерирует конфигурацию представления для поля с плавающей запятой
			 * @protected
			 * @virtual
			 * @param {Object} config Конфигурация элемента представления схемы
			 * @return {object} Возвращает представление поля с плавающей запятой
			 */
			generateFloatEdit: function(config) {
				var id = this.getControlId(config, "Terrasoft.FloatEdit");
				var floatEdit = {
					className: "Terrasoft.FloatEdit"
				};
				this.applyControlId(floatEdit, config, id);
				var defaultBindings = this.getAutoBindings(config);
				var column = this.findViewModelColumn(config);
				if (column) {
					Ext.apply(floatEdit, {decimalPrecision: column.precision});
				}
				Ext.apply(floatEdit, defaultBindings);
				Ext.apply(floatEdit, this.getConfigWithoutServiceProperties(config,
					["labelConfig", "labelWrapConfig", "caption", "textSize"]));
				this.applyControlConfig(floatEdit, config);
				return floatEdit;
			},

			/**
			 * Генерирует конфигурацию представления для денежного поля
			 * @protected
			 * @virtual
			 * @param {Object} config Конфигурация элемента представления схемы
			 * @return {object} Возвращает представление денежного поля
			 */
			generateMoneyEdit: function(config) {
				var id = this.getControlId(config, "Terrasoft.FloatEdit");
				var floatEdit = {
					className: "Terrasoft.FloatEdit",
					decimalPrecision: 2
				};
				this.applyControlId(floatEdit, config, id);
				var defaultBindings = this.getAutoBindings(config);
				Ext.apply(floatEdit, defaultBindings);
				Ext.apply(floatEdit, this.getConfigWithoutServiceProperties(config,
					["labelConfig", "labelWrapConfig", "caption", "textSize"]));
				this.applyControlConfig(floatEdit, config);
				return floatEdit;
			},

			/**
			 * Генерирует конфигурацию представления для поля даты и времени
			 * @protected
			 * @virtual
			 * @param {Object} config Конфигурация элемента представления схемы
			 * @return {object} Возвращает представление поля даты и времени
			 */
			generateDateTimeEdit: function(config) {
				var dateEdit = this.generateDateEdit(config);
				var timeEdit = this.generateTimeEdit(config);
				this.addClasses(dateEdit, "wrapClass", ["datetime-datecontrol"]);
				this.addClasses(timeEdit, "wrapClass", ["datetime-timecontrol"]);
				var controlContainer = this.getDefaultContainerConfig(config.name + "DateTimeContainer", config);
				controlContainer.items = [dateEdit, timeEdit];
				return controlContainer;
			},

			/**
			 * Генерирует конфигурацию представления для поля даты
			 * @protected
			 * @virtual
			 * @param {Object} config Конфигурация элемента представления схемы
			 * @return {object} Возвращает представление поля даты
			 */
			generateDateEdit: function(config) {
				var id = this.getControlId(config, "Terrasoft.DateEdit");
				var dateEdit = {
					className: "Terrasoft.DateEdit"
				};
				this.applyControlId(dateEdit, config, id);
				var defaultBindings = this.getAutoBindings(config);
				Ext.apply(dateEdit, defaultBindings);
				Ext.apply(dateEdit, this.getConfigWithoutServiceProperties(config,
					["labelConfig", "labelWrapConfig", "caption", "textSize"]));
				if (config.controlConfig) {
					this.applyControlConfig(dateEdit, config.controlConfig.dateEdit || {});
					delete config.controlConfig.dateEdit;
				}
				var configWithOutTimeEdit = this.getConfigWithoutProperties(config,
					["timeEdit"]);
				this.applyControlConfig(dateEdit, configWithOutTimeEdit);
				return dateEdit;
			},

			/**
			 * Генерирует конфигурацию представления для поля времени
			 * @protected
			 * @virtual
			 * @param {Object} config Конфигурация элемента представления схемы
			 * @return {object} Возвращает представление поля времени
			 */
			generateTimeEdit: function(config) {
				var id = this.getControlId(config, "Terrasoft.TimeEdit");
				var timeEdit = {
					className: "Terrasoft.TimeEdit"
				};
				this.applyControlId(timeEdit, config, id);
				var defaultBindings = this.getAutoBindings(config);
				Ext.apply(timeEdit, defaultBindings);
				Ext.apply(timeEdit, this.getConfigWithoutServiceProperties(config,
					["labelConfig", "labelWrapConfig", "caption", "textSize"]));
				if (config.controlConfig) {
					this.applyControlConfig(timeEdit, config.controlConfig.timeEdit || {});
					delete config.controlConfig.timeEdit;
				}
				this.applyControlConfig(timeEdit, config);
				return timeEdit;
			},

			/**
			 * Генерирует конфигурацию представления для поля с выпадающим списком
			 * @protected
			 * @virtual
			 * @param {Object} config Конфигурация элемента представления схемы
			 * @return {object} Возвращает представление поля с выпадающим списком
			 */
			generateEnumEdit: function(config) {
				var id = this.getControlId(config, "Terrasoft.ComboBoxEdit");
				var enumEdit = {
					className: "Terrasoft.ComboBoxEdit",
					list: {
						bindTo: this.getExpandableListName(config)
					}
				};
				this.applyControlId(enumEdit, config, id);
				var defaultBindings = this.getAutoBindings(config);
				Ext.apply(enumEdit, defaultBindings);
				Ext.apply(enumEdit, this.getConfigWithoutServiceProperties(config,
					["labelConfig", "labelWrapConfig", "caption", "textSize"]));
				this.applyControlConfig(enumEdit, config);
				return enumEdit;
			},

			/**
			 * Генерирует конфигурацию представления для справочного поля.
			 * @protected
			 * @virtual
			 * @param {Object} config Конфигурация элемента представления схемы.
			 * @return {object} Конфигурация представления справочного поля.
			 */
			generateLookupEdit: function(config) {
				var contentType = config.contentType;
				if ((contentType && (contentType !== Terrasoft.ContentType.LOOKUP)) || !contentType) {
					var viewModelColumn = this.findViewModelColumn(config);
					if (viewModelColumn && viewModelColumn.isSimpleLookup) {
						contentType = Terrasoft.ContentType.ENUM;
					}
				}
				if (contentType && contentType === Terrasoft.ContentType.ENUM) {
					return this.generateEnumEdit(config);
				}
				var id = this.getControlId(config, "Terrasoft.LookupEdit");
				var lookupEdit = {
					className: "Terrasoft.LookupEdit",
					list: {
						bindTo: this.getExpandableListName(config)
					},
					tag: this.getItemBindTo(config),
					loadVocabulary: {
						bindTo: this.loadVocabularyMethodName
					},
					change: {
						bindTo: "onLookupChange"
					},
					href: { bindTo: "getLinkUrl" },
					linkclick: { bindTo: "onLinkClick" },
					showValueAsLink: true,
					hasClearIcon: true
				};
				this.applyControlId(lookupEdit, config, id);
				var defaultBindings = this.getAutoBindings(config);
				Ext.apply(lookupEdit, defaultBindings);
				Ext.apply(lookupEdit, this.getConfigWithoutServiceProperties(config,
					["loadVocabularyMethodName", "labelConfig", "labelWrapConfig", "caption", "textSize"]));
				this.applyControlConfig(lookupEdit, config);
				return lookupEdit;
			},

			/**
			 * Генерирует конфигурацию представления для логического поля
			 * @protected
			 * @virtual
			 * @param {Object} config Конфигурация элемента представления схемы
			 * @return {object} Возвращает представление логического поля
			 */
			generateBooleanEdit: function(config) {
				var id = this.getControlId(config, "Terrasoft.CheckBoxEdit");
				var checkBoxEdit = {
					className: "Terrasoft.CheckBoxEdit",
					checked: {
						bindTo: this.getItemBindTo(config)
					},
					markerValue: this.getMarkerValue(config)
				};
				this.applyControlId(checkBoxEdit, config, id);
				if (this.schemaType === Terrasoft.SchemaType.EDIT_VIEW_MODEL_SCHEMA) {
					checkBoxEdit.focus = { bindTo: this.defaultFocusMethodName };
				}
				Ext.apply(checkBoxEdit, this.getConfigWithoutServiceProperties(config,
					["labelConfig", "labelWrapConfig", "caption", "textSize"]));
				this.applyControlConfig(checkBoxEdit, config);
				return checkBoxEdit;
			},

			/**
			 * Генерирует конфигурацию представления индикатора прогресса
			 * @protected
			 * @overridden
			 * @param {Object} config Конфигурация элемента индикатор прогресса
			 * @return {Object} Возвращает сгенерированное представление поля элемента схемы
			 */
			generateStageIndicator: function(config) {
				var id = this.getControlId(config, "Terrasoft.BaseProgressBar");
				var stageIndicator = {
					className: "Terrasoft.BaseProgressBar",
					markerValue: this.getMarkerValue(config)
				};
				this.applyControlId(stageIndicator, config, id);
				Ext.apply(stageIndicator, this.getConfigWithoutServiceProperties(config,
					["labelConfig", "labelWrapConfig", "caption", "isRequired", "generator"]));
				this.applyControlConfig(stageIndicator, config);
				return stageIndicator;
			},

			/**
			 * Генерирует конфигурацию контейнера элемента управления
			 * @protected
			 * @virtual
			 * @param {Object} config Конфигурация элемента представления схемы
			 * @return {Object} Возвращает конфигурацию контейнера элемента управления
			 */
			generateEditControlWrap: function(config) {
				var controlWrapId = this.getControlId(config, "Terrasoft.Container");
				if (controlWrapId) {
					controlWrapId = controlWrapId + this.defaultControlWrapSuffix;
				}
				var controlConfig = {
					wrapClass: this.defaultControlWrapClass,
					generateId: config.generateId
				};
				var controlWrap = this.getDefaultContainerConfig(controlWrapId, controlConfig);
				var controlWrapConfig = config.controlWrapConfig;
				if (controlWrapConfig) {
					var configClasses = controlWrapConfig.classes;
					if (configClasses) {
						var wrapClasses = configClasses.wrapClassName;
						this.addClasses(controlWrap, "wrapClassName", wrapClasses);
						delete config.controlWrapConfig.classes;
					}
					Ext.merge(controlWrap, controlWrapConfig);
					delete config.controlWrapConfig;
				}
				return controlWrap;
			},

			/**
			 * Генерирует конфигурацию представления поля элемента схемы.
			 * @protected
			 * @virtual
			 * @param {Object} config Конфигурация элемента представления схемы.
			 * @return {Object/Array} Возвращает сгенерированное представление поля элемента схемы.
			 */
			generateEditControl: function(config) {
				var itemDataValueType = this.getItemDataValueType(config);
				var controlConfig;
				switch (itemDataValueType) {
					case Terrasoft.DataValueType.TEXT:
						controlConfig = this.generateTextEdit(config);
						break;
					case Terrasoft.DataValueType.INTEGER:
						controlConfig = this.generateIntegerEdit(config);
						break;
					case Terrasoft.DataValueType.FLOAT:
						controlConfig = this.generateFloatEdit(config);
						break;
					case Terrasoft.DataValueType.MONEY:
						controlConfig = this.generateMoneyEdit(config);
						break;
					case Terrasoft.DataValueType.DATE_TIME:
						controlConfig = this.generateDateTimeEdit(config);
						break;
					case Terrasoft.DataValueType.DATE:
						controlConfig = this.generateDateEdit(config);
						break;
					case Terrasoft.DataValueType.TIME:
						controlConfig = this.generateTimeEdit(config);
						break;
					case Terrasoft.DataValueType.LOOKUP:
						controlConfig = this.generateLookupEdit(config);
						break;
					case Terrasoft.DataValueType.ENUM:
						controlConfig = this.generateEnumEdit(config);
						break;
					case Terrasoft.DataValueType.BOOLEAN:
						controlConfig = this.generateBooleanEdit(config);
						break;
					case Terrasoft.DataValueType.STAGE_INDICATOR:
						controlConfig = this.generateStageIndicator(config);
						break;
					default:
						var errorMessage = Ext.String.format(
							resources.localizableStrings.UnsupportedDataValueTypeMessage,
							Ext.Object.getKey(Terrasoft.DataValueType, itemDataValueType));
						throw new Terrasoft.UnsupportedTypeException({message: errorMessage});
				}
				return controlConfig;
			},

			/**
			 * Генерирует конфигурацию представления контейнера {Terrasoft.Container}.
			 * @protected
			 * @virtual
			 * @param {String} id Уникальный идентификатор на странице.
			 * @param {Object} config Конфигурация элемента представления схемы.
			 * @param {String} config.wrapClass СSS классы контейнера.
			 * @param {Object} config.styles СSS стили контейнера.
			 * @return {Object} Возвращает сгенерированное представление контейнера.
			 */
			getDefaultContainerConfig: function(id, config) {
				var wrapClass = config.wrapClass;
				var styles = config.styles;
				var container = {
					className: "Terrasoft.Container",
					items: []
				};
				this.applyControlId(container, config, id);
				if (!Ext.isEmpty(styles)) {
					container.styles = {wrapStyles: styles};
				}
				if (!Ext.isEmpty(wrapClass)) {
					container.classes = {wrapClassName: wrapClass};
				}
				return container;
			},

			/**
			 * Генерирует конфигурацию представления для Terrasoft.ViewItemType.SECTION_VIEWS
			 * @protected
			 * @virtual
			 * @param {Object} config Описание элемента представления
			 * @return {Object} Конфигурация представлений
			 */
			generateSectionViews: function(config) {
				return this.generateContainer(config);
			},

			/**
			 * Генерирует конфигурацию представления для Terrasoft.ViewItemType.SECTION_VIEW
			 * @protected
			 * @virtual
			 * @param {Object} config Описание элемента представления
			 * @return {Object} Конфигурация представления
			 */
			generateSectionView: function(config) {
				var container = this.generateContainer(config);
				var visible = Ext.String.format(this.dataViewVisiblePropertyTemplate, config.name);
				container.visible = {bindTo: visible};
				Ext.apply(container, this.getConfigWithoutServiceProperties(config, []));
				this.applyControlConfig(container, config);
				return container;
			},

			/**
			 * Получает начальную конфигурацию реестра
			 * @private
			 * @param {Object} config Конфигурационный объект
			 * @returns {Object}
			 */
			getDefaultGridConfig: function(config) {
				var className = "Terrasoft.Grid";
				var id = this.getControlId(config, className);
				var gridConfig = {
					className: className
				};
				this.applyControlId(gridConfig, config, id);
				return gridConfig;
			},

			/**
			 * Генерирует конфигурацию заголовка в ячейке плиточного реестра
			 * @param {Object} gridConfig Конфигурация реестра
			 * @param {Object} columnConfig Конфигурация колонки реестра
			 * @return {Object} Возвращает конфигурацию заголовка в ячейке
			 */
			generateTiledCellCaption: function(gridConfig, columnConfig) {
				var captionConfig = Ext.apply({}, columnConfig.captionConfig, this.defaultGridCellCaptionConfig);
				if (gridConfig.type !== Terrasoft.GridType.TILED || !captionConfig.visible) {
					return null;
				}
				var name = this.getGridColumnCaption(columnConfig);
				if (!name) {
					return null;
				}
				return {
					type: !!gridConfig.isVertical ? Terrasoft.GridKeyType.LABEL : Terrasoft.GridKeyType.CAPTION,
					name: name
				};
			},

			/**
			 * Генерирует конфигурацию значения в ячейке
			 * @param {Object} config Конфигурация колонки
			 * @return {Object} Возвращает конфигурацию значения в ячейке
			 */
			generateGridCellValue: function(config) {
				var cellValue = {};
				var type = config.type;
				cellValue.name = config.value || {bindTo: config.bindTo};
				switch (type) {
					case Terrasoft.GridCellType.LINK:
						cellValue.name = {bindTo: "on" + config.bindTo + "LinkClick"};
						cellValue.type = Terrasoft.GridKeyType.LINK;
						break;
					case Terrasoft.GridCellType.TITLE:
						cellValue.type = Terrasoft.GridKeyType.TITLE;
						break;
					default:
						cellValue.type = Terrasoft.GridKeyType.TEXT;
						break;
				}
				return cellValue;
			},

			/**
			 * Сортирует колоноки в рамках одной строки реестра по позиции относительно левого края.
			 * В конфигурацию реестра текущей реализации колонки необходимо добавлять по порядку
			 * @protected
			 * @param {Array} columns Массив колонок строки
			 */
			sortGridRowColumns: function(columns) {
				columns.sort(function(first, second) {
					var firstColumn = first.position.column;
					var secondColumn = second.position.column;
					if (firstColumn > secondColumn) {
						return 1;
					}
					if (firstColumn < secondColumn) {
						return -1;
					}
					return 0;
				});
			},

			/**
			 * Получает значение заголовка колонки в реестре
			 * @protected
			 * @param {Object} config Конфигурация колонки
			 * @return {String} Возвращает значение заголовка колонки в реестре
			 */
			getGridColumnCaption: function(config) {
				if (config.caption) {
					return config.caption;
				}
				var viewModelColumn = this.findViewModelColumn(config);
				if (viewModelColumn) {
					return viewModelColumn.caption;
				}
				return null;
			},

			/**
			 * Генерирует конфигурацию заголовка колонки списочного реестра
			 * @protected
			 * @param {Object} config Конфигурация колонки
			 * @return {Object} Возвращает конфигурацию заголовка колонки списочного реестра
			 */
			generateGridCaptionConfig: function(config) {
				var position = config.position;
				var cols = position.colSpan;
				var name = this.getGridColumnCaption(config);
				return {
					cols: cols,
					name: name
				};
			},

			/**
			 * Генерирует конфигурацию заголовков списочного реестра
			 * @protected
			 * @param {Array} columns Конфигурация колонки
			 * @return {Array} Возвращает конфигурацию заголовков списочного реестра
			 */
			generateGridCaptionsConfig: function(columns) {
				var captionsConfig = [];
				this.sortGridRowColumns(columns);
				Terrasoft.each(columns, function(column) {
					var captionConfig = this.generateGridCaptionConfig(column);
					captionsConfig.push(captionConfig);
				}, this);
				return captionsConfig;
			},

			/**
			 * Получает колонки соответствующие указанной строке реестра
			 * @protected
			 * @param {Object} config Конфигурация колонок
			 * @param {Number} rowIndex Порядковый номер строки
			 * @return {Array} Возвращает колонки соответствующие указанной строке реестра
			 */
			getGridRowColumns: function(config, rowIndex) {
				return config.items.filter(function(column) {
					var position = column.position;
					return (position.row === rowIndex);
				});
			},

			/**
			 * Генерирует конфигурацию строки реестра
			 * @protected
			 * @param {Object} gridConfig Конфигурация реестра
			 * @param {Object} columns Конфигурация колонок
			 * @return {Array} Возвращает конфигурацию строки реестра
			 */
			generateGridRowConfig: function(gridConfig, columns) {
				var rowConfig = [];
				this.sortGridRowColumns(columns);
				Terrasoft.each(columns, function(column) {
					var cellConfig = this.generateGridCell(gridConfig, column);
					rowConfig.push(cellConfig);
				}, this);
				return rowConfig;
			},

			/**
			 * Генерирует конфигурацию ячейки реестра
			 * @protected
			 * @param {Object} gridConfig Конфигурация реестра
			 * @param {Object} columnConfig Конфигурация колонки
			 * @return {Object} Возвращает конфигурацию ячейки реестра
			 */
			generateGridCell: function(gridConfig, columnConfig) {
				var cols = columnConfig.position.colSpan;
				var key = [];
				var cellCaption = this.generateTiledCellCaption(gridConfig, columnConfig);
				var cellValue = this.generateGridCellValue(columnConfig);
				if (!!gridConfig.isVertical) {
					return this.generateVerticalGridCellConfig(cellCaption, cellValue, cols);
				}
				if (cellCaption) {
					key.push(cellCaption);
				}
				if (cellValue) {
					key.push(cellValue);
				}
				var cellConfig = {
					cols: cols,
					key: key
				};
				var aggregationType = columnConfig.aggregationType;
				if (!Ext.isEmpty(aggregationType)) {
					cellConfig.aggregationType = aggregationType;
				}
				return cellConfig;
			},

			/**
			 * Генерирует конфигурацию ячейки вертикального реестра
			 * @protected
			 * @param {Object} cellCaption заголовок ячейки
			 * @param {Object} cellValue значение ячейки
			 * @param {Object} colsCount ширина ячейки
			 * @return {Array} Возвращает конфигурацию ячейки вертикального реестра
			 */
			generateVerticalGridCellConfig: function(cellCaption, cellValue, colsCount) {
				var config = [];
				if (cellCaption) {
					var captionColsCount = parseInt(colsCount / 100 * 40, 10);
					config.push({cols: captionColsCount, key: [cellCaption]});
					colsCount -= captionColsCount;
				}
				if (cellValue) {
					config.push({cols: colsCount, key: [cellValue]});
				}
				return config;
			},

			/**
			 * Актуализирует списочную конфигурацию реестра старого типа, согласно новой
			 * @protected
			 * @param gridConfig Конфигурация реестра
			 */
			actualizeListedGridConfig: function(gridConfig) {
				var listedConfig = gridConfig.listedConfig;
				var listedConfigItems = listedConfig.items;
				var captionsConfig = this.generateGridCaptionsConfig(listedConfigItems);
				var columnsConfig = this.generateGridRowConfig(gridConfig, listedConfigItems);
				gridConfig.listedConfig = {
					captionsConfig: captionsConfig,
					columnsConfig: columnsConfig
				};
				this.addLinks(gridConfig.listedConfig, false);
			},

			/**
			 * Добавляет свойство link к колонкам
			 * @param gridConfig
			 * @param isTiled
			 */
			addLinks: function(gridConfig, isTiled) {
				gridConfig.columnsConfig.forEach(function(row) {
					if (!isTiled) {
						row = gridConfig.columnsConfig;
					}
					var viewModel = this.viewModelClass && this.viewModelClass.prototype ?
						this.viewModelClass.prototype :
						this.viewModelClass;
					var columns = viewModel.columns;
					var primaryDisplayColumnName = viewModel.entitySchema &&
						viewModel.entitySchema.primaryDisplayColumnName;
					Terrasoft.each(row, function(cell) {
						var item = Ext.isArray(cell) ? cell : [cell];
						Terrasoft.each(item, function(cellItem) {
							var itemKey = cellItem.key;
							var columnName;
							var columnType;
							Terrasoft.each(itemKey, function(element) {
								if (element && element.name && element.name.bindTo) {
									var keySplitter = "#";
									var columnKeySplittedArray = element.name.bindTo.split(keySplitter);
									columnName = columnKeySplittedArray[0];
									if (element.type) {
										columnType = element.type;
									}
								}
							}, this);
							var column = columns[columnName] || {};
							var entitySchema = viewModel.entitySchema || {};
							var moduleSchemaConfig = moduleUtils.getModuleStructureByName(entitySchema.name);
							if (moduleSchemaConfig && (primaryDisplayColumnName === columnName ||
								LinkColumnHelper.getIsLinkColumn(viewModel.entitySchema.name, columnName))) {
								cellItem.link = {bindTo: "on" + columnName + "LinkClick"};
							}
							var referenceSchemaName = column.referenceSchemaName;
							if (column.isLookup && referenceSchemaName) {
								var moduleStructure = moduleUtils.getModuleStructureByName(referenceSchemaName);
								var entityStructure = moduleUtils.getEntityStructureByName[referenceSchemaName];
								if (entityStructure && moduleStructure && Ext.isArray(entityStructure.pages) &&
									entityStructure.pages.length > 0) {
									cellItem.link = {bindTo: "on" + columnName + "LinkClick"};
								}
							}
							if (Ext.isEmpty(cellItem.link) && (columnType !== Terrasoft.GridKeyType.LINK)) {
								cellItem.link = {bindTo: "on" + columnName + "LinkClick"};
							}
						}, this);
					}, this);
					if (!isTiled) {
						return false;
					}
				}, this);
			},

			/**
			 * Актуализирует плиточную конфигурацию реестра старого типа, согласно новой
			 * @protected
			 * @param {Object} gridConfig Конфигурация реестра
			 */
			actualizeTiledGridConfig: function(gridConfig) {
				var tiledConfig = gridConfig.tiledConfig;
				var columnsConfig = [];
				var initialIndex = 1;
				var rowsCount = tiledConfig.grid.rows;
				for (var rowIndex = initialIndex; rowIndex < rowsCount + initialIndex; rowIndex++) {
					var columns = this.getGridRowColumns(tiledConfig, rowIndex);
					var rowConfig = this.generateGridRowConfig(gridConfig, columns);
					if (rowConfig.length) {
						columnsConfig.push(rowConfig);
					}
				}
				gridConfig.tiledConfig = {
					columnsConfig: columnsConfig
				};
				if (!gridConfig.isVertical) {
					this.addLinks(gridConfig.tiledConfig, true);
				}
			},

			/**
			 * Актуализирует конфигурацию реестра старого типа, согласно новой
			 * @protected
			 * @param {Object} config Конфигурация реестра
			 */
			actualizeGridConfig: function(config) {
				this.actualizeListedGridConfig(config);
				this.actualizeTiledGridConfig(config);
			},

			/**
			 * Генерирует конфигурацию представления для Terrasoft.ViewItemType.GRID
			 * @protected
			 * @virtual
			 * @param config Описание элемента представления
			 * @return {Object} Конфигурация реестра
			 */
			generateGrid: function(config) {
				var gridConfig = this.getDefaultGridConfig(config);
				var profile = this.schemaProfile[config.name];
				if (profile && profile.listedConfig && profile.tiledConfig) {
					if (profile.type) {
						config.type = profile.type;
					}
					config.listedConfig = Ext.decode(profile.listedConfig);
					config.tiledConfig = Ext.decode(profile.tiledConfig);
					this.actualizeGridConfig(config);
				} else if (profile && profile.listedColumnsConfig && profile.tiledColumnsConfig) {
					config.type = profile.isTiled ? Terrasoft.GridType.TILED : Terrasoft.GridType.LISTED;
					config.listedConfig = {
						columnsConfig: Ext.decode(profile.listedColumnsConfig),
						captionsConfig: Ext.decode(profile.captionsConfig)
					};
					config.tiledConfig = {
						columnsConfig:  Ext.decode(profile.tiledColumnsConfig)
					};
				} else {
					if (config.listedConfig && config.tiledConfig) {
						this.actualizeGridConfig(config);
					}
				}
				if (config.activeRowActions) {
					Terrasoft.each(config.activeRowActions, function(item) {
						item.markerValue = item.markerValue || item.caption;
					});
				}
				if (config.needLoadData) {
					config.watchRowInViewport = 2;
					config.watchedRowInViewport = config.needLoadData;
				}
				Ext.apply(gridConfig, this.getConfigWithoutServiceProperties(config, ["needLoadData"]));
				this.applyControlConfig(gridConfig, config);
				return gridConfig;
			},

			/**
			 * Генерирует конфигурацию представления для Terrasoft.ViewItemType.SCHEDULE_EDIT
			 * @protected
			 * @virtual
			 * @param {Object} config Конфигурация элемента представления
			 * @return {Object} Возвращает конфигурацию расписания
			 */
			generateScheduleEdit: function(config) {
				var className = "Terrasoft.ScheduleEdit";
				var result = {
					className: className,
					bottomPadding: this.defaultScheduleEditBottomPadding
				};
				Ext.apply(result, this.getConfigWithoutServiceProperties(config, []));
				this.applyControlConfig(result, config);
				return result;
			},

			/**
			 * Генерирует конфигурацию представления для кнопки выбора цвета {Terrasoft.ViewItemType.COLOR_BUTTON}
			 * @protected
			 * @virtual
			 * @param {Object} config Конфигурация кнопки цвета
			 * @return {Object} Возвращает сгенерированное представление кнопки цвета
			 */
			generateColorButton: function(config) {
				var id = this.getControlId(config, "Terrasoft.ColorButton");
				var result = {
					className: "Terrasoft.ColorButton",
					markerValue: config.name
				};
				this.applyControlId(result, config, id);
				Ext.apply(result, this.getConfigWithoutServiceProperties(config, []));
				this.applyControlConfig(result, config);
				return result;
			},

			/**
			 * Инициализирует внутренние параметры профиля и класса модели представления генератора.
			 * @protected
			 * @overridden
			 * @param {Object} config Конфигурация построения схемы.
			 */
			init: function(config) {
				this.callParent(arguments);
				var schema = config.schema;
				this.schemaProfile = schema.profile || [];
				this.viewModelClass = config.viewModelClass;
			},

			/**
			 * Синхронно генерирует часть представления.
			 * @param {Object} viewConfig Конфигурация представления.
			 * @param config
			 * @param {String} config.schemaName Имя схемы.
			 * @param {Class} config.viewModelClass Класс модели представления.
			 * @return {Object[]} Возвращает сгенерированное представление схемы.
			 */
			generatePartial: function(viewConfig, config) {
				this.init(config);
				if (this.schemaType === Terrasoft.SchemaType.EDIT_VIEW_MODEL_SCHEMA) {
					BusinessRulesApplier.applyRules(this.viewModelClass, viewConfig);
				}
				delete viewConfig.generator;
				var view = this.generateView([viewConfig]);
				this.clear();
				return view;
			},

			/**
			 * Очищает внутренние параметры профиля,
			 * пользовательских генераторов и класса модели представления генератора.
			 * @protected
			 * @overridden
			 */
			clear: function() {
				this.callParent(arguments);
				this.viewModelClass = null;
				this.customGenerators = null;
				this.schemaProfile = null;
			},

			/**
			 * Получает все схемы по иерархии и генерирует классы ViewModel.
			 * @overridden
			 * @param config
			 * @param {String} config.schemaName Имя схемы.
			 * @param {Class} config.viewModelClass Класс модели представления.
			 * @param {Function} callback Функция-callback.
			 * @param {Object} scope Контекст выполнения функции callback.
			 */
			generate: function(config, callback, scope) {
				var schema = config.schema;
				var combinedViewConfig = schema.viewConfig;
				this.callParent([config, function() {
					if (this.schemaType === Terrasoft.SchemaType.EDIT_VIEW_MODEL_SCHEMA) {
						BusinessRulesApplier.applyRules(this.viewModelClass, combinedViewConfig);
					}
					this.requireCustomGenerators(combinedViewConfig, function() {
						var viewConfig = this.generateView(combinedViewConfig);
						this.clear();
						callback.call(scope, viewConfig);
					}, this);
				}, this]);
			}
		});

		return Ext.create(viewGenerator);

	}
);


				// Autogenerated Code for schema ViewGeneratorV2 (End)
// Autogenerated Code for schema SchemaBuilderV2 (Start)
define('SchemaBuilderV2Resources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("SchemaBuilderV2", ["performancecountermanager", "ViewModelGeneratorV2", "ViewGeneratorV2",
		"ext-base", "terrasoft", "sandbox"],
	function(performanceManager) {

		// TODO: Логика определения какой класс генератора выбрать (при условии перекрытия генераторов)

		var schemaGenerator = Ext.define("Terrasoft.configuration.SchemaBuilder", {
			extend: "Terrasoft.BaseObject",
			alternateClassName: "Terrasoft.SchemaBuilder",

			/**
			 * Ссылка на объект ядра.
			 * @private
			 * @type {Object}
			 */
			core: require("core"),

			/**
			 * Префикс ключа профиля.
			 * @private
			 * @type {String}
			 */
			profilePrefix: "profile!",

			/**
			 * Суффикс модуля структуры схемы.
			 * @private
			 * @type {String}
			 */
			structureSuffix: "Structure",

			/**
			 * Суффикс модуля ресурсов схемы.
			 * @private
			 * @type {String}
			 */
			resourcesSuffix: "Resources",

			/**
			 * Экземпляр {Terrasoft.ViewModelGenerator} для генерации модели представления.
			 * @private
			 * @type {Terrasoft.ViewModelGenerator}
			 */
			viewModelGenerator: null,

			/**
			 * Экземпляр {Terrasoft.ViewGenerator} для генерации преддставления.
			 * @private
			 * @type {Terrasoft.ViewGenerator}
			 */
			viewGenerator: null,

			/**
			 * Генерирует конфигурацию представления схемы.
			 * @param {Object} schema Схема, для которой генерируется представление.
			 * @param {String[]} hierarchy Иерархия схем.
			 */
			generateViewConfig: function(schema, hierarchy) {
				var viewConfig = [];
				Terrasoft.each(hierarchy, function(schema) {
					viewConfig = this.applyViewDiff(viewConfig, schema.diff);
				}, this);
				schema.viewConfig = viewConfig;
			},

			/**
			 * Применяет пакет разницы на представление родительской схемы.
			 * @protected
			 * @param {Object[]} parentView Конфигурация представления родительской схемы.
			 * @param {Object[]} diff Пакет разницы. Представляет собой массив операций модификации родительской схемы.
			 * @return {Object[]} Возвращает структуру представления с примененным пакетом разницы.
			 */
			applyViewDiff: function(parentView, diff) {
				return Terrasoft.JsonApplier.applyDiff(parentView, diff);
			},

			/**
			 * Применяет пакет разницы, настроенный в элементе БП, на представление родительской схемы.
			 * @param {Object} schema Схема.
			 * @param {Object[]} customDiff Пакет разницы. Представляет собой массив операций модификации родительской
			 * схемы.
			 */
			applyCustomDiff: function(schema, customDiff) {
				if (!customDiff) {
					return;
				}
				schema.viewConfig = Terrasoft.JsonApplier.applyDiff(schema.viewConfig, customDiff);
			},

			/**
			 * Получает имя схемы по ее UId.
			 * @private
			 * @param {String} schemaUId.
			 * @return {String} schemaName.
			 */
			getParentSchemaNameByUId: function(schemaUId) {
				var result = "";
				Terrasoft.each(this.core.schemaModules, function(uId, name) {
					if (uId === schemaUId) {
						result = name;
						return false;
					}
					return true;
				});
				return result;
			},

			/**
			 * Возвращает через функцию обратного вызова схему.
			 * @static
			 * @param {String} schemaName Имя схемы.
			 * @param {Function} callback Функция обратного вызова.
			 * @param {Object} scope Контекст вызова callback-функции.
			 */
			getSchema: function(schemaName, callback, scope) {
				Terrasoft.require([schemaName], function(schema) {
					callback.call(scope, schema);
				}, this);
			},

			/**
			 * Возвращает через функцию обратного вызова структуру схемы.
			 * @static
			 * @param {String} schemaName Имя схемы.
			 * @param {Function} callback Функция обратного вызова.
			 * @param {Object} scope Контекст вызова callback-функции.
			 */
			getSchemaStructure: function(schemaName, callback, scope) {
				Terrasoft.require([schemaName + this.structureSuffix], function(structure) {
					callback.call(scope, structure);
				}, this);
			},

			/**
			 * Возвращает через функцию обратного вызова ресурсы схемы.
			 * @static
			 * @param {String} schemaName Имя схемы.
			 * @param {Function} callback Функция обратного вызова.
			 * @param {Object} scope Контекст вызова callback-функции.
			 */
			getSchemaResources: function(schemaName, callback, scope) {
				Terrasoft.require([schemaName + this.resourcesSuffix], function(resources) {
					callback.call(scope, resources);
				}, this);
			},

			/**
			 * Возвращает через функцию обратного вызова entity схему.
			 * @static
			 * @param {String} entitySchemaName Имя entity схемы.
			 * @param {Function} callback Функция обратного вызова.
			 * @param {Object} scope Контекст вызова callback-функции.
			 */
			getEntitySchema: function(entitySchemaName, callback, scope) {
				Terrasoft.require([entitySchemaName], function(entitySchema) {
					callback.call(scope, entitySchema);
				}, this);
			},

			/**
			 * Возвращает через функцию обратного вызова проффиль.
			 * @static
			 * @param {String} profileKey Ключ профиля.
			 * @param {Function} callback Функция обратного вызова.
			 * @param {Object} scope Контекст вызова callback-функции.
			 */
			getProfile: function(profileKey, callback, scope) {
				Terrasoft.require([this.profilePrefix + profileKey], function(profile) {
					callback.call(scope, profile);
				}, this);
			},

			/**
			 * Получает всю цепочку наследования схем.
			 * @private
			 * @param {Object} config
			 * @param {String} config.schemaName Название схемы.
			 * @param {Object} config.hierarchyStack Иерархия наследования схем.
			 * @param {Function} callback Функция обратного вызова.
			 * @param {Object} scope Область видимости.
			 */
			requireAllSchemaHierarchy: function(config, callback, scope) {
				var schemaName = config.schemaName;
				var isParent = config.isParent;
				var profileKey = config.profileKey;
				var hierarchy = config.hierarchyStack || [];
				var customAttributes = config.customAttributes;
				var entitySchemaName = config.entitySchemaName;
				var schema;
				var schemaResponse = config.schemaResponse;
				Terrasoft.chain(
					function(next) {
						if (!schemaResponse) {
							this.getSchema(schemaName, function(schemaResponse) {
								next(schemaResponse);
							}, this, isParent);
						} else {
							next(schemaResponse);
						}
					},
					function(next, schemaResponse) {
						schema = schemaResponse;
						if (customAttributes) {
							if (!schema.initialAttributes) {
								schema.initialAttributes = Ext.apply({}, schema.attributes);
							}
							schema.attributes = {};
							Ext.apply(schema.attributes, schema.initialAttributes);
							Ext.apply(schema.attributes, customAttributes);
						}
						if (entitySchemaName) {
							schema.entitySchemaName = entitySchemaName;
						}
						next();
					},
					function(next) {
						this.getSchemaResources(schemaName, function(resources) {
							schema.resources = resources;
							next();
						}, this, isParent);
					},
					function(next) {
						entitySchemaName = (entitySchemaName) ? entitySchemaName : schema.entitySchemaName;
						this.getEntitySchema(entitySchemaName, function(entitySchema) {
							schema.entitySchema = entitySchema;
							next();
						}, this, isParent);
					},
					function(next) {
						this.getProfile(profileKey, function(profile) {
							schema.profile = profile;
							next();
						}, this, isParent);
					},
					function() {
						this.getSchemaStructure(schemaName, function(structure) {
							schema.extendParent = structure.extendParent;
							schema.parentSchemaUId = structure.parentSchemaUId;
							schema.schemaName = structure.schemaName;
							schema.schemaCaption = structure.schemaCaption;
							schema.schemaUId = structure.schemaUId;
							schema.type = structure.type;
							hierarchy.unshift(schema);
							var parentSchemaName = structure.parentSchemaName;
							if (parentSchemaName) {
								var config = {
									schemaName: parentSchemaName,
									profileKey: profileKey,
									hierarchyStack: hierarchy,
									isParent: true
								};
								scope.requireAllSchemaHierarchy(config, callback, scope);
							} else {
								callback.call(scope, hierarchy);
							}
						}, this, isParent);
					},
					this
				);
			},

			/**
			 * Генерирует представление схемы.
			 * @override
			 * @param {Object} config Объект конфигурации.
			 * @param {Function} callback Функция обратного вызова.
			 * @param {Object} scope Область видимости.
			 */
			generateView: function(config, callback, scope) {
				this.viewGenerator.generate(config, function(viewConfig) {
					callback.call(scope, viewConfig);
				});
			},

			/**
			 * Генерирует модель представления схемы.
			 * @override
			 * @param {Object} config Объект конфигурации.
			 * @param {Function} callback Функция обратного вызова.
			 * @param {Object} scope Область видимости.
			 */
			generateViewModel: function(config, callback, scope) {
				this.viewModelGenerator.generate(config, function(viewModelClass) {
					callback.call(scope, viewModelClass);
				});
			},

			/**
			 * Создает экземпляр класса Terrasoft.ViewGenerator.
			 * @return {Terrasoft.ViewGenerator} Возвращает объект Terrasoft.ViewGenerator.
			 */
			createViewGenerator: function() {
				return Ext.create("Terrasoft.ViewGenerator");
			},

			/**
			 * Создает экземпляр класса Terrasoft.ViewModelGenerator.
			 * @return {Terrasoft.ViewModelGenerator} Возвращает объект Terrasoft.ViewModelGenerator.
			 */
			createViewModelGenerator: function() {
				return Ext.create("Terrasoft.ViewModelGenerator");
			},

			/**
			 * Генерирует структуру схемы. В случае, когда данные по запрашиваемому конфигу находятся в кэше,
			 * возвращает закэшированный результат. Используется кэш уровня страницы.
			 * @param {Object} config Конфигурация сборки схемы.
			 * @param {Function} callback Функция обратного вызова.
			 * @param {Object} scope Контекст вызова callback-функции.
			 */
			build: function(config, callback, scope) {
				var performanceManagerLabel = "";
				if (scope && scope.hasOwnProperty("sandbox")) {
					performanceManagerLabel = scope.sandbox.id;
				} else if (this && this.hasOwnProperty("sandbox")) {
					performanceManagerLabel = this.sandbox.id;
				}
				performanceManager.start(performanceManagerLabel + "_Build");
				var generatorConfig = Terrasoft.deepClone(config);
				generatorConfig.performanceManagerLabel = performanceManagerLabel;
				performanceManager.start(performanceManagerLabel + "_Build_requireAllSchemaHierarchy");
				if (config.useCache !== false) {
					if (generatorConfig.entitySchemaName) {
						if (!this.tryReturnCache(generatorConfig, callback, scope)) {
							this.buildSchemaHierarchy(generatorConfig, callback, scope);
						}
					} else {
						this.getSchema(config.schemaName, function(schemaResponse) {
							generatorConfig.entitySchemaName = schemaResponse.entitySchemaName;
							generatorConfig.schemaResponse = schemaResponse;
							if (!this.tryReturnCache(generatorConfig, callback, scope)) {
								this.buildSchemaHierarchy(generatorConfig, callback, scope);
							}
						}, this);
					}
				} else {
					this.buildSchemaHierarchy(generatorConfig, callback, scope);
				}
			},

			/**
			 * Ищет сохраненные данные в кэше. В случае, если данные найдены, завершает работу SchemaBuilder, вызывает
			 * функцию обратного вызова с найденными данными и возвращает true. Если данные не найдены,
			 * возвращает false.
			 * @param {Object} config Конфигурация сборки схемы.
			 * @param {Function} callback Функция обратного вызова.
			 * @param {Object} scope Контекст вызова callback-функции.
			 * @returns {Boolean} Результат поиска данных в кэше.
			 */
			tryReturnCache: function(config, callback, scope) {
				var result = false;
				var cacheItem = this.getCachedItem(config);
				if (cacheItem) {
					result = true;
					var performanceManagerLabel = config.performanceManagerLabel;
					performanceManager.stop(performanceManagerLabel + "_Build_requireAllSchemaHierarchy");
					performanceManager.start(performanceManagerLabel + "_Build_buildSchema");
					performanceManager.start(performanceManagerLabel + "_Build_buildSchema_generateViewModel");
					performanceManager.stop(performanceManagerLabel + "_Build_buildSchema_generateViewModel");
					performanceManager.start(performanceManagerLabel + "_Build_buildSchema_generateView");
					performanceManager.stop(performanceManagerLabel + "_Build_buildSchema_generateView");
					performanceManager.stop(performanceManagerLabel + "_Build_buildSchema");
					performanceManager.stop(performanceManagerLabel + "_Build");
					callback.call(scope, cacheItem.viewModelClass, cacheItem.view, cacheItem.schema);
				}
				return result;
			},

			/**
			 * Выполняет запрос всей цепочки наследования схемы и запускает процесс построения схемы
			 * (см. {@link #buildSchema}).
			 * @param {Object} config Конфигурация сборки схемы.
			 * @param {Function} callback Функция обратного вызова.
			 * @param {Object} scope Контекст вызова callback-функции.
			 */
			buildSchemaHierarchy: function(config, callback, scope) {
				this.requireAllSchemaHierarchy(config, function(hierarchy) {
					var schema = hierarchy[hierarchy.length - 1];
					Ext.apply(config, {
						hierarchy: hierarchy,
						schema: schema
					});
					performanceManager.stop(config.performanceManagerLabel + "_Build_requireAllSchemaHierarchy");
					performanceManager.start(config.performanceManagerLabel + "_Build_buildSchema");
					this.buildSchema(config, callback, scope);
				}, this);
			},

			/**
			 * По конфигу запроса схемы вовзвращает ключ кеширования.
			 * @param {Object} config Конфигурация сборки схемы.
			 * @returns {String} Ключ кэша.
			 */
			getCacheItemKey: function(config) {
				return [config.schemaName, config.entitySchemaName, config.profileKey].join("_");
			},

			/**
			 * Возвращает закэшированный вариант схемы, представления и модели представления схемы. В кэше не храниться
			 * класс модели представления, вместо него сохраняется имя класса. При получении закэшировнных данных, в
			 * менеджере классов проверяется наличие класса. Если класс найден, он возвращается, иначе кэш сбрасывается
			 * и возвращается нулевой результат.
			 * @param {Object} config Конфигурация сборки схемы.
			 * @return {Object} Объект кэша.
			 */
			getCachedItem: function(config) {
				var cache = this.getCache();
				if (!cache) {
					return null;
				}
				var cacheKey = this.getCacheItemKey(config);
				var cacheItem = cache.getItem(cacheKey);
				if (cacheItem) {
					var item = Terrasoft.deepClone(cacheItem);
					var viewModelClass = Ext.ClassManager.get(item.viewModelClassName);
					if (viewModelClass) {
						item.viewModelClass = viewModelClass;
						return item;
					}
					cache.removeItem(cacheKey);
				}
				return null;
			},

			/**
			 * Сохраняет в кэш схему, представление и имя класса модели представления схемы.
			 * @param {Object} config Конфигурация сборки схемы.
			 * @param {Object} item Кэшируемый объект.
			 */
			addToCaсhe: function(config, item) {
				var cache = this.getCache();
				if (cache) {
					var cacheKey = this.getCacheItemKey(config);
					cache.setItem(cacheKey, item);
				}
			},

			/**
			 * Возвращает объект кэша уровня странцы (MemoryCache).
			 * @returns {Terrasoft.MemoryStore}
			 */
			getCache: function() {
				return Terrasoft.ClientPageSessionCache;
			},

			/**
			 * Выполняет построение схемы по иерархии наследования схем.
			 * @param {Object} config Конфигурация построения схемы.
			 * @param {Function} callback Функция обратного вызова.
			 * @param {Object} scope Контекст вызова callback-функции.
			 */
			buildSchema: function(config, callback, scope) {
				var schema = config.schema;
				var hierarchy = config.hierarchy;
				this.viewModelGenerator = this.createViewModelGenerator();
				performanceManager.start(config.performanceManagerLabel + "_Build_buildSchema_generateViewModel");
				this.generateViewModel(config, function(viewModelClass) {
					this.generateViewConfig(schema, hierarchy);
					this.applyCustomDiff(schema, config.customDiff);
					var viewConfig = {
						schema: schema,
						viewModelClass: viewModelClass
					};
					if (config.viewGeneratorConfig) {
						Ext.apply(viewConfig, config.viewGeneratorConfig);
					}
					this.viewGenerator = this.createViewGenerator();
					performanceManager.stop(config.performanceManagerLabel + "_Build_buildSchema_generateViewModel");
					performanceManager.start(config.performanceManagerLabel + "_Build_buildSchema_generateView");
					this.generateView(viewConfig, function(view) {
						this.viewModelGenerator = null;
						this.viewGenerator = null;
						performanceManager.stop(config.performanceManagerLabel + "_Build_buildSchema_generateView");
						performanceManager.stop(config.performanceManagerLabel + "_Build_buildSchema");
						performanceManager.stop(config.performanceManagerLabel + "_Build");
						this.addToCaсhe(config, {
							view: Terrasoft.deepClone(view),
							//schema: Terrasoft.deepClone(schema),
							viewModelClassName: viewModelClass.$className
						});
						callback.call(scope, viewModelClass, view, schema);
					}, this);
				}, this);
			}

		});

		return Ext.create(schemaGenerator);

	});


				// Autogenerated Code for schema SchemaBuilderV2 (End)
// Autogenerated Code for schema BaseModule (Start)
define('BaseModuleResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("BaseModule", ["ext-base"], function(Ext) {

	/**
	 * @class Terrasoft.configuration.BaseModule
	 * Базовый класс модуля
	 */
	Ext.define("Terrasoft.configuration.BaseModule", {
		extend: "Terrasoft.BaseObject",
		alternateClassName: "Terrasoft.BaseModule",

		/**
		 * Идентификатор контейнера модуля.
		 * type {String}
		 */
		renderToId: null,

		/**
		 * Признак использования маски загрузки при загрузке модуля.
		 * type {Boolean}
		 */
		showMask: false,

		/**
		 * Идентификатор маски загрузки модуля.
		 * @private
		 * type {String}
		 */
		maskId: null,

		/**
		 * Параметры загрузки модуля.
		 * @type {Object}
		 * @protected
		 */
		parameters: null,

		/**
		 * Отображает маску загрузки модуля.
		 * @protected
		 */
		showLoadingMask: function() {
			if (this.showMask && this.renderToId) {
				this.maskId = Terrasoft.Mask.show({
					selector: Ext.String.format("#{0}", this.renderToId)
				});
			}
		},

		/**
		 * Скрывает маску загрузки модуля.
		 * @protected
		 */
		hideLoadingMask: function() {
			if (this.maskId && this.showMask) {
				Terrasoft.Mask.hide(this.maskId);
				this.maskId = null;
			}
		},

		/**
		 * @inheritDoc Terrasoft.core.BaseObject#init
		 * @overridden
		 */
		init: function() {
			this.showLoadingMask();
		},

		/**
		 * Запускает процесс рендеринга модуля.
		 */
		render: function() {
			this.hideLoadingMask();
		},

		/**
		 * @inheritDoc Terrasoft.core.BaseObject#onDestroy
		 * @overridden
		 */
		onDestroy: function() {
			this.hideLoadingMask();
			this.callParent(arguments);
		}

	});

	return Terrasoft.BaseModule;
});


				// Autogenerated Code for schema BaseModule (End)
// Autogenerated Code for schema BaseSchemaModuleV2 (Start)
define('BaseSchemaModuleV2Resources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("BaseSchemaModuleV2", ["performancecountermanager", "GoogleTagManagerUtilities", "SchemaBuilderV2", "BaseModule"],
	function(performanceManager, GoogleTagManagerUtilities) {

	/**
	 * @class Terrasoft.configuration.BaseSchemaModule
	 * Базовый класс конфигурационного модуля.
	 */
	Ext.define("Terrasoft.configuration.BaseSchemaModule", {
		extend: "Terrasoft.BaseModule",
		alternateClassName: "Terrasoft.BaseSchemaModule",

		Ext: null,
		sandbox: null,
		Terrasoft: null,

		/**
		 * Признак того, что параметры схемы установлены извне.
		 * @public
		 * @type {Boolean}
		 */
		isSchemaConfigInitialized: false,

		/**
		 * Признак того, что при загрузке модуля используется состояние истории.
		 * @public
		 * @type {Boolean}
		 */
		useHistoryState: true,

		/**
		 * Название схемы отображаемой сущности
		 * @protected
		 * @type {String}
		 */
		schemaName: "",

		/**
		 * Суффикс контейнера модуля
		 * @private
		 * @type {String}
		 */
		autoGeneratedContainerSuffix: "Container",

		/**
		 * Признак того, что модуль инциализируется асинхронно
		 * @private
		 * @type {Boolean}
		 */
		isAsync: true,

		/**
		 * Экземпляр {Terrasoft.SchemaBuilder} для генерации представления и модели представления по иерархии страниц
		 * @private
		 * @type {Terrasoft.SchemaBuilder}
		 */
		schemaBuilder: null,

		/**
		 * Признак того, что для контейнера представления модуля необходимо генерировать идентификатор.
		 * @protected
		 * @type {Boolean}
		 */
		generateViewContainerId: true,

		/**
		 * Инициализирует название схемы
		 * @protected
		 * @virtual
		 */
		initSchemaName: function() {
			var historyState = this.sandbox.publish("GetHistoryState");
			var hash = historyState.hash;
			var state = historyState.state;
			this.schemaName = state.cardSchemaName || hash.entityName || "";
		},

		/**
		 * Заменяет последний элемент в цепочке состояний, если его идентификатор модуля отличается от текущего
		 * @protected
		 * @virtual
		 */
		initHistoryState: function() {
			var sandbox = this.sandbox;
			var state = sandbox.publish("GetHistoryState");
			var currentHash = state.hash;
			var currentState = state.state || {};
			if (currentState.moduleId === sandbox.id) {
				return;
			}
			var newState = this.prepareHistorySate(currentState);
			sandbox.publish("ReplaceHistoryState", {
				stateObj: newState,
				pageTitle: null,
				hash: currentHash.historyState,
				silent: true
			});
		},

		/**
		 * Подготавливает новое состояние страницы
		 * @protected
		 * @virtual
		 * @return {Object} Возвращает новое состояние страницы
		 */
		prepareHistorySate: function(currentState) {
			var newState = this.Terrasoft.deepClone(currentState);
			newState.moduleId = this.sandbox.id;
			return newState;
		},

		/**
		 * Получает ключ профиля
		 * @return {String} Возращает ключ профиля
		 */
		getProfileKey: function() {
			return this.schemaName;
		},

		/**
		 * Генерирует класс для текущей схемы, классы родителей, представление
		 * @private
		 * @param {Function} callback Эта функция будет вызвана после генерации. Входящими параметрами будут класс
		 * схемы, структура представления
		 * @param {Object} scope Контекст вызова callback-функции
		 */
		generateSchemaStructure: function(callback, scope) {
			var config = {
				schemaName: this.schemaName,
				entitySchemaName: this.entitySchemaName,
				profileKey: this.getProfileKey()
			};
			this.schemaBuilder.build(config, function(viewModelClass, viewConfig) {
				callback.call(scope, viewModelClass, viewConfig);
			}, this);
		},

		/**
		 * Инициализация состояние, названия схемы, генерирует класс модели представления и представление.
		 * После этого создает и инициализирует экземпляр представления
		 * @param {Function} callback Функция, которая будет вызвана по завершению
		 * @param {Object} scope Контекст, в котором будет вызвана функция callback
		 * @virtual
		 */
		init: function(callback, scope) {
			callback = callback || function() {};
			if (this.viewModel) {
				this.viewModel.set("Restored", true);
				callback.call(scope);
				return;
			}
			this.schemaBuilder = this.Ext.create("Terrasoft.SchemaBuilder");
			if (this.useHistoryState) {
				this.initHistoryState();
			}
			if (!this.isSchemaConfigInitialized) {
				this.initSchemaName();
			}

			GoogleTagManagerUtilities.actionModule({
				virtualUrl: this.Terrasoft.workspaceBaseUrl + "/" + this.sandbox.id,
				moduleName: this.schemaName,
				currentAction: this.operation,
				primaryColumnValue: this.primaryColumnValue,
				typeModule : this.getViewModelConfig().sandbox.moduleName
			});

			this.generateSchemaStructure(function(viewModelClass, viewConfig) {
				if (this.destroyed) {
					return;
				}
				this.viewModelClass = viewModelClass;
				this.viewConfig = viewConfig;
				var viewModel = this.viewModel = this.createViewModel(viewModelClass);
				viewModel.init(function() {
					if (!this.destroyed) {
						callback.call(scope);
					}
				}, this);
			}, this);
		},

		/**
		 * Возвращает объект настроек модели представления.
		 * @protected
		 * @virtual
		 * @return {Object} Возвращает объект настроек модели представления.
		 */
		getViewModelConfig: function() {
			var viewModelConfig = {
				Ext: this.Ext,
				sandbox: this.sandbox,
				Terrasoft: this.Terrasoft
			};
			return viewModelConfig;
		},

		/**
		 * Создает модель представления
		 * @protected
		 * @virtual
		 * @param {Object} viewModelClass Класс модели представления схемы
		 * @return {Object} Возвращает экземпляр модели представления схемы
		 */
		createViewModel: function(viewModelClass) {
			var viewModelConfig = this.getViewModelConfig();
			return this.Ext.create(viewModelClass, viewModelConfig);
		},

		/**
		 * Возвращает идентификатор контейнера представления модуля.
		 * @protected
		 * @virtual
		 * @return {String} Идентификатор контейнера представления модуля.
		 */
		getViewContainerId: function() {
			return this.schemaName + this.autoGeneratedContainerSuffix;
		},

		/**
		 * Возвращает конфигурацию представления модуля.
		 * @protected
		 * @virtual
		 * @return {Object} Конфигурация представления модуля.
		 */
		getViewConfig: function() {
			var containerId = this.getViewContainerId();
			var viewConfig = {
				classes: {wrapClassName: ["schema-wrap", "one-el"]},
				items: this.Terrasoft.deepClone(this.viewConfig),
				markerValue: containerId
			};
			if (this.generateViewContainerId !== false) {
				this.Ext.apply(viewConfig, {
					id: containerId,
					selectors: {wrapEl: "#" + containerId}
				});
			}
			return viewConfig;
		},

		/**
		 * Отображение представления
		 * @param {Ext.Element} renderTo Ссылка на контейнер, в котором будет отображаться представление.
		 */
		render: function(renderTo) {
			var viewModel = this.viewModel;
			var view = this.view;
			if (!view || view.destroyed) {
				var viewConfig = this.getViewConfig();
				view = this.view = this.Ext.create("Terrasoft.Container", viewConfig);
				view.bind(viewModel);
				performanceManager.stop(this.sandbox.id + "_BeforeRender");
				performanceManager.start(this.sandbox.id + "_Render");
				view.render(renderTo);
			} else {
				performanceManager.stop(this.sandbox.id + "_BeforeRender");
				performanceManager.start(this.sandbox.id + "_Render");
				view.reRender(0, renderTo);
			}
			viewModel.renderTo = renderTo.id;
			performanceManager.stop(this.sandbox.id + "_Render");
			viewModel.onRender();
		},

		/**
		 * Очищает все подписки на события и уничтожает объект.
		 * @overridden
		 * @param {Object} config Параметры уничтожения модуля
		 */
		destroy: function(config) {
			if (config.keepAlive !== true) {
				if (this.viewModel) {
					this.viewModel.destroy();
					this.viewModel = null;
				}
				if (this.schemaBuilder) {
					this.schemaBuilder = null;
				}
				this.callParent(arguments);
			}
		}
	});

	return Terrasoft.BaseSchemaModule;
});


				// Autogenerated Code for schema BaseSchemaModuleV2 (End)
// Autogenerated Code for schema ServiceHelper (Start)
define('ServiceHelperResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("ServiceHelper", ["ext-base", "terrasoft"], function(Ext, Terrasoft) {

	/**
	 * Вызывает метод веб-сервиса.
	 * @param {String|Object} config Имя сервиса или параметры вызова сервиса.
	 * @param {String} methodName Имя метода.
	 * @param {Function} callback (optional) Функция обратного вызова.
	 * @param {Object} data (optional) Объект с данными запроса.
	 * @param {Object} scope (optional) Контекст вызова.
	 * @returns {Object} Экземпляр запроса.
	 */
	function internalCallService(config, methodName, callback, data, scope) {
		var serviceName;
		if (config && Ext.isObject(config)) {
			serviceName = config.serviceName;
			methodName = config.methodName;
			callback = config.callback;
			data = config.data;
			scope = config.scope;
		} else {
			serviceName = config;
		}
		var dataSend = data || {};
		var requestUrl = Terrasoft.workspaceBaseUrl + "/rest/" + serviceName + "/" + methodName;
		var requestConfig = {
			url: requestUrl,
			headers: {
				"Accept": "application/json",
				"Content-Type": "application/json"
			},
			method: "POST",
			jsonData: Ext.encode(dataSend),
			callback: function(request, success, response) {
				if (!callback) {
					return;
				}
				var responseObject = response;
				if (success) {
					responseObject = Terrasoft.decode(response.responseText);
				}
				callback.call(this, responseObject, success);
			},
			scope: scope || this
		};
		if (config && config.timeout) {
			requestConfig.timeout = config.timeout;
		}
		return Terrasoft.AjaxProvider.request(requestConfig);
	}

	return {
		callService: internalCallService
	};
});

				// Autogenerated Code for schema ServiceHelper (End)
// Autogenerated Code for schema ConfigurationConstants (Start)
define('ConfigurationConstantsResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={
	ContactPhone: 'Рабочий телефон',
	MobilePhone: 'Мобильный телефон',
	HomePhone: 'Домашний телефон',
	Skype: 'Skype',
	Email: 'E-mail',
	Facebook: 'Facebook',
	LinkedIn: 'LinkedIn',
	Twitter: 'Twitter',
	Web: 'Web',
	Fax: 'Факс',
	AccountPhone: 'Основной телефон',
	AdditionalPhone: 'Дополнительный телефон',
	PositiveVisaStatus: 'Положительная',
	NegativeVisaStatus: 'Отрицательная'
};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("ConfigurationConstants", ["ConfigurationConstantsResources"], function(resources) {

	var activity = {
		Type: {
			Task: "fbe0acdc-cfc0-df11-b00f-001d60e938c6",
			Email: "e2831dec-cfc0-df11-b00f-001d60e938c6",
			Call: "e1831dec-cfc0-df11-b00f-001d60e938c6"
		},
		ActivityCategory: {
			DoIt: "f51c4643-58e6-df11-971b-001d60e938c6",
			Email: "8038a396-7825-e011-8165-00155d043204",
			Call: "e52bd583-7825-e011-8165-00155d043204",
			Meeting: "42c74c49-58e6-df11-971b-001d60e938c6"
		},
		ResultCategory: {
			Neutral: "4fd40914-23a7-415d-bb56-14fed5092551",
			Fail: "4db33cbc-ba7c-4103-9887-6b39b8d36b77"
		},
		Status: {
			NotStarted: "384d4b84-58e6-df11-971b-001d60e938c6",
			Cancel: "201cfba8-58e6-df11-971b-001d60e938c6",
			Done: "4bdbb88f-58e6-df11-971b-001d60e938c6",
			InProgress: "394d4b84-58e6-df11-971b-001d60e938c6"
		},
		EmailSendStatus: {
			NotSended: "20c0c460-6107-e011-a646-16d83cab0980",
			Sended: "8074ffc0-6107-e011-a646-16d83cab0980"
		},
		MessageType: {
			Incoming: "7f9d1f86-f36b-1410-068c-20cf30b39373",
			Outgoing: "7f6d3f94-f36b-1410-068c-20cf30b39373"
		},
		ParticipantRole: {
			From: "6a6390c4-a6e1-df11-971b-001d60e938c6",
			To: "3a6893ce-a6e1-df11-971b-001d60e938c6",
			CC: "3c6893ce-a6e1-df11-971b-001d60e938c6",
			BCC: "ba1a7add-a6e1-df11-971b-001d60e938c6",
			Participant: "1a8324e8-a6e1-df11-971b-001d60e938c6",
			Responsible: "53fc4a92-b0ea-e111-96c4-00165d094c12"
		}
	};

	var opportunity = {
		CloseReason: {
			DefeatedRival: "e45a0188-5be6-df11-971b-001d60e938c6"
		},
		Stage: {
			DeterminationOfPotential: "c2067b11-0ee0-df11-971b-001d60e938c6",
			PreparingQuotation: "241ade6b-4256-4947-ba8a-7d96988a97b6",
			PresentationQuotation: "423774cb-5ae6-df11-971b-001d60e938c6",
			RejectedByUs: "736f54fd-e240-46f8-8c7c-9066c30aff59",
			TranslationIntoAnotherProcess: "9abf243c-fc00-45cf-8E28-cdb66c9208b0",
			FinishedWithLoss: "a9aafdfe-2242-4f42-8cd5-2ae3b9556d79"
		},
		Type: {
			PartnerSale: "c4505efc-6cf5-4b0c-b984-55076bc235f0"
		}
	};

	var adresses = {
		ForContact: [{
			value: "4f8b2d67-71d0-45fb-897e-cd4a308a97c0",
			displayValue: "Домашний"
		}, {
			value: "760bf68c-4b6e-df11-b988-001d60e938c6",
			displayValue: "Доставки"
		}],
		ForAccount: [{
			value: "760bf68c-4b6e-df11-b988-001d60e938c6",
			displayValue: "Доставки"
		}, {
			value: "770bf68c-4b6e-df11-b988-001d60e938c6",
			displayValue: "Юридический"
		}, {
			value: "780bf68c-4b6e-df11-b988-001d60e938c6",
			displayValue: "Фактический"
		}]
	};

	var addressTypes = {
		Delivery: {
			value: "760bf68c-4b6e-df11-b988-001d60e938c6",
			displayValue: "Доставки"
		},
		Home: {
			value: "4f8b2d67-71d0-45fb-897e-cd4a308a97c0",
			displayValue: "Домашний"
		},
		Legal: {
			value: "770bf68c-4b6e-df11-b988-001d60e938c6",
			displayValue: "Юридический"
		},
		Actual: {
			value: "780bf68c-4b6e-df11-b988-001d60e938c6",
			displayValue: "Фактический"
		}
	};

	var communicationTypes = {
		Facebook: "2795dd03-bacf-e011-92c3-00155d04c01d",
		LinkedIn: "ea0f3b0a-bacf-e011-92c3-00155d04c01d",
		Google: "efe5d7a2-5f38-e111-851e-00155d04c01d",
		Twitter: "e7139487-bad3-e011-92c3-00155d04c01d",
		Phone: "3dddb3cc-53ee-49c4-a71f-e9e257f59e49",
		MainPhone: "6a3fb10c-67cc-df11-9b2a-001d60e938c6",
		AdditionalPhone: "2b387201-67cc-df11-9b2a-001d60e938c6",
		MobilePhone: "d4a2dc80-30ca-df11-9b2a-001d60e938c6",
		HomePhone: "0da6a26b-d7bc-df11-b00f-001d60e938c6",
		InnerPhone: "e9d91e45-8d92-4e38-95a0-ef8aa28c9e7a",
		Fax: "9a7ab41b-67cc-df11-9b2a-001d60e938c6",
		Web: "6a8ba927-67cc-df11-9b2a-001d60e938c6",
		Email: "ee1c85c3-cfcb-df11-9b2a-001d60e938c6"
	};

	var socialNetworksCommunicationTypes = [
		communicationTypes.Facebook,
		communicationTypes.LinkedIn,
		communicationTypes.Google,
		communicationTypes.Twitter
	];
	var phonesCommunicationTypes = [
		communicationTypes.Phone,
		communicationTypes.MobilePhone,
		communicationTypes.HomePhone,
		communicationTypes.MainPhone,
		communicationTypes.AdditionalPhone,
		communicationTypes.Fax
	];

	var communications = {
		UseForContacts: {
			Predefined: {
				Phone: {
					displayValue: resources.localizableStrings.ContactPhone,
					value: "3dddb3cc-53ee-49c4-a71f-e9e257f59e49"
				},
				MobilePhone: {
					displayValue: resources.localizableStrings.MobilePhone,
					value: "d4a2dc80-30ca-df11-9b2a-001d60e938c6"
				},
				HomePhone: {
					displayValue: resources.localizableStrings.HomePhone,
					value: "0da6a26b-d7bc-df11-b00f-001d60e938c6"
				},
				Skype: {
					displayValue: resources.localizableStrings.Skype,
					value: "09e4bda6-cfcb-df11-9b2a-001d60e938c6"
				},
				Email: {
					displayValue: resources.localizableStrings.Email,
					value: "ee1c85c3-cfcb-df11-9b2a-001d60e938c6"
				}
			},
			Socials: {
				Facebook: {
					displayValue: resources.localizableStrings.Facebook,
					value: "2795dd03-bacf-e011-92c3-00155d04c01d"
				},
				LinkedIn: {
					displayValue: resources.localizableStrings.LinkedIn,
					value: "ea0f3b0a-bacf-e011-92c3-00155d04c01d"
				},
				Twitter: {
					displayValue: resources.localizableStrings.Twitter,
					value: "e7139487-bad3-e011-92c3-00155d04c01d"
				}
			},
			Other: {
				Web: {
					displayValue: resources.localizableStrings.Web,
					value: "6a8ba927-67cc-df11-9b2a-001d60e938c6"
				},
				Fax: {
					displayValue: resources.localizableStrings.Fax,
					value: "9a7ab41b-67cc-df11-9b2a-001d60e938c6"
				}
			}
		},
		UseForAccounts: {
			Predefined: {
				Phone: {
					displayValue: resources.localizableStrings.AccountPhone,
					value: "6a3fb10c-67cc-df11-9b2a-001d60e938c6"
				},
				AdditionalPhone: {
					displayValue: resources.localizableStrings.AdditionalPhone,
					value: "2b387201-67cc-df11-9b2a-001d60e938c6"
				},
				Fax: {
					displayValue: resources.localizableStrings.Fax,
					value: "9a7ab41b-67cc-df11-9b2a-001d60e938c6"
				},
				Web: {
					displayValue: resources.localizableStrings.Web,
					value: "6a8ba927-67cc-df11-9b2a-001d60e938c6"
				}
			},
			Socials: {
				Facebook: {
					displayValue: resources.localizableStrings.Facebook,
					value: "2795dd03-bacf-e011-92c3-00155d04c01d"
				},
				LinkedIn: {
					displayValue: resources.localizableStrings.LinkedIn,
					value: "ea0f3b0a-bacf-e011-92c3-00155d04c01d"
				},
				Twitter: {
					displayValue: resources.localizableStrings.Twitter,
					value: "e7139487-bad3-e011-92c3-00155d04c01d"
				}
			},
			Other: {
				Email: {
					displayValue: resources.localizableStrings.Email,
					value: "ee1c85c3-cfcb-df11-9b2a-001d60e938c6"
				},
				Web: {
					displayValue: resources.localizableStrings.Web,
					value: "6a8ba927-67cc-df11-9b2a-001d60e938c6"
				},
				Fax: {
					displayValue: resources.localizableStrings.Fax,
					value: "9a7ab41b-67cc-df11-9b2a-001d60e938c6"
				},
				Phone: {
					displayValue: resources.localizableStrings.AccountPhone,
					value: "6a3fb10c-67cc-df11-9b2a-001d60e938c6"
				},
				AdditionalPhone: {
					displayValue: resources.localizableStrings.AdditionalPhone,
					value: "2b387201-67cc-df11-9b2a-001d60e938c6"
				}
			}
		}
	};

	var communication = {
		"Email": "ea350dd6-66cc-df11-9b2a-001d60e938c6",
		"Phone": "e037f25a-d7bc-df11-b00f-001d60e938c6",
		"Skype": "cae7d7c9-66cc-df11-9b2a-001d60e938c6",
		"SMS": "a09511b4-13f0-e011-a86b-00155d04c01d",
		"SocialNetwork": "ba75f995-aebe-e011-bc15-00155d04c01b",
		"Web": "cadd142e-4b2d-e011-ac0a-00155d043205"
	};

	var contactType = {
		Contact: "806732ee-f36b-1410-a883-16d83cab0980",
		Client: "00783ef6-f36b-1410-a883-16d83cab0980",
		Employee: "60733efc-f36b-1410-a883-16d83cab0980"
	};

	var document = {
		Type: {
			Contract: "39b28624-98e6-df11-971b-001d60e938c6",
			Act: "61f7a573-52e6-df11-971b-001d60e938c6",
			Correspondence: "2cb5cac1-1523-e011-a94a-00155d043204"
		},
		Status: {
			Plans: "0226b053-52e6-df11-971b-001d60e938c6",
			Underway: "09ee1344-52e6-df11-971b-001d60e938c6",
			Registred: "7e7f1202-f46b-1410-c686-0026185bfcd3"
		}
	};

	var lead = {
		Status: {
			New: "bd3511f8-f36b-1410-4493-1c6f65e16a07",
			QualifiedAsNew: "7d372f02-f46b-1410-4593-1c6f65e16a07",
			QualifiedAsExisting: "7d3f3116-f46b-1410-4693-1c6f65e16a07",
			QualifiedAsLost: "fd3d301e-f46b-1410-4693-1c6f65e16a07",
			QualifiedAsNoConnection: "7d3d1124-f46b-1410-4693-1c6f65e16a07",
			QualifiedAsNotInterested: "3db90f2a-f46b-1410-4693-1c6f65e16a07"
		}
	};

	var fileType = {
		File: "529bc2f8-0ee0-df11-971b-001d60e938c6",
		Link: "539bc2f8-0ee0-df11-971b-001d60e938c6",
		EntityLink: "549bc2f8-0ee0-df11-971b-001d60e938c6"
	};

	var folder = {
		Type: {
			Search: "65ca0946-0084-4874-b117-c13199af3b95",
			General: "9dc5f6e6-2a61-4de8-a059-de30f4e74f24",
			Recent: "c01ffb44-7407-e011-a646-16d83cab0980",
			RootEmail: "6e23fa26-5bee-e011-a86b-00155d04c01d",
			Duplicates: "10794494-d2dd-e011-92c3-00155d04c01d",
			SubEmail: "b97a5836-1cd0-e111-90c6-00155d054c03",
			MailBox: "99c2351c-f0f8-e111-9dba-00155d051801",
			Favorite: "80c0c97d-51a7-4e32-a89e-d5f827705be4"
		}
	};

	var dashboard = {
		Type: {
			OpportunityByCategory: "06586cdc-8e74-4732-a58a-89764054676c",
			AwaitingPayment: "317c0b3b-8874-4b0c-acc0-02792f24b8db",
			ActivityByOpportunityStage: "e29c6a10-405a-4e1e-9813-972a06e05986",
			OverdueActivities: "e29c6a10-405a-4e1e-9813-962a06e05986"
		}
	};

	var sysAdminUnit = {
		Id: {
			SysAdministrators: "83a43ebc-f36b-1410-298d-001e8c82bcad",
			AllEmployees: "a29a3ba5-4b0d-de11-9a51-005056c00008",
			PortalUsers: "720b771c-e7a7-4f31-9cfb-52cd21c3739f"
		},
		Type: {
			Organisation: 0,
			Department: 1,
			Manager: 2,
			Team: 3,
			User: 4,
			SSPUser: 5,
			FuncRole: 6
		},
		TypeGuid: {
			Organisation: "df93dcb9-6bd7-df11-9b2a-001d60e938c6",
			Department: "b659f1c0-6bd7-df11-9b2a-001d60e938c6",
			Manager: "b759f1c0-6bd7-df11-9b2a-001d60e938c6",
			Team: "462e97c7-6bd7-df11-9b2a-001d60e938c6",
			User: "472e97c7-6bd7-df11-9b2a-001d60e938c6",
			SSPUser: "f4044c41-df2b-e111-851e-00155d04c01d",
			FuncRole: "625aca96-0293-4ab4-b7b1-37c9a6a42fed"
		},
		ConnectionType: {
			AllEmployees: 0,
			PortalUsers: 1
		},
		SysLicType: {
			Personal: 0,
			Competitive: 1,
			Server: 2
		}
	};

	var userType = {
		GENERAL: 0,
		SSP: 1,
		VIRTUAL: 2
	};

	var sysProcess = {
		Status: {
			Performed: "ed2ae277-b6e2-df11-971b-001d60e938c6",
			Error: "f942c08d-b6e2-df11-971b-001d60e938c6",
			Completed: "815c9586-b6e2-df11-971b-001d60e938c6",
			Canceled: "1be78f3e-234d-4d6a-869a-dc07253fd2f3"
		},
		BusinessProcessTag: "Business Process"
	};

	var communicationType = {
		Email: "EE1C85C3-CFCB-DF11-9B2A-001D60E938C6",
		Google: "efe5d7a2-5f38-e111-851e-00155d04c01d"
	};

	var contactFolder = {
		All: "F35A1295-DCA5-DF11-831A-001D60E938C6"
	};

	var emailFolder = {
		Root: "181F9D34-5DEE-E011-A86B-00155D04C01D"
	};

	var entitySchemaQuery = {
		ColumnKeySplitter: "#"
	};

	var aggregationType = {
		sum: "9baf22e6-f36b-1410-3890-00059a3c7800",
		count: "de9f12a4-f36b-1410-3590-00059a3c7800"
	};

	var processLog = {
		sysProcessLogViewPageId: "fc771f06-fa62-4782-9b01-b858e86266f3"
	};

	var visaStatus = {
		positive: {
			displayValue: resources.localizableStrings.PositiveVisaStatus,
			value: "e79facb3-3c32-43e7-a59e-12ba125e6132"
		},
		negative: {
			displayValue: resources.localizableStrings.NegativeVisaStatus,
			value: "a93ab0b9-ca36-4b95-9b23-e01aa169c338"
		}
	};

	var PackageUId = {
		Platform: "3218E5EC-25C1-472B-9DE0-1673E071A79F"
	};

	var ESN = {
		SocialChannelSchemaUId: "dd74c060-eb4b-4f15-b381-db91ca5ac483"
	};

	var sysSchema = {
		ActivityFile: "080C9917-7EC9-42E5-86FF-75A683D4F124"
	};

	var sysCulture = {
		RUS: "1A778E3F-0A8E-E111-84A3-00155D054C03",
		ENU: "A5420246-0A8E-E111-84A3-00155D054C03"
	};

	var buildType = {
		Public: "e45eb864-59cc-4325-8276-d85e1ba90c95"
	};

	var fileSystemTypes = {
		Temporary: "temporary",
		Persistent: "persistent"
	};

	var supplyPayment = {
		FromPlan: "6fc58059-9c4a-4481-8775-bbadf4a4ad51",
		FromFact: "eeada309-2ce7-413c-8b66-e984242a4d22",
		Fixed: "b664126f-211f-44a1-acd8-6d9d8a1601c7",
		StateFinished: "e9eb323c-b1ed-4b4b-8dd9-414ad95075d3",
		TypeSupply: "e6d0464d-ef2d-467e-bd73-816b8fab764f"
	};

	var accountType = {
		Client: "03A75490-53E6-DF11-971B-001D60E938C6",
		Partner: "F2C0CE97-53E6-DF11-971B-001D60E938C6",
		Contractor: "F3C0CE97-53E6-DF11-971B-001D60E938C6",
		Provider: "D34B9DA2-53E6-DF11-971B-001D60E938C6",
		Competitor: "D44B9DA2-53E6-DF11-971B-001D60E938C6",
		OurCompany: "57412FAD-53E6-DF11-971B-001D60E938C6"
	};

	var contractType = {
		Contract: "42B49A15-1D6C-4FA3-B24A-45711BA90CB3",
		SubAgreement: "4AD8D1D2-8D39-4B54-8017-AFEC75DCD9C3",
		Act: "392753BA-CF2C-4BF8-B679-8F9AEF4B1C14"
	};

	var contextHelp = {
		StaticFolderHelpPageId: 1066,
		StaticFolderHelpPageCode: "StaticFolder"
	};

	var defaultHomeModule = "IntroPage";

	var relationType = {
		HeadCompany: "1ed655f3-5fe6-df11-971b-001d60e938c6",
		Subsidiary: "fb3a75d3-5fe6-df11-971b-001d60e938c6"
	};

	var columnImage = {
		Contact: "880a6888-1b05-4b56-b665-f6bd9385cfbe",
		Account: "b5cbd10f-32ce-4ac3-bb01-7a9eef7b66e4"
	};

	var anniversaryType = {
		"Birthday": "173d56d2-fdca-df11-9b2a-001d60e938c6"
	};

	return {
		AccountType: accountType,
		Activity: activity,
		Addresses: adresses,
		AddressTypes: addressTypes,
		AggregationType: aggregationType,
		CommunicationTypes: communicationTypes,
		SocialNetworksCommunicationTypes: socialNetworksCommunicationTypes,
		PhonesCommunicationTypes: phonesCommunicationTypes,
		CommunicationType: communicationType,
		Communications: communications,
		Communication: communication,
		ContactFolder: contactFolder,
		ContactType: contactType,
		Dashboard: dashboard,
		Document: document,
		EmailFolder: emailFolder,
		EntitySchemaQuery: entitySchemaQuery,
		FileType: fileType,
		Folder: folder,
		Lead: lead,
		Opportunity: opportunity,
		ProcessLog: processLog,
		UserType: userType,
		SysAdminUnit: sysAdminUnit,
		SysProcess: sysProcess,
		VisaStatus: visaStatus,
		PackageUId: PackageUId,
		ESN: ESN,
		SysSchema: sysSchema,
		SysCulture: sysCulture,
		BuildType: buildType,
		FileSystemTypes: fileSystemTypes,
		SupplyPayment: supplyPayment,
		ContractType: contractType,
		ContextHelp: contextHelp,
		DefaultHomeModule: defaultHomeModule,
		RelationType: relationType,
		ColumnImage: columnImage,
		AnniversaryType: anniversaryType
	};
});


				// Autogenerated Code for schema ConfigurationConstants (End)
// Autogenerated Code for schema RemindingsUtilities (Start)
define('RemindingsUtilitiesResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("RemindingsUtilities", ["ext-base", "terrasoft", "Reminding", "ServiceHelper"],
	function(Ext, Terrasoft, Reminding, ServiceHelper) {
		function remindingFilters() {
			var filters = Terrasoft.createFilterGroup();
			var currentContactId = Terrasoft.core.enums.SysValue.CURRENT_USER_CONTACT.value;
			filters.addItem(Terrasoft.createColumnFilterWithParameter(Terrasoft.ComparisonType.EQUAL,
				"Contact", currentContactId));
			filters.addItem(Terrasoft.createColumnFilterWithParameter(Terrasoft.ComparisonType.LESS_OR_EQUAL,
				"RemindTime", new Date(Ext.Date.now())));
			var workspaceIdFilter = Terrasoft.createColumnFilterWithParameter(Terrasoft.ComparisonType.EQUAL,
				"SysEntitySchema.SysWorkspace.Id", Terrasoft.SysValue.CURRENT_WORKSPACE.value);
			filters.add("workspaceIdFilter", workspaceIdFilter);

			// Activity
			var existFilterActivity = Ext.create("Terrasoft.CompareFilter", {
				comparisonType: Terrasoft.ComparisonType.EQUAL,
				leftExpression: Ext.create("Terrasoft.SubQueryExpression", {
					columnPath: "[Activity:Id:SubjectId].Id",
					aggregationType: Terrasoft.AggregationType.COUNT
				}),
				rightExpression: Ext.create("Terrasoft.ParameterExpression", { parameterValue: 0 })
			});
			var subFilterActivity = existFilterActivity.leftExpression.subFilters;
			subFilterActivity.addItem(Terrasoft.createColumnFilterWithParameter(Terrasoft.ComparisonType.EQUAL,
				"Status.Finish", true));
			filters.add("activityStatusFinishedFilter", existFilterActivity);
			// Invoice
			var existFilterInvoice = Ext.create("Terrasoft.CompareFilter", {
				comparisonType: Terrasoft.ComparisonType.EQUAL,
				leftExpression: Ext.create("Terrasoft.SubQueryExpression", {
					columnPath: "[Invoice:Id:SubjectId].Id",
					aggregationType: Terrasoft.AggregationType.COUNT
				}),
				rightExpression: Ext.create("Terrasoft.ParameterExpression", { parameterValue: 0 })
			});
			var subFilterInvoice = existFilterInvoice.leftExpression.subFilters;
			subFilterInvoice.addItem(Terrasoft.createColumnFilterWithParameter(Terrasoft.ComparisonType.EQUAL,
				"PaymentStatus.FinalStatus", true));
			filters.add("invoiceStatusFinishedFilter", existFilterInvoice);

			return filters;
		}

		function getRemindingSelect() {
			var select = Ext.create("Terrasoft.EntitySchemaQuery", {
				rootSchema: Reminding
			});
			select.isDistinct = true;
			select.addColumn("Id");
			select.addColumn("Author");
			select.addColumn("Contact");
			var column = select.addColumn("RemindTime");
			column.orderDirection = Terrasoft.OrderDirection.DESC;
			select.addColumn("Description");
			select.addColumn("SubjectId");
			select.addColumn("Source");
			select.addColumn("SysEntitySchema");
			select.addColumn("SubjectCaption");
			select.addColumn("TypeCaption");
			select.addColumn("[SysSchema:UId:SysEntitySchema].Name", "SchemaName");
			select.filters = remindingFilters();
			return select;
		}

		function getVisaSelect(rowCount) {
			var rCount = !Ext.isEmpty(rowCount) ? rowCount : 40;
			var select = Ext.create("Terrasoft.EntitySchemaQuery", {
				rootSchemaName: "VwVisa",
				rowCount: rCount
			});
			select.addColumn("Id");
			var column = select.addColumn("CreatedOn");
			column.orderDirection = Terrasoft.OrderDirection.ASC;
			select.addColumn("Title");
			select.addColumn("Objective");
			select.addColumn("VisaOwner");
			select.addColumn("VisaSchemaName");
			select.addColumn("VisaObjectId");
			select.addColumn("VisaSchemaTypeId");
			select.addColumn("VisaTypeName");
			select.addColumn("VisaSchemaCaption");
			select.filters = visaFilters();
			return select;
		}

		function getEmailSelect(rowCount) {
			var rCount = !Ext.isEmpty(rowCount) ? rowCount : 40;
			var select = Ext.create("Terrasoft.EntitySchemaQuery", {
				rootSchemaName: "Activity",
				isDistinct: true,
				rowCount: rCount
			});
			select.addColumn("Id");
			select.addColumn("Author");
			select.addColumn("Owner");
			select.addColumn("Contact");
			select.addColumn("Sender");
			select.addColumn("Type");
			select.addColumn("MessageType");
			select.addColumn("Title");
			var column = select.addColumn("StartDate");
			column.orderDirection = Terrasoft.OrderDirection.DESC;
			select.addColumn("[ActivityParticipant:Activity:Id].ReadMark");
			select.filters = emailFilters();
			return select;
		}

		function emailFilters() {
			var filters = Terrasoft.createFilterGroup();
			var currentContactId = Terrasoft.core.enums.SysValue.CURRENT_USER_CONTACT.value;
			filters.addItem(Terrasoft.createColumnFilterWithParameter(Terrasoft.ComparisonType.EQUAL,
				"Type.Id", "E2831DEC-CFC0-DF11-B00F-001D60E938C6"));
			filters.addItem(Terrasoft.createColumnFilterWithParameter(Terrasoft.ComparisonType.EQUAL,
				"MessageType.Id", "7F9D1F86-F36B-1410-068C-20CF30B39373"));
			filters.addItem(Terrasoft.createColumnFilterWithParameter(Terrasoft.ComparisonType.EQUAL,
				"[ActivityParticipant:Activity:Id].Participant.Id", currentContactId));
			filters.addItem(Terrasoft.createColumnFilterWithParameter(Terrasoft.ComparisonType.EQUAL,
				"[ActivityParticipant:Activity:Id].ReadMark", false));
			return filters;
		}

		function visaFilters() {
			var filters = Terrasoft.createFilterGroup();
			var sysAdminUnitId = Terrasoft.core.enums.SysValue.CURRENT_USER.value;
			filters.addItem(Terrasoft.createColumnFilterWithParameter(Terrasoft.ComparisonType.EQUAL,
				"VisaOwner", sysAdminUnitId));
			filters.addItem(Terrasoft.createColumnFilterWithParameter(Terrasoft.ComparisonType.EQUAL,
				"Status.IsFinal", false));
			filters.addItem(Terrasoft.createColumnFilterWithParameter(Terrasoft.ComparisonType.EQUAL,
				"IsCanceled", false));
			return filters;
		}

		function getActivityParticipant(activityId) {
			var select = Ext.create("Terrasoft.EntitySchemaQuery", {
				rootSchemaName: "ActivityParticipant",
				isDistinct: true
			});
			select.addColumn("Activity.Id");
			select.addColumn("[Contact:Id:Participant].Id", "ContactId");
			select.addColumn("[Contact:Id:Participant].Name", "ContactName");
			var filters = Terrasoft.createFilterGroup();
			filters.addItem(Terrasoft.createColumnFilterWithParameter(Terrasoft.ComparisonType.EQUAL,
				"Activity.Id", activityId));
			filters.addItem(Terrasoft.createColumnFilterWithParameter(Terrasoft.ComparisonType.EQUAL,
				"Role.Id", "6A6390C4-A6E1-DF11-971B-001D60E938C6"));
			select.filters = filters;
			return select;
		}

		function getUserRemindingsCountersSelect() {
			var select = Ext.create("Terrasoft.EntitySchemaQuery", {
				rootSchemaName: "VwUserRemindingsCount"
			});
			select.addAggregationSchemaColumn("RemindingsCount", Terrasoft.AggregationType.SUM, "RemindingsCount");
			select.addColumn("SysAdminUnit");
			var filters = Terrasoft.createFilterGroup();
			var currentContactId = Terrasoft.core.enums.SysValue.CURRENT_USER.value;
			filters.addItem(Terrasoft.createColumnFilterWithParameter(Terrasoft.ComparisonType.EQUAL,
				"SysAdminUnit", currentContactId));
			var currentDate = new Date(Ext.Date.now());
			filters.addItem(Terrasoft.createColumnFilterWithParameter(Terrasoft.ComparisonType.LESS_OR_EQUAL,
				"RemindTime", currentDate));
			select.filters = filters;
			return select;
		}

		function getUserEmailsCountersSelect() {
			var select = Ext.create("Terrasoft.EntitySchemaQuery", {
				rootSchemaName: "VwUserEmailsCount"
			});
			select.addColumn("EmailsCount");
			select.addColumn("SysAdminUnit");
			var filters = Terrasoft.createFilterGroup();
			var currentContactId = Terrasoft.core.enums.SysValue.CURRENT_USER.value;
			filters.addItem(Terrasoft.createColumnFilterWithParameter(Terrasoft.ComparisonType.EQUAL,
				"SysAdminUnit", currentContactId));
			select.filters = filters;
			return select;
		}

		function getUserVisaCountersSelect() {
			var select = Ext.create("Terrasoft.EntitySchemaQuery", {
				rootSchemaName: "VwVisa"
			});
			select.addAggregationSchemaColumn("Id", Terrasoft.AggregationType.COUNT,
				"VisaCount");
			select.addColumn("VisaOwner");
			select.filters.addItem(visaFilters());
			return select;
		}


		//ATTENTION: In future may be hidden
		function getRemindingsCountersSelect() {
			var select = Ext.create("Terrasoft.EntitySchemaQuery", {
				rootSchemaName: "VwRemindingsCount"
			});
			select.isDistinct = true;
			select.addColumn("RemindingsCount");
			select.addColumn("EmailsCount");
			select.addColumn("SysAdminUnit");
			var filters = Terrasoft.createFilterGroup();
			var currentContactId = Terrasoft.core.enums.SysValue.CURRENT_USER.value;
			filters.addItem(Terrasoft.createColumnFilterWithParameter(Terrasoft.ComparisonType.EQUAL,
				"SysAdminUnit", currentContactId));
			select.filters = filters;
			return select;
		}

		function getRemindingsCounters(scope, callback) {
			var currentContactId = Terrasoft.core.enums.SysValue.CURRENT_USER.value;
			var currentDate = new Date(Ext.Date.now());
			ServiceHelper.callService(
				"RemindingsDataService",
				"GetRemindingsCount",
				function(response) {
					var responseObject = Terrasoft.decode(response);
					var result = Terrasoft.decode(responseObject.GetRemindingsCountResult);
					var remindingsCount = result.RemindingsCount;
					var emailsCount = result.EmailsCount;
					var visaCount = result.VisaCount;
					var sysAdminUnit = result.SysAdminUnit;
					var esnNotificationsCount = result.ESNNotificationsCount;
					callback.call(scope, {
						remindingsCount: remindingsCount,
						emailsCount: emailsCount,
						visaCount: visaCount,
						sysAdminUnit: sysAdminUnit,
						esnNotificationsCount: esnNotificationsCount
					});
				},
				{
					sysAdminUnitId: currentContactId,
					dueDate: currentDate
				},
			this);
		}

		//ATTENTION: In future may be hidden
		function getCounters(scope, callback) {
			var bq = Ext.create("Terrasoft.BatchQuery");
			bq.add(getRemindingsCountersSelect());
			bq.execute(callback, scope);
		}

		return {
			getCounters: getCounters,
			getRemindingsCounters: getRemindingsCounters,
			getRemindingSelect: getRemindingSelect,
			getEmailSelect: getEmailSelect,
			remindingFilters: remindingFilters,
			emailFilters: emailFilters,
			getActivityParticipant: getActivityParticipant,
			getVisaSelect: getVisaSelect,
			visaFilters: visaFilters
		};
	});


				// Autogenerated Code for schema RemindingsUtilities (End)
// Autogenerated Code for schema MainHeaderModule (Start)
define('MainHeaderModuleResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={
	ProfileImageButtonHintCaption: 'Профиль',
	ProfileMenuItemCaption: 'Ваш профиль',
	ExitMenuItemCaption: 'Выход',
	SystemDesignerCaption: 'Дизайнер системы'
};
var localizableImages={
	'ContactEmptyPhoto': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'MainHeaderModule', resourceItemName: 'ContactEmptyPhoto' }},
	'RemindingsIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'MainHeaderModule', resourceItemName: 'RemindingsIcon' }},
	'Logo': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'MainHeaderModule', resourceItemName: 'Logo' }},
	'YourProfileIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'MainHeaderModule', resourceItemName: 'YourProfileIcon' }},
	'SystemDesignerIcon': {source: Terrasoft.ImageSources.SOURCE_CODE_SCHEMA, params: { schemaName: 'MainHeaderModule', resourceItemName: 'SystemDesignerIcon' }}
};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("MainHeaderModule", ["MainHeaderModuleResources", "IconHelper", "ServiceHelper",
		"MainHeaderExtensions", "IntroPageUtilities", "ConfigurationConstants", "BaseSchemaModuleV2",
		"ImageView", "css!MainHeaderExtensions"],
	function(resources, iconHelper, serviceHelper, extensions, IntroPageUtilities, ConfigurationConstants) {

		/**
		 * Создает конфигурацию кнопки представления с иконкой.
		 * @private
		 * @param config {Object} Конфигурация кнопки представления с иконкой.
		 * @return {Object} Возвращает конфигурацию кнопки представления с иконкой.
		 */
		var createViewIconButtonConfig = function(config) {
			var buttonConfig = iconHelper.createIconButtonConfig(config);
			buttonConfig.imageConfig = {
				source: Terrasoft.ImageSources.URL,
				url: Terrasoft.ImageUrlBuilder.getUrl(config.icon)
			};
			return buttonConfig;
		};

		/**
		 * @class Terrasoft.configuration.MainHeaderModule
		 * Класс MainHeaderModule предназначен для создания экземпляра верхней панели.
		 */
		Ext.define("Terrasoft.configuration.MainHeaderModule", {
			alternateClassName: "Terrasoft.MainHeaderModule",
			extend: "Terrasoft.BaseSchemaModule",

			Ext: null,
			sandbox: null,
			Terrasoft: null,

			/**
			 * Модель представления верхней панели.
			 * @private
			 * @type {Object}
			 */
			viewModel: null,

			/**
			 * Иницализирует начальные значения модуля верхней панели.
			 * @private
			 */
			init: function(callback, scope) {
				this.viewModel = this.createViewModel();
				this.viewModel.Ext = this.Ext;
				this.viewModel.Terrasoft = this.Terrasoft;
				this.viewModel.init();
				if (callback) {
					callback.call(scope || this);
				}
			},

			/**
			 * Отображает представление в контейнер renderTo.
			 * @param {Ext.Element} renderTo Ссылка на контейнер, в котором будет отображаться представление.
			 */
			render: function(renderTo) {
				var view = this.getView();
				view.bind(this.viewModel);
				view.render(renderTo);
				this.viewModel.loadCommandModule();
				this.viewModel.loadProfileButtonMenu();
			},

			/**
			 * Создает модель представления верхней панели.
			 * @protected
			 * @return {Object} Возвращает модель представления верхней панели.
			 */
			createViewModel: function() {
				var values = {
					/**
					 * Внутренний sandbox модели.
					 * @private
					 * @type {Object}
					 */
					sandbox: this.sandbox,

					/**
					 * Заголовок верхней шапки.
					 * @private
					 * @type {String}
					 */
					HeaderCaption: "",

					/**
					 * Имя активного представления.
					 * @private
					 * @type {String}
					 */
					ActiveViewName: "",

					/**
					 * Коллекция кнопок представлений раздела.
					 * @private
					 * @type {Collection}
					 */
					ViewButtons: new Terrasoft.Collection(),

					/**
					 * Флаг, который указывает откуда вызывается верхняя панель.
					 * Если значение True, то вызывается из главного меню - Логотип слева отображается,
					 * справа скрывается.
					 * Если значение False, то стандартный вызов - Логотип слева скрываетя, справа отображается.
					 * @private
					 * @type {Boolean}
					 */
					IsMainMenu: false,

					/**
					 * Флаг, который указывает будет ли видим заголовок верхней панели.
					 * @private
					 * @type {Boolean}
					 */
					IsCaptionVisible: true,

					/**
					 * Флаг, который указывает будет ли видим модуль коммандной строки.
					 * @private
					 * @type {Boolean}
					 */
					IsCommandLineVisible: false,

					IsSSP: (Terrasoft.CurrentUser.userType === Terrasoft.UserType.SSP),

					/**
					 * Флаг, который указывает будет ли видим модуль контекстной справки.
					 * @private
					 * @type {Boolean}
					 */
					IsContextHelpVisible: false,

					/**
					 * Флаг, который указывает будет ли видна кнопка "Дизайнер системы".
					 * @private
					 * @type {Boolean}
					 */
					IsSystemDesignerVisible: false,

					/**
					 * Флаг, который указывает будет ли видимо фото текущего пользователя в верхней панели.
					 * @private
					 * @type {Boolean}
					 */
					IsUserPhotoVisible: true,

					/**
					 * Флаг, который указывает будет ли видим правый логотип в верхней панели.
					 * @private
					 * @type {Boolean}
					 */
					IsLogoVisible: true,

					/**
					 * Флаг, который указывает будет ли видима верхняя панель.
					 * @private
					 * @type {Boolean}
					 */
					IsMainHeaderVisible: true,

					/**
					 * Идентификатор фотографии текущего пользователя.
					 * @private
					 * @type {String}
					 */
					ContactPhotoId: "",

					/**
					 * Название модуля, который сейчас заружен.
					 * @private
					 * @type {String}
					 */
					ModuleName: "",

					/**
					 * Коллекция пунктов меню кнопки профиля пользователя.
					 * @private
					 * @type {Terrasoft.BaseViewModelCollection}
					 */
					ProfileMenuCollection: Ext.create("Terrasoft.BaseViewModelCollection")
				};
				var methods = {
					/**
					 * Загружает модуль коммандной строки.
					 * @private
					 */
					loadCommandModule: function() {
						var commandLineContainer = this.Ext.getCmp("header-command-line-container");
						if (commandLineContainer && commandLineContainer.rendered) {
							this.getSandbox().loadModule("CommandLineModule", {
								renderTo: "header-command-line-container"
							});
						}
					},

					/**
					 * Формирует пункты меню в меню кнопки профиля.
					 * @private
					 */
					loadProfileButtonMenu: function() {
						var profileMenuCollection = this.get("ProfileMenuCollection");
						profileMenuCollection.addItem(Ext.create("Terrasoft.BaseViewModel", {
							values: {
								Caption: resources.localizableStrings.ProfileMenuItemCaption,
								Click: {
									bindTo: "onProfileMenuItemClick"
								},
								MarkerValue: resources.localizableStrings.ProfileMenuItemCaption,
								ImageConfig: resources.localizableImages.YourProfileIcon
							}
						}));
						profileMenuCollection.addItem(Ext.create("Terrasoft.BaseViewModel", {
							values: {
								Type: "Terrasoft.MenuSeparator",
								Caption: ""
							}
						}));
						profileMenuCollection.addItem(Ext.create("Terrasoft.BaseViewModel", {
							values: {
								Caption: resources.localizableStrings.ExitMenuItemCaption,
								Click: {
									bindTo: "onExitMenuItemClick"
								},
								MarkerValue: resources.localizableStrings.ExitMenuItemCaption
							}
						}));
					},

					/**
					 * Выгружает модуль коммандной строки.
					 * @private
					 */
					unloadCommandModule: function() {
						this.getSandbox().unloadModule("CommandLineModule");
					},

					/**
					 * Перезагружает модуль коммандной строки.
					 * @private
					 */
					reloadCommandModule: function() {
						this.unloadCommandModule();
						this.loadCommandModule();
					},

					/**
					 * Получает sandbox.
					 * @private
					 * @return {Object} sandbox.
					 */
					getSandbox: function() {
						return this.get("sandbox");
					},

					/**
					 * Изменяет видимость панели кнопок.
					 * @returns {boolean}
					 */
					getIsButtonsVisible: function() {
						return (this.get("ViewButtons").getCount() > 1);
					},

					/**
					 * Корректирует ширину заголовка в зависимости от наличия кнопок представлений.
					 */
					fixHeaderWidth: function() {
						var captionContainer = this.Ext.get("caption");
						if (!captionContainer) {
							return;
						}
						var viewButtonsVisible = this.getIsButtonsVisible();
						if (viewButtonsVisible) {
							captionContainer.removeCls("fix-width");
						} else {
							captionContainer.addCls("fix-width");
						}
					},

					/**
					 * Изменяет состояние верхней панели.
					 * @private
					 * @param config {Object} Конфигурация состояния верхней панели.
					 */
					onInitDataViews: function(config) {
						var conf = (config && config[0].settings) ? config[0].settings : config[0];
						if (conf.dataViews) {
							this.setButtons(conf);
						} else {
							this.set("ViewButtons", new this.Terrasoft.Collection());
							this.setSettings(conf);
						}
						this.set("HeaderCaption", conf.caption ? conf.caption : "");
						this.set("ModuleName", conf.moduleName ? conf.moduleName : "");
					},

					/**
					 * Устанавливает коллекцию кнопок переключения представлений.
					 * @param config
					 */
					setButtons: function(config) {
						var buttons = new this.Terrasoft.Collection();
						var buttonsContainer = this.Ext.getCmp("button-switch");
						if (buttonsContainer) {
							this.clearContainerItems("button-switch");
							config.dataViews.each(function(item) {
								var bConfig = item.icon ?
									this.createViewIconButtonConfig(item) :
									this.createButtonConfig(item);
								if (item.active) {
									this.set("ActiveViewName", item.name);
								}
								buttons.add(bConfig);
								buttonsContainer.add(bConfig);
							}, this);
							this.set("ViewButtons", buttons);
							this.setSettings(config);
							buttonsContainer.bind(this);
							this.setPressedViewButtons(this.get("ActiveViewName"));
						}
					},

					/**
					 * Обрабатывает нажатие на элемент "Ваш профиль" меню кнопки профиля.
					 * @private
					 */
					onProfileMenuItemClick: function() {
						this.getSandbox().publish("PushHistoryState", {hash: "ProfileModule"});
					},

					/**
					 * Обрабатывает нажатие на элемент "Выход" меню кнопки профиля.
					 * @private
					 */
					onExitMenuItemClick: function() {
						serviceHelper.callService("MainMenuService", "Logout", function() {
							window.logout = true;
							window.location.replace(Terrasoft.loaderBaseUrl + "/simpleLogin");
						}, {}, this);
					},

					/**
					 * Обрабатывает нажатие на логотип.
					 * @private
					 */
					onLogoClick: function() {
						this.openHomePage();
					},

					/**
					 * Открывает домашнюю страницу.
					 * @protected
					 */
					openHomePage: function() {
						this.Terrasoft.SysSettings.querySysSettings(["DefaultIntroPage"], function(values) {
							var defaultIntroPage = values.DefaultIntroPage;
							if (defaultIntroPage) {
								IntroPageUtilities.getDefaultIntroPageName(defaultIntroPage.value,
									function(defaultIntroPageName) {
										var defaultHomeModule = ConfigurationConstants.DefaultHomeModule;
										var hash = this.Terrasoft.combinePath(defaultHomeModule, defaultIntroPageName);
										this.getSandbox().publish("PushHistoryState", {hash: hash});
									}, this);
							}
						}, this);
					},

					/**
					 * Обрабатывает нажатие на кнопку "Дизайнер системы".
					 * @private
					 */
					onSystemDesignerClick: function() {
						this.getSandbox().publish("PushHistoryState", {
							hash: "IntroPage/SystemDesigner"
						});
					},

					/**
					 * Обрабатывает нажатие на заголовок раздела.
					 * @private
					 */
					onCaptionClick: function() {
						this.updateSection();
					},

					/**
					 * Обновляет раздел.
					 * @private
					 */
					updateSection: function() {
						this.getSandbox().publish("UpdateSection", null, [this.get("ModuleName") + "_UpdateSection"]);
					},

					/**
					 * Сбрасывает фильтры и обновляет раздел.
					 * @private
					 */
					resetSection: function() {
						this.getSandbox().publish("ResetSection", null, [this.get("ModuleName") + "_ResetSection"]);
					},

					/**
					 * Обрабатывает нажатие на кнопку переключения видов грида.
					 * @private
					 */
					onViewButtonClick: function() {
						var tag = arguments[3];
						this.setPressedViewButtons(tag);
						var viewConfig = {
							tag: tag,
							moduleName: this.get("ModuleName")
						};
						var sandbox = this.getSandbox();
						sandbox.publish("ChangeDataView", viewConfig, [sandbox.id + "_" + viewConfig.moduleName]);
					},

					/**
					 * Обрабатывает нажатие на кнопку переключения представления в состояние Нажата.
					 * @private
					 * @param viewName {String} Имя представления.
					 */
					setPressedViewButtons: function(viewName) {
						var buttons = this.get("ViewButtons");
						var items = buttons.getItems();
						var isPressed = false;
						this.Terrasoft.each(items, function(item) {
							if (item.tag === viewName) {
								isPressed = true;
								this.set(item.tag + "Active", true);
							} else {
								this.set(item.tag + "Active", false);
							}
						}, this);
						if (!isPressed && items.length > 0) {
							this.set(items[0].tag + "Active", true);
						}
					},

					/**
					 * Устанавливает нужные состояния панелей по конфигурации.
					 * @private
					 * @param config {Object} Конфигурация настроек верхней панели.
					 */
					setSettings: function setSettings(config) {
						var mainHeader = this.Ext.get("mainHeader");
						var centerPanelContainer = this.Ext.get("centerPanelContainer");
						if (config.hasOwnProperty("isMainHeaderVisible")) {
							mainHeader.setVisible(config.isMainHeaderVisible);
							centerPanelContainer.addCls("center-panel-no-padding-top");
						} else {
							mainHeader.setVisible(true);
							centerPanelContainer.removeCls("center-panel-no-padding-top");
						}
						var logoVisible = true;
						if (config.hasOwnProperty("isMainMenu")) {
							this.set("IsMainMenu", config.isMainMenu);
							logoVisible = false;
							this.set("IsLogoVisible", logoVisible);
						} else {
							this.set("IsMainMenu", false);
							logoVisible = true;
							this.set("IsLogoVisible", logoVisible);
						}
						if (config.hasOwnProperty("isCaptionVisible")) {
							this.set("IsCaptionVisible", config.isCaptionVisible);
						} else {
							this.set("IsCaptionVisible", true);
						}
						this.сommandLineVisible(config);
						this.contextHelpVisible(config);
						this.setSystemDesignerVisible(config);
						if (config.hasOwnProperty("isUserPhotoVisible")) {
							this.set("IsUserPhotoVisible", config.isUserPhotoVisible);
						} else {
							this.set("IsUserPhotoVisible", true);
						}
						if (config.hasOwnProperty("isLogoVisible")) {
							this.set("IsLogoVisible", config.isLogoVisible);
						} else {
							this.set("IsLogoVisible", logoVisible);
						}
						if (config.hasOwnProperty("isLogoVisible")) {
							this.set("IsLogoVisible", config.isLogoVisible);
						} else {
							this.set("IsLogoVisible", logoVisible);
						}
					},

					/**
					 * Устанавливает, исходя из конфигурации, свойство панели отвечающее за отображение командной
					 * строки. Отвечает за отображение и скрытие командной строки на панели.
					 * @private
					 * @param {Object} config Конфигурация настроек верхней панели.
					 */
					сommandLineVisible: function(config) {
						var isCommandLineVisible = !this.get("IsSSP");
						if (isCommandLineVisible && config.hasOwnProperty("isCommandLineVisible")) {
							isCommandLineVisible = config.isCommandLineVisible;
						}
						if (this.get("IsCommandLineVisible") !== isCommandLineVisible) {
							this.set("IsCommandLineVisible", isCommandLineVisible);
							this.reloadCommandModule();
						}
					},

					/**
					 * Устанавливает, исходя из конфигурации, свойство панели отвечающее за отображение кнопки помощи.
					 * Отвечает за отображение и скрытие кнопки помощи на панели.
					 * @private
					 * @param {Object} config Конфигурация настроек верхней панели.
					 */
					contextHelpVisible: function(config) {
						var isContextHelpVisible = !this.get("IsSSP");
						if (isContextHelpVisible && config.hasOwnProperty("isContextHelpVisible")) {
							isContextHelpVisible = config.isContextHelpVisible;
						}
						this.set("IsContextHelpVisible", isContextHelpVisible);
					},

					/**
					 * Устанавливает, исходя из конфигурации, свойство панели отвечающее за отображение кнопки
					 * "Дизайнер системы". Отвечает за отображение и скрытие кнопки "Дизайнер системы" на панели.
					 * @private
					 * @param {Object} config Конфигурация настроек верхней панели.
					 */
					setSystemDesignerVisible: function(config) {
						var isSystemDesignerVisible = !this.get("IsSSP");
						if (config.hasOwnProperty("isSystemDesignerVisible")) {
							isSystemDesignerVisible = config.isSystemDesignerVisible;
						}
						Terrasoft.SysSettings.querySysSettings(["BuildType"], function(sysSettings) {
							var buildType = sysSettings.BuildType;
							if (buildType && (buildType.value === ConfigurationConstants.BuildType.Public)) {
								isSystemDesignerVisible = false;
							}
							this.set("IsSystemDesignerVisible", isSystemDesignerVisible);
						}, this);
					},

					/**
					 * Очищает заголовок верхней панели.
					 * @private
					 */
					clearHeader: function() {
						var mainHeader = this.Ext.get("mainHeader");
						if (mainHeader && !mainHeader.isVisible()) {
							mainHeader.setVisible(true);
						}
						this.set("HeaderCaption", "");
					},

					/**
					 * Загружает кнопку контекстной справки.
					 * @param config
					 * @private
					 */
					loadContextHelp: function(config) {
						this.getSandbox().subscribe("GetContextHelpId", function() {
							return config;
						}, [this.getSandbox().id + "_ContextHelpModule"]);
						this.clearContainerItems("header-context-help-container", true);
						this.getSandbox().loadModule("ContextHelpModule", {
							renderTo: "header-context-help-container"
						});
					},

					/**
					 * Очищает элементы контейнера и перерисовывает его.
					 * @param {String} containerId Идентификатор контейнера.
					 * @param {Boolean} needRerender Флаг, указывающий, необходимо ли перерисовывать контейнер
					 * после удаления элементов.
					 */
					clearContainerItems: function(containerId, needRerender) {
						var container = this.Ext.getCmp(containerId);
						if (container && container.getWrapEl()) {
							if (container.getWrapEl()) {
								container.items.each(function(item) {
									container.remove(item);
									item.destroy();
								}, this);
							}
						}
						if (needRerender) {
							container.reRender();
						}
					},

					/**
					 * Создает конфигурацию кнопки представления с иконкой.
					 * @private
					 * @param config {Object} Конфигурационный объект представления.
					 * @return {Object} Конфигурация элемента управления представления с иконкой.
					 */
					createViewIconButtonConfig: createViewIconButtonConfig,

					/**
					 * Создает конфигурация кнопки без иконки.
					 * @private
					 * @param config {Object} Конфигурация.
					 * @return {Object} Конфигурация элемента управления без иконки.
					 */
					createButtonConfig: function(config) {
						var buttonConfig = {
							caption: config.caption ? config.caption : config.name,
							tag: [config.name, config.caption],
							markerValue: [config.name, config.caption],
							className: "Terrasoft.Button",
							style: this.Terrasoft.controls.ButtonEnums.style.DEFAULT,
							pressed: {bindTo: config.name + "Active"},
							click: {bindTo: config.func ? config.func : "onViewButtonClick"},
							classes: {
								textClass: ["view-no-images-class"],
								pressedClass: ["pressed-button-view"]
							},
							menu: {
								items: {
									bindTo: "ProfileMenuCollection"
								},
								ulClass: "profile-menu"
							}
						};
						return buttonConfig;
					},

					/**
					 * Обрабатывает события изменения фото текущего пользователя.
					 * @param {Object} scope Контекст выполнения метода.
					 * @param {Object} response Ответ сервера.
					 */
					onContactPhotoMessageChanged: function(scope, response) {
						if (response && response.Header.Sender !== "UpdateHeaderContactPhoto") {
							return;
						}
						var receivedMessage = Ext.decode(response.Body);
						var photoId = receivedMessage.photoId;
						this.set("ContactPhotoId", photoId);
						var storage = this.Terrasoft.DomainCache;
						storage.setItem("ContactPhotoId", Terrasoft.encode(photoId));
					},

					/**
					 * Инициализирует начальное состояние и события модели.
					 * @protected
					 */
					init: function() {
						var sandbox = this.getSandbox();
						sandbox.subscribe("InitDataViews", function() {
							this.onInitDataViews(arguments);
							this.fixHeaderWidth();
						}, this);
						sandbox.subscribe("ChangeHeaderCaption", function(args) {
							this.set("HeaderCaption", args.caption);
							this.set("ModuleName", args.moduleName ? args.moduleName : "");
							if (args.dataViews) {
								this.setButtons(args);
							}
							this.fixHeaderWidth();
						}, this);
						sandbox.subscribe("InitContextHelp", function(config) {
							this.loadContextHelp(config);
							sandbox.publish("ChangeContextHelpId", config, [sandbox.id + "_ContextHelpModule"]);
						}, this);
						if (this.Ext.isEmpty(this.get("HeaderCaption"))) {
							sandbox.publish("NeedHeaderCaption");
						}
						var storage = this.Terrasoft.DomainCache;
						var contactPhotoId = storage.getItem("ContactPhotoId") ||
							this.Terrasoft.SysValue.CURRENT_USER_CONTACT.primaryImageValue;
						this.set("ContactPhotoId", contactPhotoId);
						Terrasoft.ServerChannel.on(Terrasoft.EventName.ON_MESSAGE,
							this.onContactPhotoMessageChanged, this);
						if (Ext.isFunction(extensions.customInitViewModel)) {
							extensions.customInitViewModel(viewModel);
						}
					},

					/**
					 * Возвращает конфигурацию изображения текущего пользователя.
					 * @private
					 * @return {Object} Конфигурация изображения.
					 */
					getContactPhoto: function() {
						var photoId = this.get("ContactPhotoId");
						if (this.Terrasoft.isEmptyGUID(photoId)) {
							return resources.localizableImages.ContactEmptyPhoto;
						}
						var photoConfig = {
							source: this.Terrasoft.ImageSources.ENTITY_COLUMN,
							params: {
								schemaName: "SysImage",
								columnName: "Data",
								primaryColumnValue: photoId
							}
						};
						return {
							source: Terrasoft.ImageSources.URL,
							url: Terrasoft.ImageUrlBuilder.getUrl(photoConfig)
						};
					}
				};
				if (Ext.isFunction(extensions.extendViewModelValues)) {
					extensions.extendViewModelValues(values);
				}
				if (Ext.isFunction(extensions.extendViewModelMethods)) {
					extensions.extendViewModelMethods(methods);
				}
				var viewModel = this.Ext.create("Terrasoft.BaseViewModel", {
					values: values,
					methods: methods
				});
				return viewModel;
			},

			/**
			 * Получает конфигурацию представления.
			 * @private
			 * @return {Object} Возвращает конфигурацию представления.
			 */
			getView: function() {
				return this.getContainer("mainHeaderContainer", ["main-header", "fixed"], this.getHeaderItems());
			},

			/**
			 * Возвращает представление контейнера.
			 * @private
			 * @param id {String} Идентификатор.
			 * @param wrapClass {Object} Классы контейнера.
			 * @param items {Object} Коллекция дочерних элементов.
			 * @return {Object} Возвращает конфигурацию контейнера.
			 */
			getContainer: function(id, wrapClass, items) {
				var container = this.Ext.create("Terrasoft.Container", {
					id: id,
					classes: {
						wrapClassName: this.Ext.isArray(wrapClass) ? wrapClass : [wrapClass]
					},
					selectors: {
						wrapEl: "#" + id
					},
					items: items ? items : []
				});
				return container;
			},

			/**
			 * Возвращает массив контейнеров элементов представления.
			 * @private
			 * @return {Object} Массив контейнеров элементов представления.
			 */
			getHeaderItems: function() {
				var menuLogoImageContainer = this.getContainer("main-header-menu-logo-image-container",
					"main-header-menu-logo-image-container-class");
				menuLogoImageContainer.add(
					this.getImageConfig("menuLogoImage", ["main-header-menu-logo-image"],
						this.getMenuLogoImageConfig())
				);
				this.setVisibleBinding(menuLogoImageContainer, "IsMainMenu");
				var captionContainer = this.getContainer("caption", "caption-class", [this.generateCaption()]);
				var buttonsContainer = this.getContainer("button-switch", "button-class");
				this.setVisibleBinding(buttonsContainer, "getIsButtonsVisible");
				var emptyContainer = this.getContainer("empty-container", "empty-container-class");
				var commandLineContainer = this.getContainer("header-command-line-container", "command-line-class");
				this.setVisibleBinding(commandLineContainer, "IsCommandLineVisible");
				var imageContainer = this.getContainer("main-header-image-container",
					"main-header-image-container-class");
				var photo = this.getProfileButtonConfig();
				imageContainer.add(photo);
				if (Ext.isFunction(extensions.extendImageContainer)) {
					extensions.extendImageContainer(imageContainer);
				}
				this.setVisibleBinding(imageContainer, "IsUserPhotoVisible");
				var contextHelpContainer = this.getContainer("header-context-help-container", "context-help-class");
				this.setVisibleBinding(contextHelpContainer, "IsContextHelpVisible");
				var systemDesignerContainer = this.getContainer("header-system-designer-container",
					"context-system-designer-class", [ this.createViewIconButtonConfig({
						name: "system-designer",
						hint: resources.localizableStrings.SystemDesignerCaption,
						icon: resources.localizableImages.SystemDesignerIcon,
						func: "onSystemDesignerClick",
						wrapperClass: "system-designer-button",
						imageClass: "system-designer-image"
					})
				]);
				this.setVisibleBinding(systemDesignerContainer, "IsSystemDesignerVisible");
				var logoContainer = this.getContainer("main-header-logo-container", "main-header-logo-container-class");
				if (this.viewModel.get("IsSSP")) {
					logoContainer.add(
							this.getImageConfig("logoImage", ["main-header-logo-image"], this.getLogoImageConfig())
					);
				} else {
					logoContainer.add(
							this.getImageConfig("logoImage", ["main-header-logo-image", "cursor-pointer"],
									this.getLogoImageConfig(), "onLogoClick")
					);
				}
				this.setVisibleBinding(logoContainer, "IsLogoVisible");
				var leftHeaderContainer = this.getContainer("left-header-container", "left-header-container-class");
				var rightHeaderContainer = this.getContainer("right-header-container", "right-header-container-class");
				var rightImageContainer = this.getContainer("header-right-image-container",
						"context-right-image-class");
				leftHeaderContainer.add([
					menuLogoImageContainer,
					captionContainer,
					buttonsContainer,
					emptyContainer,
					commandLineContainer
				]);
				rightImageContainer.add([
					contextHelpContainer,
					systemDesignerContainer
				]);
				rightHeaderContainer.add([
					imageContainer,
					rightImageContainer,
					logoContainer
				]);
				return [
					leftHeaderContainer,
					rightHeaderContainer
				];
			},

			/**
			 * Генерирует конфигурацию элемента управления заголовка.
			 * @private
			 * @return {Object} Конфигурация элемента управления заголовка.
			 */
			generateCaption: function() {
				var caption = {
					className: "Terrasoft.Label",
					classes: {
						labelClass: ["header-section-caption-class", "cursor-pointer"]
					},
					caption: {
						bindTo: "HeaderCaption"
					},
					hint: {
						bindTo: "HeaderCaption"
					},
					markerValue: {
						bindTo: "HeaderCaption"
					},
					visible: {
						bindTo: "IsCaptionVisible"
					},
					click: {
						bindTo: "onCaptionClick"
					}
				};
				return caption;
			},

			/**
			 * Создает конфигурацию кнопки представления с иконкой.
			 * @private
			 * @param config {Object} Конфигурационный объект представления.
			 * @return {Object} Конфигурация элемента управления представления с иконкой.
			 */
			createViewIconButtonConfig: createViewIconButtonConfig,

			/**
			 * Создает конфигурационный объект кнопки профиля пользователя.
			 * @private
			 * @return {Object} Возвращает конфигурационный объект кнопки профиля пользователя.
			 */
			getProfileButtonConfig: function() {
				var buttonConfig = {
					id: "profile-user-button",
					className: "Terrasoft.Button",
					selectors: {
						wrapEl: "#profile-user-button"
					},
					hint: resources.localizableStrings.ProfileImageButtonHintCaption,
					imageConfig: {
						bindTo: "getContactPhoto"
					},
					menu: {
						items: {
							bindTo: "ProfileMenuCollection"
						},
						ulClass: "profile-menu"
					},
					style: Terrasoft.controls.ButtonEnums.style.TRANSPARENT,
					iconAlign: Terrasoft.controls.ButtonEnums.iconAlign.LEFT,
					classes: {
						wrapperClass: ["photo-icon-wrapper"],
						imageClass: ["photo-icon"],
						markerClass: ["profile-photo-btn-marker-class"]
					}
				};
				return buttonConfig;
			},

			/**
			 * Добавляет биндинг видимости к контейнеру.
			 * @private
			 * @param container {Object} Контейнер к которому добавляется биндинг.
			 * @param modelItem {String} Название элемента модели.
			 */
			setVisibleBinding: function(container, modelItem) {
				container.bindings.visible = {
					config: {
						changeMethod: "setVisible"
					},
					modelItem: modelItem
				};
			},

			/**
			 * Возвращает конфигурацию элемента управления с изображением.
			 * @private
			 * @param name {String} Наименование.
			 * @param className {String} Классы элемента управления.
			 * @param config {String} Конфигурация изображения.
			 * @param click {String} Имя метода, который вызовется при клике.
			 * @return {Object} Конфигурация элемента управления с изображением.
			 */
			getImageConfig: function(name, className, config, click) {
				if (!Ext.isArray(className) && !Ext.isEmpty(className)) {
					className = [className];
				}
				var imageUrl = this.getImageSrc(config);
				var imageConfig = {
					id: name,
					selectors: {
						wrapEl: "#" + name
					},
					className: "Terrasoft.ImageView",
					imageSrc: imageUrl,
					classes: { wrapClass: className }
				};
				if (click) {
					imageConfig.click = { bindTo: click };
				}
				return imageConfig;
			},

			/**
			 * Возвращает URL изображения.
			 * @private
			 * @param config
			 * @return {String} URL
			 */
			getImageSrc: function(config) {
				return this.Terrasoft.ImageUrlBuilder.getUrl(config);
			},

			/**
			 * Возвращает конфигурацию изображения логотипа.
			 * @private
			 * @return {Object} Конфигурация изображения.
			 */
			getLogoImageConfig: function() {
				return {
					params: {
						r: "HeaderLogoImage"
					},
					source: this.Terrasoft.ImageSources.SYS_SETTING
				};
			},

			/**
			 * Возвращает конфигурацию изображения логотипа.
			 * @private
			 * @return {Object} Конфигурация изображения логотипа.
			 */
			getMenuLogoImageConfig: function() {
				return {
					params: {
						r: "MenuLogoImage"
					},
					source: this.Terrasoft.ImageSources.SYS_SETTING
				};
			}
		});
		return Terrasoft.MainHeaderModule;
	});

				// Autogenerated Code for schema MainHeaderModule (End)
// Autogenerated Code for schema StructureExplorerUtilitiesV2 (Start)
define('StructureExplorerUtilitiesV2Resources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("StructureExplorerUtilitiesV2", ["terrasoft", "ModalBox"],
	function(Terrasoft, ModalBox) {

//		Example:
//			Terrasoft.StructureExplorerUtilities.Open({
//						handlerMethodName: "onLookupResult",
//						moduleConfig: config,
//						scope: this
//					});

		Ext.define("Terrasoft.configuration.StructureExplorerUtilities", {
			extend: "Terrasoft.BaseObject",
			alternateClassName: "Terrasoft.StructureExplorerUtilities",

			singleton: true,

			/**
			 * Контейнер в который будет отрисован StructureExplorer.
			 * @private
			 * @type {Object}
			 */
			modalBoxContainer: null,

			/**
			 * Конфигурация открытия модального окна.
			 * @private
			 * @type {Object}
			 */
			modalBoxSize: {
				minHeight : "1",
				minWidth : "1",
				maxHeight : "100",
				maxWidth : "100"
			},

			/**
			 * Возвращает фиксированный контейнер в модальном окне.
			 * @protected
			 * @returns {Object}
			 */
			getFixedHeaderContainer: function() {
				return ModalBox.getFixedBox();
			},

			/**
			 * Возвращает основной контейнер в модальном окне.
			 * @protected
			 * @returns {Object}
			 */
			getGridContainer: function() {
				return this.modalBoxContainer;
			},

			/**
			 * Обновляет размеры окна в соответствии с контентом.
			 */
			UpdateSize: function() {
				ModalBox.updateSizeByContent();
			},

			/**
			 * Подготавливает модальное окно для загрузки туда модуля.
			 * @private
			 */
			prepareModalBox: function() {
				this.modalBoxContainer = ModalBox.show(this.modalBoxSize);
				ModalBox.setSize(820, 600);
			},

			/**
			 * Закрывает модальное окно.
			 */
			closeModalBox: function() {
				if (this.modalBoxContainer || ModalBox.getFixedBox()) {
					ModalBox.close();
					this.modalBoxContainer = null;
				}
			},

			/**
			 * Генерирует идентификатор для модуля.
			 * @private
			 * @param {Object} sandbox Песоцница модуля, вызывающего открытие выбора колонки.
			 * @return {string} Возвращает идентификатор для модуля.
			 */
			getStructureExplorerPageId: function(sandbox) {
				return sandbox.id + "_StructureExplorerModule";
			},

			/**
			 * Регистрирует необходимые модулю сообщения.
			 * @protected
			 * @param {Object} sandbox Песочница модуля.
			 */
			registerStructureExplorerModuleMessages: function(sandbox) {
				var messages = {
					"StructureExplorerInfo": {
						"mode": Terrasoft.MessageMode.PTP,
						"direction": Terrasoft.MessageDirectionType.SUBSCRIBE
					},
					"ColumnSelected": {
						"mode": Terrasoft.MessageMode.PTP,
						"direction": Terrasoft.MessageDirectionType.SUBSCRIBE
					}
				};
				sandbox.registerMessages(messages);
			},

			/**
			 * Открывает окно выбора колонки.
			 * @param {Object} config Конфигурация модуля выбора колонки.
			 * @param {String} config.handlerMethodName Имя метода-обработчика результата выбора. Должен содержатся в
			 * окружении "scope".
			 * @param {Function} config.handlerMethod Метод-обработчик результата выбора.
			 * @param {Terrasoft.BaseViewModel} config.scope Окружение, в рамках которого вызывается метод-обработчик.
			 * Также хранит параметры открытия окна выбора из справочника
			 * @param {Object} [config.sandbox] Песоцница модуля, вызывающего открытие справочника
			 * Необязательный, если ее содержит окружение.
			 * @param {Object} config.lookupConfig Объект параметров для страницы выбора из справочника.
			 */
			open: function(config) {
				var scope = config.scope;
				var sandbox = config.sandbox || scope.sandbox;
				var moduleConfig = config.moduleConfig;
				moduleConfig.handlerMethodName = config.handlerMethodName;
				moduleConfig.handlerMethod = config.handlerMethod;
				var structureExplorerPageId = moduleConfig.structureExplorerPageId = this.getStructureExplorerPageId(sandbox);
				scope.structureExplorerConfig = moduleConfig;
				this.registerStructureExplorerModuleMessages(sandbox);
				sandbox.subscribe("StructureExplorerInfo", function() {
					return this.structureExplorerConfig;
				}, scope, [structureExplorerPageId]);
				sandbox.subscribe("ColumnSelected", function(args) {
					var structureExplorerConfig = this.structureExplorerConfig;
					if (Ext.isFunction(this[structureExplorerConfig.handlerMethodName])) {
						this[structureExplorerConfig.handlerMethodName](args);
					}
					if (Ext.isFunction(structureExplorerConfig.handlerMethod)) {
						structureExplorerConfig.handlerMethod.call(scope, args);
					}
					sandbox.unloadModule(structureExplorerConfig.structureExplorerPageId);
					Terrasoft.LookupUtilities.CloseModalBox();
					delete this.structureExplorerConfig;
				}, scope, [structureExplorerPageId]);
				this.prepareModalBox();
				sandbox.loadModule("StructureExploreModule", {
					renderTo: this.getGridContainer(),
					id: structureExplorerPageId
				});
			}
		});

	});


				// Autogenerated Code for schema StructureExplorerUtilitiesV2 (End)
// Autogenerated Code for schema ConfigurationEnumsV2 (Start)
define('ConfigurationEnumsV2Resources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={
	AllowRightCaption: 'Разрешено',
	AllowAndGrantRightCaption: 'Разрешено с правом делегирования',
	DenyRightCaption: 'Запрещено'
};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("ConfigurationEnumsV2", ["ConfigurationEnumsV2Resources"], function(resources) {

	Ext.ns("Terrasoft.ConfigurationEnums");

	Terrasoft.ConfigurationEnums.CardOperation = {
		ADD: "add",
		EDIT: "edit",
		COPY: "copy"
	};

	Ext.ns("Terrasoft.RightsEnums");

	Terrasoft.RightsEnums.operationTypes = {
		"read": 0,
		"edit": 1,
		"delete": 2
	};
	Terrasoft.RightsEnums.rightLevels = {
		allow: {
			Value: 1,
			Name: resources.localizableStrings.AllowRightCaption
		},
		allowAndGrant: {
			Value: 2,
			Name: resources.localizableStrings.AllowAndGrantRightCaption
		},
		deny: {
			Value: 0,
			Name: resources.localizableStrings.DenyRightCaption
		}
	};
	Terrasoft.RightsEnums.sysAdminUnitType = {
		"0": "DF93DCB9-6BD7-DF11-9B2A-001D60E938C6",
		"1": "B659F1C0-6BD7-DF11-9B2A-001D60E938C6",
		"2": "B759F1C0-6BD7-DF11-9B2A-001D60E938C6",
		"3": "462E97C7-6BD7-DF11-9B2A-001D60E938C6",
		"4": "472E97C7-6BD7-DF11-9B2A-001D60E938C6",
		"5": "F4044C41-DF2B-E111-851E-00155D04C01D"
	};

	/** @enum
	 * Шаблон тела схемы.
	 */
	Ext.ns("Terrasoft.ClientUnitSchemaBodyTemplate");
	Terrasoft.ClientUnitSchemaBodyTemplate[Terrasoft.SchemaType.EDIT_VIEW_MODEL_SCHEMA] =
		"define(\"{0}\", [], function() {\n" +
		"\treturn {\n" +
		"\t\tentitySchemaName: \"{1}\",\n" +
		"\t\tdetails: /**SCHEMA_DETAILS*/{}/**SCHEMA_DETAILS*/,\n" +
		"\t\tdiff: /**SCHEMA_DIFF*/[]/**SCHEMA_DIFF*/,\n" +
		"\t\tmethods: {},\n" +
		"\t\trules: {}\n" +
		"\t};\n" +
		"});\n";
	Terrasoft.ClientUnitSchemaBodyTemplate[Terrasoft.SchemaType.MODULE_VIEW_MODEL_SCHEMA] =
	Terrasoft.ClientUnitSchemaBodyTemplate[Terrasoft.SchemaType.DETAIL_VIEW_MODEL_SCHEMA] =
	Terrasoft.ClientUnitSchemaBodyTemplate[Terrasoft.SchemaType.GRID_DETAIL_VIEW_MODEL_SCHEMA] =
		"define(\"{0}\", [], function() {\n" +
		"\treturn {\n" +
		"\t\tentitySchemaName: \"{1}\",\n" +
		"\t\tdetails: /**SCHEMA_DETAILS*/{}/**SCHEMA_DETAILS*/,\n" +
		"\t\tdiff: /**SCHEMA_DIFF*/[]/**SCHEMA_DIFF*/,\n" +
		"\t\tmethods: {}\n" +
		"\t};\n" +
		"});\n";

});


				// Autogenerated Code for schema ConfigurationEnumsV2 (End)
// Autogenerated Code for schema ConfigurationConstantsV2 (Start)
define('ConfigurationConstantsV2Resources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("ConfigurationConstantsV2", function() {

	Ext.ns("Terrasoft.ConfigurationConstants");

});

				// Autogenerated Code for schema ConfigurationConstantsV2 (End)
// Autogenerated Code for schema MaskHelper (Start)
define('MaskHelperResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("MaskHelper", ["ext-base", "terrasoft", "MaskHelperResources"],
	function(Ext, Terrasoft) {
		/**
		 * Идентификатор маски загрузки раздела.
		 * @Type {String}
		 */
		var bodyMaskId;

		/**
		 * Отображает маску загрузки страницы, если она не была отображена.
		 * @param {Object} config Параметры для маски.
		 * @param {Number} config.timeout Задержка перед отображением маски.
		 * @param {Float} config.opacity Степень прозрачности маски в диапазоне с 0 до 1.
		 * @param {String} config.backgroundColor Цвет фона заливки маски.
		 */
		var showBodyMask = function(config) {
			bodyMaskId = Terrasoft.Mask.show(config) || bodyMaskId;
		};

		/**
		 * Скрывает маску загрузки страницы, если она была отображена.
		 */
		var hideBodyMask = function() {
			if (!Ext.isEmpty(bodyMaskId)) {
				Terrasoft.Mask.hide(bodyMaskId);
			}
		};

		return {
			ShowBodyMask: showBodyMask,
			HideBodyMask: hideBodyMask
		};
	});


				// Autogenerated Code for schema MaskHelper (End)
// Autogenerated Code for schema ModalBox (Start)
define('ModalBoxResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("ModalBox", ["ext-base", "css!ModalBox"], function(Ext) {
	/**
	 * Максимальный размер модуля в процентах.
	 * @private
	 * @type {Number}
	 */
	var fullSize = 100;

	/**
	 * Размер модуля по умолчанию.
	 * @private
	 * @type {Number}
	 */
	var defaultSize = 50;

	/**
	 * id модуля.
	 * @private
	 * @type {String}
	 */
	var id = "";

	/**
	 * Ссылка на элемент div верхнего уровня.
	 * @private
	 * @type {Ext.Element}
	 */
	var modalBoxEl = null;

	/**
	 * Ссылка на элемент модальности.
	 * @private
	 * @type {Ext.Element}
	 */
	var coverEl = null;

	/**
	 * Ссылка на внутрений div элемент.
	 * @private
	 * @type {Ext.Element}
	 */
	var innerBoxEl = null;

	/**
	 * Ссылка на внутрений div элемент с фиксированым положением.
	 * @private
	 * @type {Ext.Element}
	 */
	var fixedBoxEl = null;

	/**
	 * Объект содержащий минимальные и максимальные размеры модуля в пикселях.
	 * @private
	 * @type {Number}
	 */
	var boxSize = null;

	/**
	 * Объект селекторов
	 * @private
	 * @type {Object}
	 */
	var selectors = null;

	/**
	 * Признак наличия вертикальной полосы прокрутки.
	 */
	var disableScroll = false;
	
	var openedModalBoxCssClass = "ts-modalbox-opened";

	/**
	 * Список названий css классов используемых в модуле.
	 * @private
	 * @type {Object}
	 */
	var configCssClasses = {
		modalBox: "ts-modalbox",
		cover: "ts-modalbox-cover",
		centerPosition: "ts-modalbox-center-position",
		innerBox: "ts-modalbox-innerbox",
		fixedBox: "ts-modalbox-fixedbox"
	};

	/*jshint white:false */
	/**
	 * Шаблон разметки модуля.
	 * @private
	 * @type {Array}
	 */
	var boxTemplate = [
		"<div id=\"{id}-cover\" class=\"{coverClass}\"></div>",
		"<div id=\"{id}-box\" class=\"{boxClasses}\" style=\"{boxStyles}\">",
		"<div id=\"{id}-fixedBox\" class=\"{fixedBoxClasses}\"></div>",
		"<div id=\"{id}-innerBox\" class=\"{innerBoxClasses}\"></div>",
		"</div>"
	];
	/*jshint white:true */

	/**
	 * Экземпляр класса Ext.KeyMap для обработки нажатия кнопки esc.
	 * @private
	 * @type {Ext.KeyMap}
	 */
	var keyMap = null;

	/**
	 * Callback-функция вызываемая при закрытии окна.
	 * @private
	 * @type {Function|null}
	 */
	var onClosed = null;

	/**
	 * Иницализирует начальные значения модуля.
	 * @private
	 * @param {Object} cfg Параметры модуля.
	 * @param {Function} onCloseCallback Callback-функция которая будет вызвана при закрытии окна.
	 * @param {Object} scope Контекст выполнения onCloseCallback.
	 */
	function init(cfg, onCloseCallback, scope) {
		id = Ext.id();
		cfg = cfg || {};
		selectors = {
			modalBoxEl: id + "-box",
			coverEl: id + "-cover",
			innerBoxEl: id + "-innerBox",
			fixedBoxEl: id + "-fixedBox"
		};
		if (cfg.widthPixels && cfg.heightPixels) {
			boxSize = {
				minWidth: cfg.widthPixels,
				minHeight: cfg.heightPixels,
				maxHeight: cfg.heightPixels,
				maxWidth: cfg.widthPixels
			};
		} else {
			boxSize = calculatePixelSizes(cfg);
		}
		disableScroll = cfg.disableScroll || false;
		if (onCloseCallback) {
			onClosed = onCloseCallback.bind(scope);
		}
	}

	/**
	 * Вычисляет Ext элементы по селекторам.
	 * @private
	 */
	function applySelectors() {
		modalBoxEl = Ext.get(selectors.modalBoxEl);
		if (!modalBoxEl) {
			throw new Terrasoft.ItemNotFoundException();
		}
		coverEl = Ext.get(selectors.coverEl);
		if (!coverEl) {
			throw new Terrasoft.ItemNotFoundException();
		}
		innerBoxEl = Ext.get(selectors.innerBoxEl);
		if (!innerBoxEl) {
			throw new Terrasoft.ItemNotFoundException();
		}
		fixedBoxEl = Ext.get(selectors.fixedBoxEl);
		if (!fixedBoxEl) {
			throw  new Terrasoft.ItemNotFoundException();
		}
		modalBoxEl.on("click", function(event) {
			event.stopEvent();
		});
		coverEl.on("wheel", function(event) {
			event.preventDefault();
		});
		coverEl.on("click", function(event) {
			event.stopEvent();
		});
		fixedBoxEl.on("wheel", function(event) {
			event.preventDefault();
		});
		if (Ext.isIE9 || Ext.isChrome || Ext.isSafari || Ext.isOpera) {
			coverEl.on("mousewheel", function(event) {
				event.preventDefault();
			});
			fixedBoxEl.on("mousewheel", function(event) {
				event.preventDefault();
			});
		} else if (Ext.isGecko) {
			coverEl.on("DOMMouseScroll", function(event) {
				event.preventDefault();
			});
			fixedBoxEl.on("DOMMouseScroll", function(event) {
				event.preventDefault();
			});
		} else {
			coverEl.on("onmousewheel", function(event) {
				event.preventDefault();
			});
			fixedBoxEl.on("onmousewheel", function(event) {
				event.preventDefault();
			});
		}
	}

	function getFixedBoxClasses() {
		var fixedBoxClasses = [];
		fixedBoxClasses.push(configCssClasses.fixedBox);
		return fixedBoxClasses.join(" ");
	}

	/**
	 * Генерирует разметку модуля.
	 * @private
	 * @param {Object} config Конфигурация модального окна.
	 * @return {Ext.XTemplate}
	 */
	function prepareModalBoxHtml(config) {
		var template = new Ext.XTemplate(boxTemplate.join(""));
		return template.apply({
			coverClass: getCoverClasses(),
			boxClasses: getBoxClasses(config),
			boxStyles: getBoxStyles(),
			innerBoxClasses: configCssClasses.innerBox,
			id: id,
			fixedBoxClasses: getFixedBoxClasses()
		});
	}

	/**
	 * Возвращает строку со списком css-классов для элеманта модульности.
	 * @private
	 * @return {String}
	 */
	function getCoverClasses() {
		var coverClasses = [];
		coverClasses.push(configCssClasses.cover);
		return coverClasses.join(" ");
	}

	/**
	 * Возвращает строку со списком css-классов для элемент div верхнего уровня.
	 * @private
	 * @param {Object} config Конфигурация модального окна.
	 * @return {String}
	 */
	function getBoxClasses(config) {
		var boxClasses = [];
		boxClasses.push(configCssClasses.modalBox);
		boxClasses.push(configCssClasses.centerPosition);
		boxClasses = boxClasses.concat(config.boxClasses);
		return boxClasses.join(" ");
	}

	/**
	 * Возвращает строку со списком inline-стилей для элемент div верхнего уровня.
	 * @private
	 * @return {String}
	 */
	function getBoxStyles() {
		var styles = {
			minWidth: boxSize.minWidth + "px",
			minHeight: boxSize.minHeight + "px",
			maxHeight: boxSize.maxHeight + "px",
			maxWidth: boxSize.maxWidth + "px",
			width: boxSize.minWidth + "px",
			height: boxSize.minHeight + "px"
		};
		return Ext.DomHelper.generateStyles(styles);
	}

	/**
	 * Пересчитывает относительные размеры заданые в процентах в пиксели экрана.
	 * @private
	 * @param {Object} boxSizePercents объект содержащий минимальные и максимальные размеры в процентах.
	 * @return {Object} объект содержащий минимальные и максимальные размеры в пикселях.
	 */
	function calculatePixelSizes(boxSizePercents) {
		var boxSizePixels = {};
		var minHeight = boxSizePercents.minHeight;
		var maxHeight = boxSizePercents.maxHeight;
		var minWidth = boxSizePercents.minWidth;
		var maxWidth = boxSizePercents.maxWidth;
		var viewportHeight = Ext.Element.getViewportHeight() / fullSize;
		var viewportWidth = Ext.Element.getViewportWidth() / fullSize;
		boxSizePixels.minHeight = (minHeight > 0) ? viewportHeight * minHeight : viewportHeight * defaultSize;
		boxSizePixels.minWidth = (minWidth > 0) ? viewportWidth * minWidth : viewportWidth * defaultSize;
		boxSizePixels.maxHeight = (maxHeight > 0) ? viewportHeight * maxHeight : viewportWidth * fullSize;
		boxSizePixels.maxWidth = (maxWidth > 0) ? viewportWidth * maxWidth : viewportWidth * fullSize;
		return boxSizePixels;
	}

	/**
	 * Обработчик события нажатия кнопки ESC.
	 * @private
	 */
	function onEscKeyPressed() {
		close(true);
	}

	/**
	 * Показывает модуль, возвращает ссылку на элемент куда будет отображатся модержанее пользовательского контента.
	 * @param {Object} [config] Объект содержащий установленные размеры в пикселях или
	 * минимальные и максимальные размеры в процентах от размера экрана.
	 * @param {Number} [config.minWidth] Минимальная ширина в процентах.
	 * @param {Number} [config.maxHeight] Максимальная высота в процентах.
	 * @param {Number} [config.maxWidth] Максимальная ширина в процентах.
	 * @param {Number} [config.minHeight] Минимальная высота в процентах.
	 * @param {Number} [config.widthPixels] Фиксированная ширина в пикселях.
	 * @param {Number} [config.heightPixels] Фиксированная высота в пикселях.
	 * @param {Array} [config.boxClasses] Css-классы внешнего контейнера.
	 * @param {Function} onCloseCallback Callback-функция которая будет вызвана при закрытии окна.
	 * @param {Object} scope Контекст выполнения onCloseCallback.
	 * @return {Ext.Element} Контейнер для содержимого.
	 */
	function show(config, onCloseCallback, scope) {
		if (modalBoxEl || coverEl) {
			return;
		}
		var body = document.body;
		if (!body) {
			return;
		}
		var bodyEl = Ext.getBody();
		bodyEl.addCls(openedModalBoxCssClass);
		keyMap =  new Ext.util.KeyMap(Ext.getBody(), [{
			key: Ext.EventObject.ESC,
			scope: this,
			fn: onEscKeyPressed
		}]);
		init(config, onCloseCallback, scope);
		var modalBoxHtml = prepareModalBoxHtml(config);
		Ext.DomHelper.insertHtml("beforeEnd", body, modalBoxHtml);
		applySelectors();
		return innerBoxEl;
	}

	/**
	 * Обновляет размеры окна. Если размеры контета превишают заданый максимальный размер -
	 * появляется вертикальная прокрутка.
	 */
	function updateSizeByContent() {
		if (!modalBoxEl) {
			return;
		}
		var modalBoxWidthOffset = modalBoxEl.getPadding("lr") + modalBoxEl.getBorderWidth("lr");
		var modalBoxHeightOffset = modalBoxEl.getPadding("tb") + modalBoxEl.getBorderWidth("tb");
		var width = innerBoxEl.getComputedWidth() + modalBoxWidthOffset;
		// значение округляется - может приводить к появлению полосы прокрутки
		var height = innerBoxEl.getComputedHeight() + modalBoxHeightOffset + 1;
		var maxHeight = boxSize.maxHeight;
		// BrowserSupport: IE8 явная установка высоты т.к. при height > maxHeight окно частично
		// смещается вверх за пределы экрана
		if (Ext.isIE8 && height > maxHeight) {
			height = maxHeight;
		}
		if (disableScroll) {
			modalBoxEl.applyStyles("overflow-y: hidden");
		}
		modalBoxEl.setSize(width, height);
	}

	/**
	 * Устанавливает размеры модального окна в пикселях.
	 */
	function setSize(width, height) {
		if (modalBoxEl) {
			modalBoxEl.setSize(width, height);
		}
	}

	/**
	 * Закрывает окно, уничтожает DOM модуля, удаляет ссылкы на элементы.
	 * @param {Boolean} needDestroyNestedModule Флаг выгрузки загруженого в модальное окно модуля.
	 * Передается как параметр в callback-функцию onClosed.
	 */
	function close(needDestroyNestedModule) {
		if (onClosed) {
			onClosed(needDestroyNestedModule);
		}
		var bodyEl = Ext.getBody();
		if (bodyEl) {
			bodyEl.removeCls(openedModalBoxCssClass);
		}
		keyMap.destroy();
		modalBoxEl.destroy();
		coverEl.destroy();
		innerBoxEl.destroy();
		id = "";
		modalBoxEl = null;
		innerBoxEl = null;
		coverEl = null;
		boxSize = null;
		selectors = null;
		disableScroll = false;
		fixedBoxEl = null;
	}

	function getFixedBox() {
		return fixedBoxEl;
	}

	return {
		getFixedBox: getFixedBox,
		show: show,
		setSize: setSize,
		updateSizeByContent: updateSizeByContent,
		close: close
	};

});

				// Autogenerated Code for schema ModalBox (End)
// Autogenerated Code for schema LookupUtilitiesV2 (Start)
define('LookupUtilitiesV2Resources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("LookupUtilitiesV2", ["terrasoft", "MaskHelper", "ModalBox"],
	function(Terrasoft, MaskHelper, ModalBox) {

//		Example:
//			Terrasoft.LookupUtilities.Open({
//						handlerMethodName: "onLookupResult",
//						lookupConfig: config,
//						scope: this
//					});

		Ext.define("Terrasoft.configuration.LookupUtilities", {
			extend: "Terrasoft.BaseObject",
			alternateClassName: "Terrasoft.LookupUtilities",

			singleton: true,

			/**
			 * Контейнер в который будет отрисован LookupPage
			 * @private
			 * @type {Object}
			 */
			modalBoxContainer: null,

			/**
			 * Конфигурация открытия модального окна
			 * @private
			 * @type {Object}
			 */
			modalBoxSize: {
				minHeight : "1",
				minWidth : "1",
				maxHeight : "100",
				maxWidth : "100"
			},

			/**
			 * Возвращает фиксированный контейнер в модальном окне
			 * @protected
			 * @returns {Object}
			 */
			getFixedHeaderContainer: function() {
				return ModalBox.getFixedBox();
			},

			/**
			 * Возвращает основной контейнер в модальном окне
			 * @protected
			 * @returns {Object}
			 */
			getGridContainer: function() {
				return this.modalBoxContainer;
			},

			/**
			 * Обновляет размеры окна в соответствии с контентом
			 */
			UpdateSize: function() {
				ModalBox.updateSizeByContent();
			},

			/**
			 * Подготавливает модальное окно для загрузки туда модуля справочника
			 * @private
			 */
			prepareModalBox: function() {
				this.modalBoxContainer = ModalBox.show(this.modalBoxSize);
				ModalBox.setSize(820, 600);
			},

			/**
			 * Закрывает модальное окно Lookup-а и выгружает модуль
			 */
			CloseModalBox: function() {
				if (this.modalBoxContainer) {
					ModalBox.close();
					this.modalBoxContainer = null;
				}
			},

			/**
			 * Генерирует идентификатор для модуля справочника
			 * @private
			 * @param {Object} sandbox Песоцница модуля, вызывающего открытие справочника
			 * @return {string}
			 */
			getLookupPageId: function(sandbox) {
				return sandbox.id + "_LookupPage";
			},

			/**
			 * Открывает окно выбора из справочника
			 * @param {Object} config Конфигурация открытия выбора из справочника
			 * @param {String} config.handlerMethodName Имя метода-обработчика результата выбора. Должен содержатся в
			 * окружении "scope"
			 * @param {Terrasoft.BaseViewModel} config.scope Окружение, в рамках которого вызывается метод-обработчик.
			 * Также хранит параметры открытия окна выбора из справочника
			 * @param {Object} [config.sandbox] Песоцница модуля, вызывающего открытие справочника
			 * Необязательный, если ее содержит окружение
			 * @param {Object} config.lookupConfig Объект параметров для страницы выбора из справочника
			 */
			Open: function(config) {
				var scope = config.scope;
				var sandbox = config.sandbox || scope.sandbox;
				var openLookupConfig = config.lookupConfig;
				openLookupConfig.handlerMethodName = config.handlerMethodName;
				var lookupPageId = openLookupConfig.lookupPageId = this.getLookupPageId(sandbox);
				scope.lookupPageParams = openLookupConfig;
				//todo: реализовать регистрацию сообщений в песоцнице модуля
				sandbox.subscribe("LookupInfo", function() {
					return this.lookupPageParams;
				}, scope, [lookupPageId]);
				sandbox.subscribe("ResultSelectedRows", function(args) {
					var lookupPageParams = this.lookupPageParams;
					if (Ext.isFunction(this[lookupPageParams.handlerMethodName])) {
						this[lookupPageParams.handlerMethodName](args);
					}
					Terrasoft.LookupUtilities.CloseModalBox();
					this.sandbox.unloadModule(lookupPageParams.lookupPageId);
					delete this.lookupPageParams;
				}, scope, [lookupPageId]);
				this.prepareModalBox();
				MaskHelper.ShowBodyMask();
				sandbox.loadModule("LookupPageV2", {
					renderTo: this.getGridContainer(),
					id: lookupPageId
				});
			}
		});

	});

				// Autogenerated Code for schema LookupUtilitiesV2 (End)
// Autogenerated Code for schema BootstrapModules (Start)
define('BootstrapModulesResources', ['terrasoft'], function(Terrasoft) {
var localizableStrings={};
var localizableImages={};
return {localizableStrings:localizableStrings,localizableImages:localizableImages};
});
define("BootstrapModules", function() {
	return {
		"LookupUtilitiesV2": {},
		"ConfigurationEnumsV2": {},
		"ConfigurationConstantsV2": {},
		"DashboardEnums": {},
		"StructureExplorerUtilitiesV2": {}
	};
});

				// Autogenerated Code for schema BootstrapModules (End)
// Autogenerated Code for schema ConfigurationBootstrap (Start)
define("ConfigurationBootstrap", ["terrasoft", "BootstrapModules"],
	function(Terrasoft, bootstrapModules) {
	var modulesNames = [];
	Terrasoft.each(bootstrapModules, function() {
		var moduleName = arguments[1];
		modulesNames.push(moduleName);
	});
	require(modulesNames, function() {
		Terrasoft.each(arguments, function(module) {
			if (module && module.init) {
				module.init();
			}
		});
	});//a
});
				// Autogenerated Code for schema ConfigurationBootstrap (End)
